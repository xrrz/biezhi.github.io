[{"title":"跟上Java8 - 优化工作中那些屎代码","date":"2017-07-23T16:00:00.000Z","path":"2017/07/24/keep-up-with-java8-optimizing.html","text":"","tags":[{"name":"Java8","slug":"Java8","permalink":"http://biezhi.me/tags/Java8/"},{"name":"优化","slug":"优化","permalink":"http://biezhi.me/tags/优化/"}]},{"title":"跟上Java8 - 七七八八的黑科技","date":"2017-07-22T16:00:00.000Z","path":"2017/07/23/keep-up-with-java8-tips.html","text":"","tags":[{"name":"Java8","slug":"Java8","permalink":"http://biezhi.me/tags/Java8/"},{"name":"系列","slug":"系列","permalink":"http://biezhi.me/tags/系列/"}]},{"title":"跟上Java8 - 使用lambda并发编程","date":"2017-07-21T16:00:00.000Z","path":"2017/07/22/keep-up-with-java8-concurrent.html","text":"","tags":[{"name":"Java8","slug":"Java8","permalink":"http://biezhi.me/tags/Java8/"},{"name":"concurrent","slug":"concurrent","permalink":"http://biezhi.me/tags/concurrent/"},{"name":"并发","slug":"并发","permalink":"http://biezhi.me/tags/并发/"}]},{"title":"跟上Java8 - 你忽略了的新特性","date":"2017-07-20T16:00:00.000Z","path":"2017/07/21/keep-up-with-java8-features.html","text":"","tags":[{"name":"Java8","slug":"Java8","permalink":"http://biezhi.me/tags/Java8/"},{"name":"features","slug":"features","permalink":"http://biezhi.me/tags/features/"}]},{"title":"跟上Java8 - 日期和时间最实用技巧","date":"2017-07-19T16:00:00.000Z","path":"2017/07/20/keep-up-with-java8-datetime.html","text":"","tags":[{"name":"Java8","slug":"Java8","permalink":"http://biezhi.me/tags/Java8/"},{"name":"datetime","slug":"datetime","permalink":"http://biezhi.me/tags/datetime/"}]},{"title":"跟上Java8 - 函数式编程","date":"2017-07-18T16:00:00.000Z","path":"2017/07/19/keep-up-with-java8-functional-programming.html","text":"","tags":[{"name":"Java8","slug":"Java8","permalink":"http://biezhi.me/tags/Java8/"},{"name":"函数式","slug":"函数式","permalink":"http://biezhi.me/tags/函数式/"}]},{"title":"跟上Java8 - stream入门与实战","date":"2017-07-17T16:00:00.000Z","path":"2017/07/18/keep-up-with-java8-stream.html","text":"","tags":[{"name":"Java8","slug":"Java8","permalink":"http://biezhi.me/tags/Java8/"},{"name":"stream","slug":"stream","permalink":"http://biezhi.me/tags/stream/"}]},{"title":"跟上Java8 - 了解lambda","date":"2017-07-16T16:00:00.000Z","path":"2017/07/17/keep-up-with-java8-lambda.html","text":"从java8出现以来lambda是最重要的特性之一，它可以让我们用简洁流畅的代码完成一个功能。 很长一段时间java被吐槽是冗余和缺乏函数式编程能力的语言，随着函数式编程的流行java8种也引入了 这种编程风格。在此之前我们都在写匿名内部类干这些事，但有时候这不是好的做法，本文中将介绍和使用lambda， 带你体验函数式编程的魔力。 什么是lambda?lambda表达式是一段可以传递的代码，它的核心思想是将面向对象中的传递数据变成传递行为。 我们回顾一下在使用java8之前要做的事，之前我们编写一个线程时是这样的： Runnable r = new Runnable() &#123; @Override public void run() &#123; System.out.println(\"do something.\"); &#125;&#125; 也有人会写一个类去实现Runnable接口，这样做没有问题，我们注意这个接口中只有一个run方法， 当把Runnable对象给Thread对象作为构造参数时创建一个线程，运行后将输出do something.。 我们使用匿名内部类的方式实现了该方法。 这实际上是一个代码即数据的例子，在run方法中是线程要执行的一个任务，但上面的代码中任务内容已经被规定死了。 当我们有多个不同的任务时，需要重复编写如上代码。 设计匿名内部类的目的，就是为了方便 Java 程序员将代码作为数据传递。不过，匿名内部 类还是不够简便。 为了执行一个简单的任务逻辑，不得不加上 6 行冗繁的样板代码。那如果是lambda该怎么做? Runnable r = () -&gt; System.out.println(\"do something.\"); 嗯，这代码看起来很酷，你可以看到我们用()和-&gt;的方式完成了这件事，这是一个没有名字的函数，也没有人和参数，再简单不过了。 使用-&gt;将参数和实现逻辑分离，当运行这个线程的时候执行的是-&gt;之后的代码片段，且编译器帮助我们做了类型推导； 这个代码片段可以是用{}包含的一段逻辑。下面一起来学习一下lambda的语法。 基础语法在lambda中我们遵循如下的表达式来编写： expression = (variable) -&gt; action variable: 这是一个变量,一个占位符。像x,y,z,可以是多个变量。 action: 这里我称它为action, 这是我们实现的代码逻辑部分,它可以是一行代码也可以是一个代码片段 可以看到Java中lambda表达式的格式：参数、箭头、以及动作实现，当一个动作实现无法用一行代码完成，可以编写 一段代码用{}包裹起来。 lambda表达式可以包含多个参数,例如： int sum = (x, y) -&gt; x + y; 这时候我们应该思考这段代码不是之前的x和y数字相加，而是创建了一个函数，用来计算两个操作数的和。 后面用int类型进行接收，在lambda中为我们省略去了return。 函数式接口函数式接口是只有一个方法的接口，用作lambda表达式的类型。前面写的例子就是一个函数式接口，来看看jdk中的Runnable源码 @FunctionalInterfacepublic interface Runnable &#123; /** * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used * to create a thread, starting the thread causes the object's * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing * thread. * &lt;p&gt; * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run();&#125; 这里只有一个抽象方法run，实际上你不写public abstract也是可以的，在接口中定义的方法都是public abstract的。 同时也使用注解@FunctionalInterface告诉编译器这是一个函数式接口，当然你不这么写也可以，标识后明确了这个函数中 只有一个抽象方法，当你尝试在接口中编写多个方法的时候编译器将不允许这么干。 尝试函数式接口我们来编写一个函数式接口，输入一个年龄，判断这个人是否是成人。 public class FunctionInterfaceDemo &#123; @FunctionalInterface interface Predicate&lt;T&gt; &#123; boolean test(T t); &#125; /** * 执行Predicate判断 * * @param age 年龄 * @param predicate Predicate函数式接口 * @return 返回布尔类型结果 */ public static boolean doPredicate(int age, Predicate&lt;Integer&gt; predicate) &#123; return predicate.test(age); &#125; public static void main(String[] args) &#123; boolean isAdult = doPredicate(20, x -&gt; x &gt;= 18); System.out.println(isAdult); &#125;&#125; 从这个例子我们很轻松的完成 是否是成人 的动作，其次判断是否是成人，在此之前我们的做法一般是编写一个 判断是否是成人的方法，是无法将 判断 共用的。而在本例只，你要做的是将 行为 (判断是否是成人，或者是判断是否大于30岁) 传递进去，函数式接口告诉你结果是什么。 实际上诸如上述例子中的接口，伟大的jdk设计者为我们准备了java.util.function包 我们前面写的Predicate函数式接口也是JDK种的一个实现，他们大致分为以下几类： 接口 参数 返回值 类别 示例 Consumer T void 消费型接口 输出一个值 Supplier None T 供给型接口 工厂方法 Function T R 函数型接口 获得 Artist 对象的名字 Predicate T boolean 断言型接口 这张唱片已经发行了吗 消费型接口示例 public static void donation(Integer money, Consumer&lt;Integer&gt; consumer)&#123; consumer.accept(money); &#125;public static void main(String[] args) &#123; donation(1000, money -&gt; System.out.println(\"好心的麦乐迪为Blade捐赠了\"+money+\"元\")) ;&#125; 供给型接口示例 public static List&lt;Integer&gt; supply(Integer num, Supplier&lt;Integer&gt; supplier)&#123; List&lt;Integer&gt; resultList = new ArrayList&lt;Integer&gt;() ; for(int x=0;x&lt;num;x++) resultList.add(supplier.get()); return resultList ;&#125;public static void main(String[] args) &#123; List&lt;Integer&gt; list = supply(10,() -&gt; (int)(Math.random()*100)); list.forEach(System.out::println);&#125; 函数型接口示例 转换字符串为Integer public static Integer convert(String str, Function&lt;String, Integer&gt; function) &#123; return function.apply(str);&#125;public static void main(String[] args) &#123; Integer value = convert(\"28\", x -&gt; Integer.parseInt(x));&#125; 断言型接口示例 筛选出只有2个字的水果 public static List&lt;String&gt; filter(List&lt;String&gt; fruit, Predicate&lt;String&gt; predicate)&#123; List&lt;String&gt; f = new ArrayList&lt;&gt;(); for (String s : fruit) &#123; if(predicate.test(s))&#123; f.add(s); &#125; &#125; return f;&#125;public static void main(String[] args) &#123; List&lt;String&gt; fruit = Arrays.asList(\"香蕉\", \"哈密瓜\", \"榴莲\", \"火龙果\", \"水蜜桃\"); List&lt;String&gt; newFruit = filter(fruit, (f) -&gt; f.length() == 2); System.out.println(newFruit);&#125; 默认方法在Java语言中，一个接口中定义的方法必须由实现类提供实现。但是当接口中加入新的API时， 实现类按照约定也要修改实现，而Java8的API对现有接口也添加了很多方法，比如List接口中添加了sort方法。 如果按照之前的做法，那么所有的实现类都要实现sort方法，JDK的编写者们一定非常抓狂。 幸运的是我们使用了Java8，这一问题将得到很好的解决，在Java8种引入新的机制，支持在接口中声明方法同时提供实现。 这令人激动不已，你有两种方式完成 1.在接口内声明静态方法 2.指定一个默认方法。 我们来看看在JDK8中上述List接口添加方法的问题是如何解决的 default void sort(Comparator&lt;? super E&gt; c) &#123; Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator&lt;E&gt; i = this.listIterator(); for (Object e : a) &#123; i.next(); i.set((E) e); &#125;&#125; 翻阅List接口的源码，其中加入一个默认方法default void sort(Comparator&lt;? super E&gt; c)。 在返回值之前加入default关键字，有了这个方法我们可以直接调用sort方法进行排序。 List&lt;Integer&gt; list = Arrays.asList(2, 7, 3, 1, 8, 6, 4);list.sort(Comparator.naturalOrder());System.out.println(list); Comparator.naturalOrder()是一个自然排序的实现，这里可以自定义排序方案。 你经常看到使用Java8操作集合的时候可以直接foreach的原因也是在Iterable接口中也新增了一个默认方法：forEach ， 该方法功能和 for 循环类似，但是允许 用户使用一个Lambda表达式作为循环体。","tags":[{"name":"Java8","slug":"Java8","permalink":"http://biezhi.me/tags/Java8/"},{"name":"lambda","slug":"lambda","permalink":"http://biezhi.me/tags/lambda/"}]},{"title":"跟上Java8系列文章 - 带你实战Java8","date":"2017-07-15T16:00:00.000Z","path":"2017/07/16/keep-up-with-java8.html","text":"Java8从2014年出现至今已经三年有余，这里发布的新功能是自Java1.0发布18年来最大变化的。 没有去处任何API，我们仍然能兼容以前的代码，新功能中提供了更多的语法和设计，帮助开发者编写更清楚、简洁的代码。 Java8把函数式编程里一些最好的思想融入到大家熟知的Java语法中，让你用更少的时间写出高效代码。 而目前国内很多开发者的现状还处于Java6的语法之上，这确实没什么问题，可以保证你的企业软件稳定运行下去。 但时代总是变化的，我们熟悉的Spring框架也对java8做了更好的支持。 大势所趋，为何不跟上Java8的节奏一起体验现代高级编程语言中的新特性呢？ 现在我可以带你深入浅出跟上Java8，这一系列文章写了那些我认为有用所关注的一些内容，如果你对更详细的细节感兴趣可以查阅相关书籍。 优势 lambda表达式 stream流 optional jvm优化 兼容老版本 文章目录 跟上Java8 - 了解lambda 跟上Java8 - stream入门与实战 跟上Java8 - 函数式编程 跟上Java8 - 日期和时间最实用技巧 跟上Java8 - 你忽略了的新特性 跟上Java8 - 使用lambda并发编程 跟上Java8 - 七七八八的黑科技 跟上Java8 - 优化工作中那些屎代码 资料分享 在线查看Java8新增API java8-the-missing-tutorial java8-tutorial","tags":[{"name":"Java8","slug":"Java8","permalink":"http://biezhi.me/tags/Java8/"},{"name":"系列","slug":"系列","permalink":"http://biezhi.me/tags/系列/"}]},{"title":"Hello World","date":"2017-07-14T16:00:00.000Z","path":"2017/07/15/hello-world.html","text":"博客换了主题，以前的文章在github的分支上保存，以后在这里重新写点东西。","tags":[{"name":"blog","slug":"blog","permalink":"http://biezhi.me/tags/blog/"},{"name":"hello-world","slug":"hello-world","permalink":"http://biezhi.me/tags/hello-world/"}]}]