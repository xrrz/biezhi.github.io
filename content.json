[{"title":"跟上Java8 - Stream API快速入门","date":"2017-07-17T16:00:00.000Z","path":"2017/07/18/keep-up-with-java8-stream.html","text":"在前面我们简单介绍了lambda表达式，Java8旨在帮助程序员写出更好的代码， 其对核心类库的改进也是关键的一部分，Stream是Java8种处理集合的抽象概念， 它可以指定你希望对集合的操作，但是执行操作的时间交给具体实现来决定。 为什么需要Stream?Java语言中集合是使用最多的API，几乎每个Java程序都会用到集合操作， 这里的Stream和IO中的Stream不同，它提供了对集合操作的增强，极大的提高了操作集合对象的便利性。 集合对于大多数编程任务而言都是基本的，为了解释集合是怎么工作，我们想象一下当下最火的外卖APP， 当我们点菜的时候需要按照距离、价格、销量等进行排序后筛选出自己满意的菜品。 你可能想选择距离自己最近的一家店铺点菜，尽管用集合可以完成这件事，但集合的操作远远算不上完美。 假如让你编写上面示例中的代码，你可能会写出如下： // 店铺属性public class Property &#123; String name; // 距离，单位:米 Integer distance; // 销量，月售 Integer sales; // 价格，这里简单起见就写一个级别代表价格段 Integer priceLevel; public Property(String name, int distance, int sales, int priceLevel) &#123; this.name = name; this.distance = distance; this.sales = sales; this.priceLevel = priceLevel; &#125; // getter setter 省略&#125; 我想要筛选距离我最近的店铺，你可能会写下这样的代码： public static void main(String[] args) &#123; Property p1 = new Property(\"叫了个鸡\", 1000, 500, 2); Property p2 = new Property(\"张三丰饺子馆\", 2300, 1500, 3); Property p3 = new Property(\"永和大王\", 580, 3000, 1); Property p4 = new Property(\"肯德基\", 6000, 200, 4); List&lt;Property&gt; properties = Arrays.asList(p1, p2, p3, p4); Collections.sort(properties, (x, y) -&gt; x.distance.compareTo(y.distance)); String name = properties.get(0).name; System.out.println(\"距离我最近的店铺是:\" + name);&#125; 这里也使用了部分lambda表达式，在Java8之前你可能写的更痛苦一些。 要是要处理大量元素又该怎么办呢？为了提高性能，你需要并行处理，并利用多核架构。 但写并行代码比用迭代器还要复杂，而且调试起来也够受的！ 但Stream中操作这些东西当然是非常简单的，小试牛刀: // Stream操作String name2 = properties.stream() .sorted(Comparator.comparingInt(x -&gt; x.distance)) .findFirst() .get().name;System.out.println(\"距离我最近的店铺是:\" + name); 新的API对所有的集合操作都提供了生成流操作的方法，写的代码也行云流水，我们非常简单的就筛选了离我最近的店铺。 在后面我们继续讲解Stream更多的特性和玩法。 外部迭代和内部迭代当你处理集合时，通常会对它进行迭代，然后处理返回的每个元素。比如我想看看月销量大于1000的店铺个数。 使用for循环进行迭代int count = 0;for (Property property : properties) &#123; if(property.sales &gt; 1000)&#123; count++; &#125;&#125; 上面的操作是可行的，但是当每次迭代的时候你需要些很多重复的代码。将for循环修改为并行执行也非常困难， 需要修改每个for的实现。 从集合背后的原理来看，for循环封装了迭代的语法糖，首先调用iterator方法，产生一个Iterator对象， 然后控制整个迭代，这就是外部迭代。迭代的过程通过调用Iterator对象的hasNext和next方法完成。 使用迭代器进行计算int count = 0;Iterator&lt;Property&gt; iterator = properties.iterator();while(iterator.hasNext())&#123; Property property = iterator.next(); if(property.sales &gt; 1000)&#123; count++; &#125;&#125; 而迭代器也是有问题的。它很难抽象出未知的不能操作；此外它本质上还是串行化的操作，总体来看使用 for循环会将行为和方法混为一谈。 另一种办法是使用内部迭代完成，properties.stream()该方法返回一个Stream而不是迭代器。 使用内部迭代进行计算long count2 = properties.stream() .filter(p -&gt; p.sales &gt; 1000) .count(); 上述代码是通过Stream API完成的，我们可以把它理解为2个步骤： 找出所有销量大于1000的店铺 计算出店铺个数 为了找出销量大于1000的店铺，需要先做一次过滤：filter，你可以看看这个方法的入参就是前面讲到的Predicate断言型函数式接口， 测试一个函数完成后，返回值为boolean。 由于Stream API的风格，我们没有改变集合的内容，而是描述了Stream的内容，最终调用count()方法计算出Stream 里包含了多少个过滤之后的对象，返回值为long。 创建Stream你已经知道Java8种在Collection接口添加了Stream方法，可以将任何集合转换成一个Stream。 如果你操作的是一个数组可以使用Stream.of(1, 2, 3)方法将它转换为一个流。 也许有人知道JDK7中添加了一些类库如Files.readAllLines(Paths.get(&quot;/home/biezhi/a.txt&quot;))这样的读取文件行方法。 List作为Collection的子类拥有转换流的方法，那么我们读取这个文本文件到一个字符串变量中将变得更简洁： String content = Files.readAllLines(Paths.get(\"/home/biezhi/a.txt\")).stream() .collect(Collectors.joining(\"\\n\")); 这里的collect是后面要讲解的收集器，对Stream进行了处理后得到一个文本文件的内容。 JDK8也为我们提供了一些便捷的Stream相关类库: 创建一个流是很简单的，下面我们试试用创建好的Stream做一些操作吧。 流操作java.util.stream.Stream中定义了许多流操作的方法，为了更好的理解Stream API掌握它常用的操作非常重要。 流的操作其实可以分为两类：处理操作、聚合操作。 处理操作：诸如filter、map等处理操作将Stream一层一层的进行抽离，返回一个流给下一层使用。 聚合操作：从最后一次流中生成一个结果给调用方，foreach只做处理不做返回。 filterfilter看名字也知道是过滤的意思，我们通常在筛选数据的时候用到，频率非常高。 filter方法的参数是Predicate&lt;T&gt; predicate即一个从T到boolean的函数。 筛选出距离我在1000米内的店铺 properties.stream() .filter(p -&gt; p.distance &lt; 1000) 筛选出名称大于5个字的店铺 properties.stream() .filter(p -&gt; p.name.length() &gt; 5); map有时候我们需要将流中处理的数据类型进行转换，这时候就可以使用map方法来完成，将流中的值转换为一个新的流。 列出所有店铺的名称 properties.stream() .map(p -&gt; p.name); 传给map的lambda表达式接收一个Property类型的参数，返回一个String。 参数和返回值不必属于同一种类型，但是lambda表达式必须是Function接口的一个实例。 flatMap有时候我们会遇到提取子流的操作，这种情况用的不多但是遇到flatMap将变得更容易处理。 例如我们有一个List&lt;List&lt;String&gt;&gt;结构的数据： List&lt;List&lt;String&gt;&gt; lists = new ArrayList&lt;&gt;(); lists.add(Arrays.asList(\"apple\", \"click\")); lists.add(Arrays.asList(\"boss\", \"dig\", \"qq\", \"vivo\")); lists.add(Arrays.asList(\"c#\", \"biezhi\")); 要做的操作是获取这些数据中长度大于2的单词个数 lists.stream() .flatMap(Collection::stream) .filter(str -&gt; str.length() &gt; 2) .count(); 在不使用flatMap前你可能需要做2次for循环。这里调用了List的stream方法将每个列表转换成Stream对象， 其他的就和之前的操作一样。 max和minStream中常用的操作之一是求最大值和最小值，Stream API 中的max和min操作足以解决这一问题。 我们需要筛选出价格最低的店铺: Property property = properties.stream() .max(Comparator.comparingInt(p -&gt; p.priceLevel)) .get(); 查找Stream中的最大或最小元素，首先要考虑的是用什么作为排序的指标。 以查找价格最低的店铺为例，排序的指标就是店铺的价格等级。 为了让Stream对象按照价格等级进行排序，需要传给它一个Comparator对象。 Java8提供了一个新的静态方法comparingInt，使用它可以方便地实现一个比较器。 放在以前，我们需要比较两个对象的某项属性的值，现在只需要提供一个存取方法就够了。 收集结果通常我们处理完流之后想查看一下结果，比如获取总数，转换结果，在前面的示例中你发现调用了 filter、map之后没有下文了，后续的操作应该调用Stream中的collect方法完成。 获取距离我最近的2个店铺 List&lt;Property&gt; properties = properties.stream() .sorted(Comparator.comparingInt(x -&gt; x.distance)) .limit(2) .collect(Collectors.toList()); 获取所有店铺的名称 List&lt;String&gt; names = properties.stream() .map(p -&gt; p.name) .collect(Collectors.toList()); 获取每个店铺的价格等级 Map&lt;String, Integer&gt; map = properties.stream() .collect(Collectors.toMap(Property::getName, Property::getPriceLevel)); 所有价格等级的店铺列表 Map&lt;Integer, List&lt;Property&gt;&gt; priceMap = properties.stream() .collect(Collectors.groupingBy(Property::getPriceLevel)); 并行数据处理并行和并发并发是两个任务共享时间段，并行则是两个任务在同一时间发生，比如运行在多核CPU上。 如果一个程序要运行两个任务，并且只有一个CPU给它们分配了不同的时间片，那么这就是并发，而不是并行。 并行化是指为缩短任务执行时间，将一个任务分解成几部分，然后并行执行。 这和顺序执行的任务量是一样的，区别就像用更多的马来拉车，花费的时间自然减少了。 实际上，和顺序执行相比，并行化执行任务时，CPU承载的工作量更大。 数据并行化是指将数据分成块，为每块数据分配单独的处理单元。 还是拿马拉车那个例子打比方，就像从车里取出一些货物，放到另一辆车上，两辆马车都沿着同样的路径到达目的地。 当需要在大量数据上执行同样的操作时，数据并行化很管用。 它将问题分解为可在多块数据上求解的形式，然后对每块数据执行运算，最后将各数据块上得到的结果汇总，从而获得最终答案。 人们经常拿任务并行化和数据并行化做比较，在任务并行化中，线程不同，工作各异。 我们最常遇到的JavaEE应用容器便是任务并行化的例子之一，每个线程不光可以为不同用户服务， 还可以为同一个用户执行不同的任务，比如登录或往购物车添加商品。 Stream并行流流使得计算变得容易，它的操作也非常简单，但你需要遵守一些约定。默认情况下我们使用集合的stream方法 创建的是一个串行流，你有两种办法让他变成并行流。 调用Stream对象的parallel方法 创建流的时候调用parallelStream而不是stream方法 我们来用具体的例子来解释串行和并行流 串行化计算 筛选出价格等级小于4，按照距离排序的2个店铺名 properties.stream() .filter(p -&gt; p.priceLevel &lt; 4) .sorted(Comparator.comparingInt(Property::getDistance)) .map(Property::getName) .limit(2) .collect(Collectors.toList()); 调用 parallelStream 方法即能并行处理 properties.parallelStream() .filter(p -&gt; p.priceLevel &lt; 4) .sorted(Comparator.comparingInt(Property::getDistance)) .map(Property::getName) .limit(2) .collect(Collectors.toList()); 读到这里，大家的第一反应可能是立即将手头代码中的stream方法替换为parallelStream方法， 因为这样做简直太简单了！先别忙，为了将硬件物尽其用，利用好并行化非常重要，但流类库提供的数据并行化只是其中的一种形式。 我们先要问自己一个问题：并行化运行基于流的代码是否比串行化运行更快？这不是一个简单的问题。 回到前面的例子，哪种方式花的时间更多取决于串行或并行化运行时的环境。","tags":[{"name":"Java8","slug":"Java8","permalink":"http://biezhi.me/tags/Java8/"},{"name":"stream","slug":"stream","permalink":"http://biezhi.me/tags/stream/"},{"name":"flatmap","slug":"flatmap","permalink":"http://biezhi.me/tags/flatmap/"},{"name":"filter","slug":"filter","permalink":"http://biezhi.me/tags/filter/"},{"name":"collect","slug":"collect","permalink":"http://biezhi.me/tags/collect/"}]},{"title":"跟上Java8 - 了解lambda","date":"2017-07-16T16:00:00.000Z","path":"2017/07/17/keep-up-with-java8-lambda.html","text":"从java8出现以来lambda是最重要的特性之一，它可以让我们用简洁流畅的代码完成一个功能。 很长一段时间java被吐槽是冗余和缺乏函数式编程能力的语言，随着函数式编程的流行java8种也引入了 这种编程风格。在此之前我们都在写匿名内部类干这些事，但有时候这不是好的做法，本文中将介绍和使用lambda， 带你体验函数式编程的魔力。 什么是lambda?lambda表达式是一段可以传递的代码，它的核心思想是将面向对象中的传递数据变成传递行为。 我们回顾一下在使用java8之前要做的事，之前我们编写一个线程时是这样的： Runnable r = new Runnable() &#123; @Override public void run() &#123; System.out.println(\"do something.\"); &#125;&#125; 也有人会写一个类去实现Runnable接口，这样做没有问题，我们注意这个接口中只有一个run方法， 当把Runnable对象给Thread对象作为构造参数时创建一个线程，运行后将输出do something.。 我们使用匿名内部类的方式实现了该方法。 这实际上是一个代码即数据的例子，在run方法中是线程要执行的一个任务，但上面的代码中任务内容已经被规定死了。 当我们有多个不同的任务时，需要重复编写如上代码。 设计匿名内部类的目的，就是为了方便 Java 程序员将代码作为数据传递。不过，匿名内部 类还是不够简便。 为了执行一个简单的任务逻辑，不得不加上 6 行冗繁的样板代码。那如果是lambda该怎么做? Runnable r = () -&gt; System.out.println(\"do something.\"); 嗯，这代码看起来很酷，你可以看到我们用()和-&gt;的方式完成了这件事，这是一个没有名字的函数，也没有人和参数，再简单不过了。 使用-&gt;将参数和实现逻辑分离，当运行这个线程的时候执行的是-&gt;之后的代码片段，且编译器帮助我们做了类型推导； 这个代码片段可以是用{}包含的一段逻辑。下面一起来学习一下lambda的语法。 基础语法在lambda中我们遵循如下的表达式来编写： expression = (variable) -&gt; action variable: 这是一个变量,一个占位符。像x,y,z,可以是多个变量。 action: 这里我称它为action, 这是我们实现的代码逻辑部分,它可以是一行代码也可以是一个代码片段 可以看到Java中lambda表达式的格式：参数、箭头、以及动作实现，当一个动作实现无法用一行代码完成，可以编写 一段代码用{}包裹起来。 lambda表达式可以包含多个参数,例如： int sum = (x, y) -&gt; x + y; 这时候我们应该思考这段代码不是之前的x和y数字相加，而是创建了一个函数，用来计算两个操作数的和。 后面用int类型进行接收，在lambda中为我们省略去了return。 函数式接口函数式接口是只有一个方法的接口，用作lambda表达式的类型。前面写的例子就是一个函数式接口，来看看jdk中的Runnable源码 @FunctionalInterfacepublic interface Runnable &#123; /** * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used * to create a thread, starting the thread causes the object's * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing * thread. * &lt;p&gt; * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run();&#125; 这里只有一个抽象方法run，实际上你不写public abstract也是可以的，在接口中定义的方法都是public abstract的。 同时也使用注解@FunctionalInterface告诉编译器这是一个函数式接口，当然你不这么写也可以，标识后明确了这个函数中 只有一个抽象方法，当你尝试在接口中编写多个方法的时候编译器将不允许这么干。 尝试函数式接口我们来编写一个函数式接口，输入一个年龄，判断这个人是否是成人。 public class FunctionInterfaceDemo &#123; @FunctionalInterface interface Predicate&lt;T&gt; &#123; boolean test(T t); &#125; /** * 执行Predicate判断 * * @param age 年龄 * @param predicate Predicate函数式接口 * @return 返回布尔类型结果 */ public static boolean doPredicate(int age, Predicate&lt;Integer&gt; predicate) &#123; return predicate.test(age); &#125; public static void main(String[] args) &#123; boolean isAdult = doPredicate(20, x -&gt; x &gt;= 18); System.out.println(isAdult); &#125;&#125; 从这个例子我们很轻松的完成 是否是成人 的动作，其次判断是否是成人，在此之前我们的做法一般是编写一个 判断是否是成人的方法，是无法将 判断 共用的。而在本例只，你要做的是将 行为 (判断是否是成人，或者是判断是否大于30岁) 传递进去，函数式接口告诉你结果是什么。 实际上诸如上述例子中的接口，伟大的jdk设计者为我们准备了java.util.function包 我们前面写的Predicate函数式接口也是JDK种的一个实现，他们大致分为以下几类： 接口 参数 返回值 类别 示例 Consumer T void 消费型接口 输出一个值 Supplier None T 供给型接口 工厂方法 Function T R 函数型接口 获得 Artist 对象的名字 Predicate T boolean 断言型接口 这张唱片已经发行了吗 消费型接口示例 public static void donation(Integer money, Consumer&lt;Integer&gt; consumer)&#123; consumer.accept(money); &#125;public static void main(String[] args) &#123; donation(1000, money -&gt; System.out.println(\"好心的麦乐迪为Blade捐赠了\"+money+\"元\")) ;&#125; 供给型接口示例 public static List&lt;Integer&gt; supply(Integer num, Supplier&lt;Integer&gt; supplier)&#123; List&lt;Integer&gt; resultList = new ArrayList&lt;Integer&gt;() ; for(int x=0;x&lt;num;x++) resultList.add(supplier.get()); return resultList ;&#125;public static void main(String[] args) &#123; List&lt;Integer&gt; list = supply(10,() -&gt; (int)(Math.random()*100)); list.forEach(System.out::println);&#125; 函数型接口示例 转换字符串为Integer public static Integer convert(String str, Function&lt;String, Integer&gt; function) &#123; return function.apply(str);&#125;public static void main(String[] args) &#123; Integer value = convert(\"28\", x -&gt; Integer.parseInt(x));&#125; 断言型接口示例 筛选出只有2个字的水果 public static List&lt;String&gt; filter(List&lt;String&gt; fruit, Predicate&lt;String&gt; predicate)&#123; List&lt;String&gt; f = new ArrayList&lt;&gt;(); for (String s : fruit) &#123; if(predicate.test(s))&#123; f.add(s); &#125; &#125; return f;&#125;public static void main(String[] args) &#123; List&lt;String&gt; fruit = Arrays.asList(\"香蕉\", \"哈密瓜\", \"榴莲\", \"火龙果\", \"水蜜桃\"); List&lt;String&gt; newFruit = filter(fruit, (f) -&gt; f.length() == 2); System.out.println(newFruit);&#125; 默认方法在Java语言中，一个接口中定义的方法必须由实现类提供实现。但是当接口中加入新的API时， 实现类按照约定也要修改实现，而Java8的API对现有接口也添加了很多方法，比如List接口中添加了sort方法。 如果按照之前的做法，那么所有的实现类都要实现sort方法，JDK的编写者们一定非常抓狂。 幸运的是我们使用了Java8，这一问题将得到很好的解决，在Java8种引入新的机制，支持在接口中声明方法同时提供实现。 这令人激动不已，你有两种方式完成 1.在接口内声明静态方法 2.指定一个默认方法。 我们来看看在JDK8中上述List接口添加方法的问题是如何解决的 default void sort(Comparator&lt;? super E&gt; c) &#123; Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator&lt;E&gt; i = this.listIterator(); for (Object e : a) &#123; i.next(); i.set((E) e); &#125;&#125; 翻阅List接口的源码，其中加入一个默认方法default void sort(Comparator&lt;? super E&gt; c)。 在返回值之前加入default关键字，有了这个方法我们可以直接调用sort方法进行排序。 List&lt;Integer&gt; list = Arrays.asList(2, 7, 3, 1, 8, 6, 4);list.sort(Comparator.naturalOrder());System.out.println(list); Comparator.naturalOrder()是一个自然排序的实现，这里可以自定义排序方案。 你经常看到使用Java8操作集合的时候可以直接foreach的原因也是在Iterable接口中也新增了一个默认方法：forEach ， 该方法功能和 for 循环类似，但是允许 用户使用一个Lambda表达式作为循环体。 在后面的章节中我们再次通过案例来展示函数式编程的魅力 :)","tags":[{"name":"Java8","slug":"Java8","permalink":"http://biezhi.me/tags/Java8/"},{"name":"lambda","slug":"lambda","permalink":"http://biezhi.me/tags/lambda/"},{"name":"functional-interface","slug":"functional-interface","permalink":"http://biezhi.me/tags/functional-interface/"}]},{"title":"跟上Java8系列文章 - 带你实战Java8","date":"2017-07-15T16:00:00.000Z","path":"2017/07/16/keep-up-with-java8.html","text":"Java8从2014年出现至今已经三年有余，这里发布的新功能是自Java1.0发布18年来最大变化的。 没有去处任何API，我们仍然能兼容以前的代码，新功能中提供了更多的语法和设计，帮助开发者编写更清楚、简洁的代码。 Java8把函数式编程里一些最好的思想融入到大家熟知的Java语法中，让你用更少的时间写出高效代码。 而目前国内很多开发者的现状还处于Java6的语法之上，这确实没什么问题，可以保证你的企业软件稳定运行下去。 但时代总是变化的，我们熟悉的Spring框架也对java8做了更好的支持。 大势所趋，为何不跟上Java8的节奏一起体验现代高级编程语言中的新特性呢？ 现在我可以带你深入浅出跟上Java8，这一系列文章写了那些我认为有用所关注的一些内容，如果你对更详细的细节感兴趣可以查阅相关书籍。 优势 lambda表达式 stream流 optional jvm优化 兼容老版本 文章目录 跟上Java8 - 了解lambda 跟上Java8 - Stream API快速入门 跟上Java8 - 函数式编程 跟上Java8 - 日期和时间最实用技巧 跟上Java8 - 你忽略了的新特性 跟上Java8 - 使用lambda并发编程 跟上Java8 - 七七八八的黑科技 跟上Java8 - 优化工作中那些屎代码 资料分享 在线查看Java8新增API java8-the-missing-tutorial java8-tutorial","tags":[{"name":"Java8","slug":"Java8","permalink":"http://biezhi.me/tags/Java8/"},{"name":"lambda","slug":"lambda","permalink":"http://biezhi.me/tags/lambda/"},{"name":"系列","slug":"系列","permalink":"http://biezhi.me/tags/系列/"},{"name":"stream-api","slug":"stream-api","permalink":"http://biezhi.me/tags/stream-api/"}]},{"title":"Hello World","date":"2017-07-14T16:00:00.000Z","path":"2017/07/15/hello-world.html","text":"博客换了主题，以前的文章在github的分支上保存，以后在这里重新写点东西。","tags":[{"name":"blog","slug":"blog","permalink":"http://biezhi.me/tags/blog/"},{"name":"hello-world","slug":"hello-world","permalink":"http://biezhi.me/tags/hello-world/"}]}]