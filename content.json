[{"title":"聊聊TCP中的KeepAlive机制","date":"2017-08-28T16:00:00.000Z","path":"2017/08/29/talk-tcp-keepalive.html","text":"服务端的系统设置中经常会和底层协议打交道，我们有必要重温一下曾经那些“听过”却不熟悉的名词。 今天聊的话题是 KeepAlive，在实际应用中又是怎么使用的？ wireshark抓包 为什么有Keepalive？ 大家都做过电梯吧，假设电梯来了你先进去，你朋友还没进来，过一段时间电梯门就会自动关闭， 你应该没遇到过哪个电梯会一直等你朋友来了才关门的。如果真是那样，那别的楼层的小姐姐们会炸了~ 我们举个编程中的例子来解释下，我编写了一个服务端程序S和一个客户端程序C，客户端向服务端发送 一个消息： 客户端发送消息 服务端收到消息后一看，瞧给你牛*的，然后没理客户端，傻狗客户端一直在等待，但是不知道是不是服务器挂掉了？ 这时候TCP协议提出一个办法，当客户端端等待超过一定时间后自动给服务端发送一个空的报文， 如果对方回复了这个报文证明连接还存活着，如果对方没有报文返回且进行了多次尝试都是一样， 那么就认为连接已经丢失，客户端就没必要继续保持连接了。 如果没有这种机制就会有很多空闲的连接占用着系统资源。 KeepAlive并不是TCP协议规范的一部分，但在几乎所有的TCP/IP协议栈（不管是Linux还是Windows）中，都实现了KeepAlive功能 RFC1122#TCP Keep-Alives 如何设置它?在设置之前我们先来看看KeepAlive都支持哪些设置项 KeepAlive默认情况下是关闭的，可以被上层应用开启和关闭 tcp_keepalive_time: KeepAlive的空闲时长，或者说每次正常发送心跳的周期，默认值为7200s（2小时） tcp_keepalive_intvl: KeepAlive探测包的发送间隔，默认值为75s tcp_keepalive_probes: 在tcp_keepalive_time之后，没有接收到对方确认，继续发送保活探测包次数，默认值为9（次） 我们讲讲在Linux操作系统和使用Java、C语言和Nginx中如何设置 在Linux内核设置KeepAlive默认不是开启的，如果想使用KeepAlive，需要在你的应用中设置SO_KEEPALIVE才可以生效。 查看当前的配置： cat /proc/sys/net/ipv4/tcp_keepalive_timecat /proc/sys/net/ipv4/tcp_keepalive_intvlcat /proc/sys/net/ipv4/tcp_keepalive_probes 在Linux中我们可以通过修改 /etc/sysctl.conf 的全局配置： net.ipv4.tcp_keepalive_time=7200net.ipv4.tcp_keepalive_intvl=75net.ipv4.tcp_keepalive_probes=9 添加上面的配置后输入 sysctl -p 使其生效，你可以使用 sysctl -a | grep keepalive 命令来查看当前的默认配置 如果应用中已经设置SO_KEEPALIVE，程序不用重启，内核直接生效 使用Netty4设置这里我们使用常用的Java网络框架Netty来设置，只需要在服务端设置即可： EventLoopGroup bossGroup = new NioEventLoopGroup(1);EventLoopGroup workerGroup = new NioEventLoopGroup();try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 100) .childOption(ChannelOption.SO_KEEPALIVE, true) .handler(new LoggingHandler(LogLevel.INFO)); // Start the server. ChannelFuture f = b.bind(8088).sync(); // Wait until the server socket is closed. f.channel().closeFuture().sync();&#125; finally &#123; // Shut down all event loops to terminate all threads. bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully();&#125; 这段代码来自经典的echo服务器，我们在childOption中开启了SO_KEEPALIVE。 Java程序只能做到设置SO_KEEPALIVE选项，其他配置项只能依赖于sysctl配置，系统进行读取。 C语言设置函数原型： #include &lt;sys/socket.h&gt;int setsockopt(int socket, int level, int option_name, const void *option_value, socklen_t option_len); 我们在需要使能Keepalive的socket上面调用setsockopt函数便可以打开该socket上面的keepalive。 第一个参数是要设置的套接字 第二个参数是SOL_SOCKET 第三个参数必须是SO_KEEPALIVE 第四个参数必须是一个布尔整型值，0表示关闭，1表示打开 最后一个参数是第四个参数值的大小。 调用例子： int socket(int domain, int type, int protocol)&#123; int (*libc_socket)(int, int, int); int s, optval; char *env; *(void **)(&amp;libc_socket) = dlsym(RTLD_NEXT, \"socket\"); if(dlerror()) &#123; errno = EACCES; return -1; &#125; if((s = (*libc_socket)(domain, type, protocol)) != -1) &#123; if((domain == PF_INET) &amp;&amp; (type == SOCK_STREAM)) &#123; if(!(env = getenv(\"KEEPALIVE\")) || strcasecmp(env, \"off\")) &#123; optval = 1; &#125; else &#123; optval = 0; &#125; if(!(env = getenv(\"KEEPALIVE\")) || strcasecmp(env, \"skip\")) &#123; setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, sizeof(optval)); &#125;#ifdef TCP_KEEPCNT if((env = getenv(\"KEEPCNT\")) &amp;&amp; ((optval = atoi(env)) &gt;= 0)) &#123; setsockopt(s, SOL_TCP, TCP_KEEPCNT, &amp;optval, sizeof(optval)); &#125;#endif#ifdef TCP_KEEPIDLE if((env = getenv(\"KEEPIDLE\")) &amp;&amp; ((optval = atoi(env)) &gt;= 0)) &#123; setsockopt(s, SOL_TCP, TCP_KEEPIDLE, &amp;optval, sizeof(optval)); &#125;#endif#ifdef TCP_KEEPINTVL if((env = getenv(\"KEEPINTVL\")) &amp;&amp; ((optval = atoi(env)) &gt;= 0)) &#123; setsockopt(s, SOL_TCP, TCP_KEEPINTVL, &amp;optval, sizeof(optval)); &#125;#endif &#125; &#125; return s;&#125; 代码摘取自libkeepalive源码，C语言可以设置更为详细的TCP内核参数 在Nginx中配置在Nginx中配置TCP的KeepAlive非常简单，在listen指令下配置so_keepalive就可以了，具体配置 so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt] this parameter (1.1.11) configures the “TCP keepalive” behavior for the listening socket. If this parameter is omitted then the operating system’s settings will be in effect for the socket. If it is set to the value “on”, the SO_KEEPALIVE option is turned on for the socket. If it is set to the value “off”, the SO_KEEPALIVE option is turned off for the socket. Some operating systems support setting of TCP keepalive parameters on a per-socket basis using the TCP_KEEPIDLE, TCP_KEEPINTVL, and TCP_KEEPCNT socket options. On such systems (currently, Linux 2.4+, NetBSD 5+, and FreeBSD 9.0-STABLE), they can be configured using the keepidle, keepintvl, and keepcnt parameters. One or two parameters may be omitted, in which case the system default setting for the corresponding socket option will be in effect. 例子 so_keepalive=30m::10 will set the idle timeout (TCP_KEEPIDLE) to 30 minutes, leave the probe interval (TCP_KEEPINTVL) at its system default, and set the probes count (TCP_KEEPCNT) to 10 probes. 使用的场景一般我们使用KeepAlive时会修改空闲时长，避免资源浪费，系统内核会为每一个TCP连接 建立一个保护记录，相对于应用层面效率更高。 常见的几种使用场景： 检测挂掉的连接（导致连接挂掉的原因很多，如服务停止、网络波动、宕机、应用重启等） 防止因为网络不活动而断连（使用NAT代理或者防火墙的时候，经常会出现这种问题） TCP层面的心跳检测 KeepAlive通过定时发送探测包来探测连接的对端是否存活， 但通常也会许多在业务层面处理的，他们之间的特点： TCP自带的KeepAlive使用简单，发送的数据包相比应用层心跳检测包更小，仅提供检测连接功能 应用层心跳包不依赖于传输层协议，无论传输层协议是TCP还是UDP都可以用 应用层心跳包可以定制，可以应对更复杂的情况或传输一些额外信息 KeepAlive仅代表连接保持着，而心跳包往往还代表客户端可正常工作 和Http中Keep-Alive的关系 HTTP协议的Keep-Alive意图在于连接复用，同一个连接上串行方式传递请求-响应数据 TCP的KeepAlive机制意图在于保活、心跳，检测连接错误 参考资料 Keepalive TCP Keepalive HOWTO 随手记之TCP Keepalive笔记 理解TCP之Keepalive","tags":[{"name":"tcp","slug":"tcp","permalink":"http://biezhi.me/tags/tcp/"},{"name":"keepalive","slug":"keepalive","permalink":"http://biezhi.me/tags/keepalive/"}]},{"title":"30分钟使用Node实现一个命令行程序","date":"2017-08-21T16:00:00.000Z","path":"2017/08/22/lets-30-minutes-write-a-node-cli-application.html","text":"让我很无奈的是使用Java编写命令行程序是比较麻烦的，好在NodeJs干这事很方便， 在接下来的30分钟里我将教你编写一个有趣的终端程序并将它发布到npm仓库中，赶紧GET吧~ lowb终端程序 我实在想不到起什么名字了，就叫 lowb 吧。。。我们实现好的程序是这样的： 我把源码放在：https://github.com/biezhi/lowb 如何录制终端命令，我写了一篇文章 教你使用asciinema录制命令行操作 在开始之前请务必确认你安装了Node的环境，我目前使用的NodeJs环境是 v6.10.3。 创建项目结构mkdir lowb &amp;&amp; cd lowb &amp;&amp; npm init 根据提示初始化你的项目，如果你不懂怎么填写一路回车也是可以的（终端会提示你输入一些项目信息） 创建一个二进制目录 mkdir bin 在 lowb 根目录下创建一个 bin 目录，我们将可执行文件存放在这里，此时你的项目结构是这样的： ⬢ lowb.├── bin└── package.json1 directory, 1 file 光杆司令的做法原理是解析Node中的进程对象 process.argv 首先在 bin 目录下创建一个文件 lowb.js 作为我们的运行程序#!/usr/bin/env nodevar fs = require(\"fs\"), path = process.cwd();var appInfo = require('../package.json');function app(obj) &#123; if(obj[0] === '-v' || obj[0] === '--version')&#123; console.log(' version is ' + appInfo.version); &#125; else if(obj[0] === '-h' || obj[0] === '--help')&#123; console.log('Useage:'); console.log(' -v --version [show version]'); &#125; else&#123; fs.readdir(path, function(err, files)&#123; if(err)&#123; return console.log(err); &#125; for(var i = 0; i &lt; files.length; i += 1)&#123; console.log(files[i]); &#125; &#125;); &#125;&#125;;//获取除第一个命令以后的参数，使用空格拆分app(process.argv.slice(2)); 这段代码中非常简单，我们首先引入了 fs 模块和 package.json 的变量（用于获取版本号）。 然后编写了一个函数进行调用，里面只实现了一个 -v 和 -h 的命令。 process.argv 是一个数组，第一个元素返回node执行路径，第二个元素是当前执行文件的路径， 从第三个开始是运行时带的参数 指定执行脚本修改一下 package.json &#123; \"name\": \"lowb\", \"version\": \"1.0.0\", \"description\": \"lowb项目，在命令行下输出名言、段子、诗歌的小玩意~\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"repository\": &#123; \"type\": \"git\", \"url\": \"https://github.com/biezhi/lowb.git\" &#125;, \"keywords\": [ \"lowb\" ], \"bin\": &#123; \"lowb\": \"bin/lowb.js\" &#125;, \"author\": \"biezhi &lt;biezhi.me@gmail.com&gt;\", \"license\": \"MIT\"&#125; 注意添加了 bin 这个参数，将 lowb 这个命令映射到 bin/lowb.js 这个文件， 我们打包安装后调用 lowb 命令会执行 bin/lowb.js 中的内容。 安装到本地sudo npm install . -g 在 lowb 根目录下执行如上命令，你将看到类似如下的输出 ⬢ lowb sudo npm install . -gPassword:/Users/biezhi/.nvm/versions/node/v6.10.3/bin/lowb -&gt; /Users/biezhi/.nvm/versions/node/v6.10.3/lib/node_modules/lowb/bin/lowb.js/Users/biezhi/.nvm/versions/node/v6.10.3/lib 此时已经将命令安装到本地了，我们可以试试在终端下运行了： ⬢ lowb lowbbinpackage.json⬢ lowb lowb -vversion is 1.0.0⬢ lowb lowb -hUseage: -v --version [show version]⬢ lowb lowb --helpbinpackage.json 试试Commander.js前面这种做法当然是可以完成一个命令行程序的，但这样的做法就像是在刀耕火种的时代，而且功能有限； 在前端界赫赫有名的工程师 tj 写了一个库 commander.js 就是帮助我们简化命令行程序开发。 它是受Ruby中的一个库 commander 而诞生，是一款轻量级表现力强大的命令行框架。 我们来使用这个工具完成今天要做的小玩意。 安装Commander.jsnpm install commander --save 快速入门var program = require('commander');program .version('0.1.0') .option('-p, --peppers', 'Add peppers') .option('-P, --pineapple', 'Add pineapple') .option('-b, --bbq-sauce', 'Add bbq sauce') .option('-c, --cheese [type]', 'Add the specified type of cheese [marble]', 'marble') .parse(process.argv);console.log('you ordered a pizza with:');if (program.peppers) console.log(' - peppers');if (program.pineapple) console.log(' - pineapple');if (program.bbqSauce) console.log(' - bbq');console.log(' - %s cheese', program.cheese); 这是官方README中的一段代码，我们写一个JS运行一下 cmd -h 看看 Usage: cmd [options] Options: -V, --version output the version number -p, --peppers Add peppers -P, --pineapple Add pineapple -b, --bbq-sauce Add bbq sauce -c, --cheese [type] Add the specified type of cheese [marble] -h, --help output usage information 常用api commander.js 中命令行有两种可变性，option：选项，command：命令。 通过option设置的选项可以通过program.chdir或者program.noTests来访问。 通过command设置的命令通常在action回调中处理逻辑。 本文中没有用到command就不详述了。 开始干它一票吧我们希望做出来的使用效果是这样的: lowb --help Usage: lowb [options] Options: -V, --version output the version number -i, --index &lt;n&gt; ascii art index, default is random -t, --type &lt;value&gt; quotes/jokes/tang/song -h, --help output usage information -V, --version: 输出程序的版本号 -i, --index &lt;n&gt;: ascii动物的索引，默认是随机的 -t, --type &lt;value&gt;: 输出文本的类型，名言、段子、唐诗、宋词，默认是名言 -h, --help: 帮助信息 引入 commander var cmd = require('commander'); 编写命令处理的代码 cmd.version(appInfo.version) .option('-i, --index &lt;n&gt;', 'ascii art index, default is random', -1, parseInt) .option('-t, --type &lt;value&gt;', '[quotes|jokes|tang|song]', 'quotes', /^(quotes|jokes|tang|song)$/i) .on('--help', function()&#123; console.log('\\t' + appInfo.repository.url); &#125;).parse(process.argv); option 的常用API 第一个参数是选项定义，分为短定义和长定义，用|，,，连接，参数可以用&lt;&gt;或者[]修饰，前者意为必须参数，后者意为可选参数 第二个参数为选项描述 第三个参数为选项参数默认值，可选 准备原材料什么原材料？我们需要输出ascii的动物图像和一些名言、段子等文本，这里数据我就存放在 data 目录下。 当然做的高级点你可以用爬虫~ 本文引砖抛玉了 我准备了 animals.txt 里面存放的是ascii的动物图像，像这样： lowb终端程序 如果觉得这些你不喜欢可以上这里看看还有更多的小动物任你把玩。 还有 段子，名言， 唐诗，宋词 的数据 将这5个文本数据存放在 data 目录下，使用JS变量存储一下 var fs = require('fs');var path = require('path');var animals = fs.readFileSync(path.join(__dirname, '../data/animals.txt')).toString() .split('===============++++SEPERATOR++++====================\\n');var jokes = fs.readFileSync(path.join(__dirname, '../data/jokes.txt')).toString().split('%\\n');var quotes = fs.readFileSync(path.join(__dirname, '../data/quotes.txt')).toString().split('%\\n');var tang300 = fs.readFileSync(path.join(__dirname, '../data/tang300.txt')).toString().split('%\\n');var song100 = fs.readFileSync(path.join(__dirname, '../data/song100.txt')).toString().split('%\\n'); 读取数据编写2个函数，一个用于产生随机的ascii动物文本，一个用于返回名言或段子 /** * 返回一个随机的动物ascii * * @returns &#123;*&#125; */function randomAnimal() &#123; return animals[Math.floor(Math.random() * animals.length)];&#125;/** * 根据类型返回名言或段子 * * @param type * @returns &#123;string&#125; */function prefix(type) &#123; switch (type) &#123; case 'quotes': return quotes[Math.floor(Math.random() * quotes.length)]; case 'jokes': return jokes[Math.floor(Math.random() * jokes.length)]; case 'tang': return tang300[Math.floor(Math.random() * tang300.length)]; case 'song': return song100[Math.floor(Math.random() * song100.length)]; default: return tang300[Math.floor(Math.random() * tang300.length)]; &#125;&#125; 然后在命令解析的下面开始调用他们吧~ var animal = cmd.index === -1 ? randomAnimal() : animals[cmd.index];console.log(prefix(cmd.type));console.log(animal); 这里的逻辑非常简单，如果没有指定动物索引则随机获取一个小动物，否则取指定的。 然后输出名言/段子，输出一个小动物~ 大功告成 来试试吧程序编写ok后我们安装到本地，然后执行 lowb -t jokes 试试看？ 阿里小米皆自主，百度排名最公平； 京东全网最低价，当当爱国很理性； 用户体验看新浪，网易从来少愤青； 豆瓣从来不约炮，人人分享高水平； 从不抄袭数腾讯， 开放安全三六零。 ____ ,.-''''-,__,..---'''``` ``''-. // ' `. `, 7; ) . Y \\ / / L, : \\. \\\\| ,` | `'. ,.-'^, \\\\``', ( ; ; `, //`_),.\\|\\)_ .\\ / ,A ._,^ \\ L\\) ,+`[ e\\ \\.-`''--......-__`. _, `\\. )Y _,--` \\ )`.`, // ```` / )_.-' |//,/`_)'` `''-. `/ _,.......----------'\"\"\"'`` /\\\\)\\) `\" +` ________ _,` `` ` ,`,'`` ```````'\"\"\"\"\"\"\"'`` |7 sk \\_, 默认输出的是名言，我加了-t参数指定来个段子。 发布到NPM仓库我们希望所有人都可以下载到自己写的程序就需要将它发布到npm的仓库中， 发布前需要注册npm账号，顺手绑定一下你的github账号吧。注册ok后在项目根目录下执行 sudo npm publish 会提示你输入一下npm的账号和密码验证，完了就会推送到 npmjs.org 了，你可以搜到自己的程序。 像安装其他程序一样安装 sudo npm install lowb -g（记得把本地安装的卸载了） 通过这篇文章相信你也可以编写一个终端程序玩了~ (๑•̀ㅂ•́) ✧加油","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://biezhi.me/tags/nodejs/"},{"name":"terminal","slug":"terminal","permalink":"http://biezhi.me/tags/terminal/"}]},{"title":"教你使用asciinema录制命令行操作","date":"2017-08-07T16:00:00.000Z","path":"2017/08/08/teach-you-how-to-use-asciinema.html","text":"asciinema 是一个在终端下非常棒的录制分享软件，基于文本的录屏工具，对终端输入输出进行捕捉， 然后以文本的形式来记录和回放！这使其拥有非常炫酷的特性：在 播放 过程中你随时可以暂停， 然后对“播放器”中的文本进行复制或者其它操作！实际效果可以点击下方的播放按钮查看。支持各个操作系统（哦。。没有windows） asciinema 原理将终端的操作记录成 JSON 格式，然后使用 JavaScript 解析，配合CSS展示，看起来像是视频播放器。 实际上就是文本，相比GIF和视频文件体积非常之小（时长2分50秒的录屏只有325KB），无需缓冲播放， 也可以方便的分享给别人或嵌入到网页中。 安装Mac brew install asciinema Pip安装 sudo pip3 install asciinema Ubuntu sudo apt-add-repository ppa:zanchey/asciinemasudo apt-get updatesudo apt-get install asciinema Arch Linux pacman -S asciinema Debian sudo apt-get install asciinema Fedora # Fedora &lt; 22sudo yum install asciinema# Fedora &gt;= 22sudo dnf install asciinema 更多安装姿势 举个栗子安装ok后，我们来尝试录制一个试试？在你的终端输入 asciinema rec 回车后你会看到下面两行输出 ~ Asciicast recording started.~ Hit Ctrl-D or type \"exit\" to finish. 这表示录制已经开始，你可以按 Ctrl+D 或输入 exit 进行退出，下面是我录制的一个例子： 退出后终端会输出 ~ Asciicast recording finished.~ Press &lt;Enter&gt; to upload, &lt;Ctrl-C&gt; to cancel. 按下回车即将你的录制上传到公共网站上，按下 Ctrl+C 即退出，本次操作不会保存。 还有什么？回放录制 我们前面录制了一个，我可以使用 asciinema play 命令在本地回放刚才的录制操作 asciinema play https://asciinema.org/a/132560 回放本地的一个文件 asciinema play /path/132560.json 嵌入播放 本文中就是使用这种方式的 &lt;script type=\"text/javascript\" src=\"https://asciinema.org/a/132560.js\"id=\"asciicast-132560\" async&gt;&lt;/script&gt; markdown的方式 [![asciicast](https://asciinema.org/a/132560.png)](https://asciinema.org/a/132560) 自由拷贝 在播放记录时，可以自由地拷贝正在播放的记录中的命令，这一点上 ttyrec 和 screen 是无法相比的。 当你在观看别人的记录时，如果有一些非常炫酷的命令，当然会心痒难耐想要自己亲手试一试，这个时候这个特性实在是不要太赞！ 删除录制 有时候不小心录制了一些隐私信息上去，不要担心，你可以在诸如 https://asciinema.org/a/132556 这个链接中登录进去删除它。 配置文件 在 Asciinema 的网站上，可以用自己的邮箱进行登录，在本地可以配置一下认证： asciinema authvim ~/.config/asciinema/config 配置文件长下面这个样子 [api]token = &lt;your-api-token-here&gt; 你也可以在这个文件中设置几个选项，这是一个所有可用的选项： [api]token = &lt;your-api-token-here&gt;url = https://asciinema.example.com[record]command = /bin/bash -lmaxwait = 2yes = truequiet = true[play]maxwait = 1 [api] 中的选项与API位置和身份验证有关； 如果要让asciinema使用您自己的asciinema站点而不是默认的asciinema.org，可以设置url选项。 API URL也可以通过 ASCIINEMA_API_URL 环境变量传递。 [record]和[play]部分中的选项配合 asciinema rec/asciinema play 命令（请参阅其他参数）。 如果经常使用-c，-w或-y这些命令，推荐将其作为默认保存在配置文件中。 其他参数☁ ~ asciinema -husage: asciinema [-h] [--version] &#123;rec,play,upload,auth&#125; ...Record and share your terminal sessions, the right way.positional arguments: &#123;rec,play,upload,auth&#125; rec Record terminal session(开始录制终端会话) play Replay terminal session(播放终端会话) upload Upload locally saved terminal session to asciinema.org(上传本地录制内容到asciinema) auth Manage recordings on asciinema.org account(登录asciinema账号管理录制记录)optional arguments: -h, --help show this help message and exit --version show program's version number and exitexample usage: Record terminal and upload it to asciinema.org: asciinema rec Record terminal to local file: asciinema rec demo.json Record terminal and upload it to asciinema.org, specifying title: asciinema rec -t \"My git tutorial\" Record terminal to local file, \"trimming\" longer pauses to max 2.5 sec: asciinema rec -w 2.5 demo.json Replay terminal recording from local file: asciinema play demo.json Replay terminal recording hosted on asciinema.org: asciinema play https://asciinema.org/a/difqlgx86ym6emrmd8u62yqu8For help on a specific command run: asciinema &lt;command&gt; -h -t：自定义名称，如 asciinema rec -t &quot;run first blade app&quot; -w：暂停时间最多多少秒，如 asciinema rec -w 2.5 demo.json，录制终端保存到本地，暂停时间最多2.5秒 这里 有很多别人分享的有趣的录制。","tags":[{"name":"terminal","slug":"terminal","permalink":"http://biezhi.me/tags/terminal/"},{"name":"asciinema","slug":"asciinema","permalink":"http://biezhi.me/tags/asciinema/"}]},{"title":"SSH免密登录是怎么玩儿的?","date":"2017-08-06T16:00:00.000Z","path":"2017/08/07/ssh-no-password-login.html","text":"作为一名后端开发，经常会遇到SSH登录，Git提交等事务，而当你有很多服务器的时候使用密码可能不是一个好的选择了， 就像我要登录自己的服务器、公司各个环境的服务器，虽然有工具可以帮我们做这些，但我习惯在命令行下操作。 下面我带你了解一下免密登录的原理和如何实现。 SSH免密登录 基本概念SSH协议SSH 是一种计算机之间加密登录的协议，它相对于telnet和rsh的明文传输， 提供了加密、校验和压缩，使得我们可以很安全的远程操作， 而不用担心信息泄露(当然不是绝对的，加密总有可能被破解，只是比起明文来说那是强了不少)。 加密加密的意思是将一段数据经过处理之后，输出为一段外人无法或者很难破译的数据，除了指定的人可以解密之外。 一般来说，加密的输入还会有一个key，这个key作为加密的参数，而在解密的时候也会用一个相关联(有可能是相同)的key作为输入。 粗略来说是下面的流程： # 加密方encrypted_data = encrypt(raw_data, key)# 解密方raw_data = decrypt(encrypted_data, key1) 目前主流的加密算法一般分为下面两类： 私钥(secret key)加密，也称为对称加密 公钥(public key)加密 私钥加密所谓的私钥加密，是说加密方和解密方用的都是同一个key，这个key对于加密方和解密方来说是保密的， 第三方是不能知道的。在第三方不知道私钥的情况下，是很难将加密的数据解密的。 一般来说是加密方先产生私钥，然后通过一个安全的途径来告知解密方这个私钥。 公钥加密公钥加密，是说解密的一方首先生成一对密钥，一个私钥一个公钥，私钥不会泄漏出去，而公钥则是可以任意的对外发布的。 用公钥进行加密的数据，只能用私钥才能解密。加密方首先从解密方获取公钥，然后利用这个公钥进行加密，把数据发送给解密方。 解密方利用私钥进行解密。如果解密的数据在传输的过程中被第三方截获，也不用担心，因为第三方没有私钥，没有办法进行解密。 公钥加密的问题还包括获取了公钥之后，加密方如何保证公钥来自于确定的一方，而不是某个冒充的机器。 假设公钥不是来自我们信任的机器，那么就算我们用公钥加密也没有用，因为加密之后的数据是发送给了冒充的机器， 该机器就可以利用它产生的私钥进行解密了。所以公钥加密里面比较重要的一步是身份认证。 需要说明一下，一般的私钥加密都会比公钥加密快，所以大数据量的加密一般都会使用私钥加密， 而公钥加密会作为身份验证和交换私钥的一个手段。 数据一致性/完整性数据一致性说得是如何保证一段数据在传输的过程中没有遗漏、破坏或者修改过。一般来说，目前流行的做法是对数据进行hash， 得到的hash值和数据一起传输，然后在收到数据的时候也对数据进行hash，将得到的hash值和传输过来的hash值进行比对， 如果是不一样的，说明数据已经被修改过；如果是一样的，则说明极有可能是完整的。 目前流行的hash算法有MD5和SHA-1算法。 身份验证身份验证说的是，判断一个人或者机器是不是就是你想要联系的。也就是说如果A想要和B通信，一般来说开始的时候会交换一些数据， A怎么可以判断发送回来的数据就真的是B发送的呢？现实中有很多方法可以假冒一个机器。 在SSH里面，这主要是通过公钥来完成的。首先客户端会有一个公钥列表，保存的是它信任的机器上面的公钥。 在开始SSH连接之后，服务器会发送过来一个公钥，然后客户端就会进行查找，如果这个公钥在这个列表里面，就说明这个机器是真的服务器。 当然实际的情况会复杂一些。实际上服务器不是真的发送公钥过来，因为这很容易被第三方盗取。 免密码登录 在自己的操作系统上生成一对SSH KEY，如果已经存在可以不生成 将公钥上传到服务器上 生成SSH密钥和公钥ssh-keygen -t rsa 这样会在当前目录生成名为id_rsa的私钥文件和名为id_rsa.pub的公钥文件，-t表示密钥类型是rsa。 如果你只输入ssh-keygen生成的RSA密钥长度为2048，如果你对安全性要求比较高可以指定4096位的长度： ssh-keygen -b 4096 -t rsa 这里-b就是多少位，当然你对这些参数感兴趣可以使用--help参数看看具体的含义和解释。 当你在生成SSHKEY的时候在命令行下会提示你Enter file in which to save the key，让你确认密钥文件保存的路径， 一般回车即可（一般默认会在当前用户家目录下的.ssh目录下）。 第二个提示是 Enter passphrase (empty for no passphrase) 让你输入一个密钥的密码，如果不输入则留空；回车生成公私钥完毕 :) 此时你可以使用cat命令看下自己的公私钥。 服务器配置我们前面在自己的操作系统生成了公私钥，然后将公钥的内容告诉给服务器就可以了，让服务器知道自己公钥的操作方式还蛮多的。 上传公钥文件 将本地的公钥文件上传到服务器上，然后在服务器需要免密登录的用户家目录下查看是否有 ~/.ssh/authorized_keys 这个文件， 如果没有手动创建一个: touch ~/.ssh/authorized_keys 然后我们将公钥内容写入到authorized_keys文件中，因为这个文件可能已经有内容了，所以你可以使用如下方式 cat -n ~/.ssh/rsa.pub ~/.ssh/authorized_keys 这样就将公钥内容追加到authorized_keys中了，然后需要注意配置权限了，否则SSH不会工作的，我在这里踩了坑。。 将.ssh目录的权限为700 将authorized_keys目录的权限为600 ssh-copy-id 复制公钥 这个工具还蛮有用的，不过它会将我本地的所有公钥都传到服务器，使用方法： ssh-copy-id username@remote-server 因为我的服务器SSH端口不是22，所以使用 ssh-copy-id 登录用户@服务器IP -p端口 试试运用我们完成了这些步骤是不是就可以免密登录了呢？是的，你现在登录服务器： ssh user@host -p22 注意修改你自己的登录信息。 再简单一点 我们前面生成SSHKEY的时候还有一个私钥没用到，这是干什么用的呢？ 公钥是公开的，任何人都可以获得，私钥则是保密的，只有本地存储了一份， 配置本地的ssh，修改 ~/.ssh/config 文件： Host yourserver HostName 192.168.11.22 Port 12345 User username IdentityFile ~/.ssh/id_rsa 这里的 Host 是我们要登录的服务器的别名，为了方便快捷登录，下面是服务器的信息，最后一项是你的私钥路径。 完成这个配置后我们就可以使用 ssh yourserver，进行登录啦~ Github添加公钥 我经常会用到Github提交，拉取代码，总不能每次都输入用户名和密码吧。。 于是在Github上添加我自己的公钥即可 Github添加SSH公钥 配置完成后从你自己仓库的提交、拉取等操作就不用再输密码了。 常见问题ssh key Key is invalid 密钥错误，或者配置错误 github ssh key Key is invalid. Ensure you’ve copied the file correctly 在github上添加新key时，没有正确拷贝 ~/.ssh/id_rsa.pub 内容所致。 一般发生在linux下，因为windows下用notepa++打开这个文件并复制一般是没有问题的， 而linux下使用vim打开再复制就会因为vim添加了回车而导致key添加失败。 解决办法是：使用cat命令将 ~/.ssh/id_rsa.pub 内容输出到终端，再拷贝。 参考资料： RSA算法原理 SSH原理与运用：远程登录 一个SSH 公钥登录失败的问题及解决经验","tags":[{"name":"ssh","slug":"ssh","permalink":"http://biezhi.me/tags/ssh/"},{"name":"mac","slug":"mac","permalink":"http://biezhi.me/tags/mac/"},{"name":"github","slug":"github","permalink":"http://biezhi.me/tags/github/"}]},{"title":"十个JDBC的最佳实践","date":"2017-07-23T16:00:00.000Z","path":"2017/07/24/top-10-jdbc-best-practices-for-java.html","text":"JDBC是Java为多种关系型数据库提供的统一的访问接口，以下是我长期使用JDBC总结的十个最佳实践。 1. 使用PrearedStatement任何一个使用过JDBC的Java程序员几乎都知道这个，PreparedStatment可以通过预编译的方式避免我们在拼接SQL时造成SQL注入。 2. 使用ConnectionPool（连接池）使用连接池作为最佳实践几乎都成了公认的标准。一些框架已经提供了内建的连接池支持， 例如Spring中的Database Connection Pool，如果你的应用部署在JavaEE的应用服务器中， 例如JBoss，WAS，这些服务器也会有内建的连接池支持，例如DBCP。 使用连接的原因简单的说就是因为创建JDBC连接耗时比较长，如果每次查询都重新打开一个连接， 然后关闭，性能将会非常低，而如果事先创建好一批连接缓存起来，使用的时候取出， 不使用的时候仍不关闭，将会节省大量的创建关闭连接的时间。 3. 禁用自动提交这个最佳实践在我们使用JDBC的批量提交的时候显得非常有用，将自动提交禁用后， 你可以将一组数据库操作放在一个事务中，而自动提交模式每次执行SQL语句都将执行自己的事务， 并且在执行结束提交。 4. 使用Batch UpdateJDBC的API提供了通过addBatch()方法向batch中添加SQL查询，然后通过executeBatch()执行批量的查询。 JDBC batch update可以减少数据库数据传输的往返次数，从而提高性能。 5. 使用列名获取ResultSet中的数据，从而避免invalidColumIndexErrorJDBC中的查询结果封装在ResultSet中，我们可以通过列名和列序号两种方 式获取查询的数据， 当我们传入的列序号不正确的时候，就会抛出invalidColumIndexException， 例如你传入了0，就会出错，因为ResultSet中的列序号是从1开始的。 另外，如果你更改了数据表中列的顺序，你也不必更改JDBC代码，保持了程序的健壮性。 有一些Java程序员 可能会说通过序号访问列要比列名访问快一些，确实是这样，但是为了程序的健壮性、可读性，我还是更推荐你使用列名来访问。 6. 使用变量绑定而不是字符串拼接在第一条最佳实践中，我们已经说过要使用PreparedStatment可以防止注入，而使用？ 或者其他占位符也会提升性能，因为这样数据库就可以使用不同的参数执行相同的查询， 这个最佳实践带来更高的性能的同时也防止了SQL注入。 7. 要记住关闭Statement、PreparedStatement和Connection通常的做法是在finally块中关闭它们，这样做的好处是不论语句执行正确与否， 不管是否有异常抛出，都能保证资源被释放。在Java7中，可以通过Automatic Resource Management Block来自动的关闭资源。 8. 选择合适的JDBC驱动有四种JDBC驱动，分别是 JDBC-ODBC Bridge driver (bridge driver) Native-API/partly Java driver (native driver) AllJava/Net-protocol driver (middleware driver) All Java/Native-protocol driver (Pure java driver) 9. 尽量使用标准的SQL语句，从而在某种程度上避免数据库对SQL支持的差异不同的数据库厂商的数据库产品支持的SQL的语法会有一定的出入，为了方便移植，我推荐使用标准的ANSI SQL标准写SQL语句。 10. 使用正确的getXXX()方法当从ResultSet中读取数据的时候，虽然JDBC允许你使用getString()和getObject()方法获取任何数据类型， 推荐使用正确的getXXX方法，这样可以避免数据类型转换。 原文地址：http://javarevisited.blogspot.in/2012/08/top-10-jdbc-best-practices-for-java.html","tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://biezhi.me/tags/JDBC/"},{"name":"最佳实践","slug":"最佳实践","permalink":"http://biezhi.me/tags/最佳实践/"},{"name":"连接池","slug":"连接池","permalink":"http://biezhi.me/tags/连接池/"}]},{"title":"跟上Java8 - 你忽略了的新特性","date":"2017-07-20T16:00:00.000Z","path":"2017/07/21/keep-up-with-java8-features.html","text":"虽然我们开始了Java8的旅程，但是很多人直接从java6上手了java8， 也许有一些JDK7的特性你还不知道，在本章节中带你回顾一下我们忘记了的那些特性。 尽管我们不能讲所有特性都讲一遍，挑出常用的核心特性拎出来一起学习。 新特新 异常改进try-with-resources这个特性是在JDK7种出现的，我们在之前操作一个流对象的时候大概是这样的： try &#123; // 使用流对象 stream.read(); stream.write();&#125; catch(Exception e)&#123; // 处理异常&#125; finally &#123; // 关闭流资源 if(stream != null)&#123; stream.close(); &#125;&#125; 这样无疑有些繁琐，而且finally块还有可能抛出异常。在JDK7种提出了try-with-resources机制， 它规定你操作的类只要是实现了AutoCloseable接口就可以在try语句块退出的时候自动调用close 方法关闭流资源。 public static void tryWithResources() throws IOException &#123; try( InputStream ins = new FileInputStream(\"/home/biezhi/a.txt\") )&#123; char charStr = (char) ins.read(); System.out.print(charStr); &#125;&#125; 使用多个资源 try ( InputStream is = new FileInputStream(\"/home/biezhi/a.txt\"); OutputStream os = new FileOutputStream(\"/home/biezhi/b.txt\")) &#123; char charStr = (char) is.read(); os.write(charStr);&#125; 当然如果你使用的是非标准库的类也可以自定义AutoCloseable，只要实现其close方法即可。 捕获多个Exception当我们在操作一个对象的时候，有时候它会抛出多个异常，像这样： try &#123; Thread.sleep(20000); FileInputStream fis = new FileInputStream(\"/a/b.txt\");&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 这样代码写起来要捕获很多异常，不是很优雅，JDK7种允许你捕获多个异常: try &#123; Thread.sleep(20000); FileInputStream fis = new FileInputStream(\"/a/b.txt\");&#125; catch (InterruptedException | IOException e) &#123; e.printStackTrace();&#125; 并且catch语句后面的异常参数是final的，不可以再修改/复制。 处理反射异常使用过反射的同学可能知道我们有时候操作反射方法的时候会抛出很多不相关的检查异常，例如： try &#123; Class&lt;?&gt; clazz = Class.forName(\"com.biezhi.apple.User\"); clazz.getMethods()[0].invoke(object);&#125; catch (IllegalAccessException e) &#123; e.printStackTrace();&#125; catch (InvocationTargetException e) &#123; e.printStackTrace();&#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125; 尽管你可以使用catch多个异常的方法将上述异常都捕获，但这也让人感到痛苦。 JDK7修复了这个缺陷，引入了一个新类ReflectiveOperationException可以帮你捕获这些反射异常: try &#123; Class&lt;?&gt; clazz = Class.forName(\"com.biezhi.apple.User\"); clazz.getMethods()[0].invoke(object);&#125; catch (ReflectiveOperationException e)&#123; e.printStackTrace();&#125; 文件操作我们知道在JDK6甚至之前的时候，我们想要读取一个文本文件也是非常麻烦的一件事，而现在他们都变得简单了， 这要归功于NIO2，我们先看看之前的做法: 读取一个文本文件 BufferedReader br = null;try &#123; new BufferedReader(new FileReader(\"file.txt\")); StringBuilder sb = new StringBuilder(); String line = br.readLine(); while (line != null) &#123; sb.append(line); sb.append(System.lineSeparator()); line = br.readLine(); &#125; String everything = sb.toString();&#125; catch (Exception e)&#123; e.printStackTrace();&#125; finally &#123; try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 大家对这样的一段代码一定不陌生，但这样太繁琐了，我只想读取一个文本文件，要写这么多代码还要 处理让人头大的一堆异常，怪不得别人吐槽Java臃肿，是在下输了。。。 下面我要介绍在JDK7中是如何改善这些问题的。 PathPath用于来表示文件路径和文件，和File对象类似，Path对象并不一定要对应一个实际存在的文件， 它只是一个路径的抽象序列。 要创建一个Path对象有多种方法，首先是final类Paths的两个static方法，如何从一个路径字符串来构造Path对象： Path path1 = Paths.get(\"/home/biezhi\", \"a.txt\");Path path2 = Paths.get(\"/home/biezhi/a.txt\");URI u = URI.create(\"file:////home/biezhi/a.txt\");Path pathURI = Paths.get(u); 通过FileSystems构造 Path filePath = FileSystems.getDefault().getPath(\"/home/biezhi\", \"a.txt\"); Path、URI、File之间的转换 File file = new File(\"/home/biezhi/a.txt\");Path p1 = file.toPath();p1.toFile();file.toURI(); 读写文件你可以使用Files类快速实现文件操作，例如读取文件内容: byte[] data = Files.readAllBytes(Paths.get(\"/home/biezhi/a.txt\"));String content = new String(data, StandardCharsets.UTF_8); 如果希望按照行读取文件，可以调用 List&lt;String&gt; lines = Files.readAllLines(Paths.get(\"/home/biezhi/a.txt\")); 反之你想将字符串写入到文件可以调用 Files.write(Paths.get(\"/home/biezhi/b.txt\"), \"Hello JDK7!\".getBytes()); 你也可以按照行写入文件，Files.write方法的参数中支持传递一个实现Iterable接口的类实例。 将内容追加到指定文件可以使用write方法的第三个参数OpenOption: Files.write(Paths.get(\"/home/biezhi/b.txt\"), \"Hello JDK7!\".getBytes(), StandardOpenOption.APPEND); 默认情况Files类中的所有方法都会使用UTF-8编码进行操作，当你不愿意这么干的时候可以传递Charset参数进去变更。 当然Files还有一些其他的常用方法: InputStream ins = Files.newInputStream(path);OutputStream ops = Files.newOutputStream(path);Reader reader = Files.newBufferedReader(path);Writer writer = Files.newBufferedWriter(path); 创建、移动、删除创建文件、目录 if (!Files.exists(path)) &#123; Files.createFile(path); Files.createDirectory(path);&#125; Files还提供了一些方法让我们创建临时文件/临时目录: Files.createTempFile(dir, prefix, suffix);Files.createTempFile(prefix, suffix);Files.createTempDirectory(dir, prefix);Files.createTempDirectory(prefix); 这里的dir是一个Path对象，并且字符串prefix和suffix都可能为null。 例如调用Files.createTempFile(null, &quot;.txt&quot;)会返回一个类似/tmp/21238719283331124678.txt 读取一个目录下的文件请使用Files.list和Files.walk方法 复制、移动一个文件内容到某个路径 Files.copy(in, path);Files.move(path, path); 删除一个文件 Files.delete(path); 小的改进Java8是一个较大改变的版本，包含了API和库方面的修正，它还对我们常用的API进行很多微小的调整， 下面我会带你了解字符串、集合、注解等新方法。 字符串使用过JavaScript语言的人可能会知道当我们将一个数组中的元素组合起来变成字符串有一个方法join， 例如我们经常用到将数组中的字符串拼接成用逗号分隔的一长串，这在Java中是要写for循环来完成的。 Java8种添加了join方法帮你搞定这一切: String str = String.join(\",\", \"a\", \"b\", \"c\"); 第一个参数是分隔符，后面接收一个CharSequence类型的可变参数数组或一个Iterable。 集合集合改变中最大的当属前面章节中提到的Stream API，除此之外还有一些小的改动。 类/接口 新方法 Iterable foreach Collection removeIf List replaceAll, sort Map forEach, replace, replaceAll, remove(key, value), putIfAbsent, compute, computeIf, merge Iterator forEachRemaining BitSet stream Map中的很多方法对并发访问十分重要，我们将在后面的章节中介绍 Iterator提供forEachRemaining将剩余的元素传递给一个函数 BitSet可以产生一个Stream对象 通用目标类型判断 Java8对泛型参数的推断进行了增强。相信你对Java8之前版本中的类型推断已经比较熟悉了。 比如，Collections中的方法emptyList方法定义如下： static &lt;T&gt; List&lt;T&gt; emptyList(); emptyList方法使用了类型参数T进行参数化。 你可以像下面这样为该类型参数提供一个显式的类型进行函数调用： List&lt;Person&gt; persons = Collections.&lt;Person&gt;emptyList(); 不过编译器也可以推断泛型参数的类型，上面的代码和下面这段代码是等价的： List&lt;Person&gt; persons = Collections.emptyList(); 我还是习惯于这样书写。 注解Java 8在两个方面对注解机制进行了改进，分别为： 可以定义重复注解 可以为任何类型添加注解 重复注解之前版本的Java禁止对同样的注解类型声明多次。由于这个原因，下面的第二句代码是无效的： @interface Basic &#123; String name();&#125;@Basic(name=\"fix\")@Basic(name=\"todo\")class Person&#123; &#125; 我们之前可能会通过数组的做法绕过这一限制: @interface Basic &#123; String name();&#125;@interface Basics &#123; Basic[] value();&#125;@Basics( &#123; @Basic(name=\"fix\") , @Basic(name=\"todo\") &#125; )class Person&#123; &#125; Book类的嵌套注解相当难看。这就是Java8想要从根本上移除这一限制的原因，去掉这一限制后， 代码的可读性会好很多。现在，如果你的配置允许重复注解，你可以毫无顾虑地一次声明多个同一种类型的注解。 它目前还不是默认行为，你需要显式地要求进行重复注解。 创建一个重复注解 如果一个注解在设计之初就是可重复的，你可以直接使用它。但是，如果你提供的注解是为用户提供的， 那么就需要做一些工作，说明该注解可以重复。下面是你需要执行的两个步骤： 将注解标记为@Repeatable 提供一个注解的容器下面的例子展示了如何将@Basic注解修改为可重复注解 @Repeatable(Basics.class)@interface Basic &#123; String name();&#125;@Retention(RetentionPolicy.RUNTIME)@interface Basics &#123; Basic[] value();&#125; 完成了这样的定义之后，Person类可以通过多个@Basic注解进行注释，如下所示： @Basic(name=\"fix\")@Basic(name=\"todo\")class Person&#123; &#125; 编译时， Person 会被认为使用了 @Basics( { @Basic(name=&quot;fix&quot;) , @Basic(name=&quot;todo&quot;)} ) 这样的形式进行了注解，所以，你可以把这种新的机制看成是一种语法糖， 它提供了程序员之前利用的惯用法类似的功能。为了确保与反射方法在行为上的一致性， 注解会被封装到一个容器中。 Java API中的getAnnotation(Class&lt;T&gt; annotationClass)方法会为注解元素返回类型为T的注解。 如果实际情况有多个类型为T的注解，该方法的返回到底是哪一个呢？ 我们不希望一下子就陷入细节的魔咒，类Class提供了一个新的getAnnotationsByType方法， 它可以帮助我们更好地使用重复注解。比如，你可以像下面这样打印输出Person类的所有Basic注解： 返回一个由重复注解Basic组成的数组 public static void main(String[] args) &#123; Basic[] basics = Person.class.getAnnotationsByType(Basic.class); Arrays.asList(basics).forEach(a -&gt; &#123; System.out.println(a.name()); &#125;);&#125; Null检查Objects类添加了两个静态方法isNull和nonNull，在使用流的时候非常有用。 例如获取一个流的所有不为null的对象: Stream.of(\"a\", \"c\", null, \"d\") .filter(Objects::nonNull) .forEach(System.out::println); Optional空指针异常一直是困扰Java程序员的问题，也是我们必须要考虑的。当业务代码中充满了if else判断null 的时候程序变得不再优雅，在Java8中提供了Optional类为我们解决NullPointerException。 我们先来看看这段代码有什么问题? class User &#123; String name; public String getName() &#123; return name; &#125;&#125;public static String getUserName(User user)&#123; return user.getName();&#125; 这段代码看起来很正常，每个User都会有一个名字。所以调用getUserName方法会发生什么呢？ 实际这是不健壮的程序代码，当User对象为null的时候会抛出一个空指针异常。 我们普遍的做法是通过判断user != null然后获取名称 public static String getUserName(User user)&#123; if(user != null)&#123; return user.getName(); &#125; return null;&#125; 但是如果对象嵌套的层次比较深的时候这样的判断我们需要编写多少次呢？难以想象 处理空指针使用Optional优化代码 public static String getUserNameByOptional(User user) &#123; Optional&lt;String&gt; userName = Optional.ofNullable(user).map(User::getName); return userName.orElse(null);&#125; 当user为null的时候我们设置UserName的值为null，否则返回getName的返回值，但此时不会抛出空指针。 在之前的代码片段中是我们最熟悉的命令式编程思维，写下的代码可以描述程序的执行逻辑，得到什么样的结果。 后面的这种方式是函数式思维方式，在函数式的思维方式里，结果比过程更重要，不需要关注执行的细节。程序的具体执行由编译器来决定。 这种情况下提高程序的性能是一个不容易的事情。 我们再次了解下Optional中的一些使用方法 Optional方法创建 Optional 对象 你可以通过静态工厂方法Optional.empty，创建一个空的Optional对象： Optional&lt;User&gt; emptyUser = Optional.empty(); 创建一个非空值的Optional Optional&lt;User&gt; userOptional = Optional.of(user); 如果user是一个null，这段代码会立即抛出一个NullPointerException，而不是等到你试图访问user的属性值时才返回一个错误。 可接受null的Optional Optional&lt;User&gt; ofNullOptional = Optional.ofNullable(user); 使用静态工厂方法Optional.ofNullable，你可以创建一个允许null值的Optional对象。 如果user是null，那么得到的Optional对象就是个空对象，但不会让你导致空指针。 使用map从Optional对象中提取和转换值 Optional&lt;User&gt; ofNullOptional = Optional.ofNullable(user);Optional&lt;String&gt; userName = ofNullOptional.map(User::getName); 这种操作就像我们之前在操作Stream是一样的，获取的只是User中的一个属性。 默认行为及解引用Optional对象 我们决定采用orElse方法读取这个变量的值，使用这种方式你还可以定义一个默认值， 遭遇空的Optional变量时，默认值会作为该方法的调用返回值。 Optional类提供了多种方法读取 Optional实例中的变量值。 get()是这些方法中最简单但又最不安全的方法。如果变量存在，它直接返回封装的变量 值，否则就抛出一个NoSuchElementException异常。所以，除非你非常确定Optional 变量一定包含值，否则使用这个方法是个相当糟糕的主意。此外，这种方式即便相对于 嵌套式的null检查，也并未体现出多大的改进。 orElse(T other)是我们在代码清单10-5中使用的方法，正如之前提到的，它允许你在 Optional对象不包含值时提供一个默认值。 orElseGet(Supplier&lt;? extends T&gt; other)是orElse方法的延迟调用版，Supplier 方法只有在Optional对象不含值时才执行调用。如果创建默认值是件耗时费力的工作， 你应该考虑采用这种方式（借此提升程序的性能），或者你需要非常确定某个方法仅在 Optional为空时才进行调用，也可以考虑该方式（这种情况有严格的限制条件）。 orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)和get方法非常类似， 它们遭遇Optional对象为空时都会抛出一个异常，但是使用orElseThrow你可以定制希 望抛出的异常类型。 ifPresent(Consumer&lt;? super T&gt;)让你能在变量值存在时执行一个作为参数传入的 方法，否则就不进行任何操作。 当前除了这些Optional类也具备一些和Stream类似的API，我们先看看Optional类方法: 方法 描述 empty 返回一个空的 Optional 实例 get 如果该值存在，将该值用Optional包装返回，否则抛出一个NoSuchElementException异常 ifPresent 如果值存在，就执行使用该值的方法调用，否则什么也不做 isPresent 如果值存在就返回true，否则返回false filter 如果值存在并且满足提供的谓词，就返回包含该值的 Optional 对象;否则返回一个空的Optional对象 map 如果值存在，就对该值执行提供的 mapping 函数调用 flatMap 如果值存在，就对该值执行提供的 mapping 函数调用，返回一个 Optional 类型的值，否则就返 回一个空的Optional对象 of 将指定值用 Optional 封装之后返回，如果该值为null，则抛出一个NullPointerException异常 ofNullable 将指定值用 Optional 封装之后返回，如果该值为 null，则返回一个空的Optional对象 orElse 如果有值则将其返回，否则返回一个默认值 orElseGet 如果有值则将其返回，否则返回一个由指定的 Supplier 接口生成的值 orElseThrow 如果有值则将其返回，否则抛出一个由指定的 Supplier 接口生成的异常 用Optional封装可能为null的值 目前我们写的大部分Java代码都会使用返回NULL的方式来表示不存在值，比如Map中通过Key获取值， 当不存在该值会返回一个null。 但是，正如我们之前介绍的，大多数情况下，你可能希望这些方法能返回一个Optional对象。 你无法修改这些方法的签名，但是你很容易用Optional对这些方法的返回值进行封装。 我们接着用Map做例子，假设你有一个Map&lt;String, Object&gt;类型的map，访问由key的值时， 如果map中没有与key关联的值，该次调用就会返回一个null。 Object value = map.get(\"key\"); 使用Optional封装map的返回值，你可以对这段代码进行优化。要达到这个目的有两种方式： 你可以使用笨拙的if-then-else判断语句，毫无疑问这种方式会增加代码的复杂度； 或者你可以采用Optional.ofNullable方法 Optional&lt;Object&gt; value = Optional.ofNullable(map.get(\"key\")); 每次你希望安全地对潜在为null的对象进行转换，将其替换为Optional对象时，都可以考虑使用这种方法。 参考资料：Java文件IO操作应该抛弃File拥抱Paths和Files","tags":[{"name":"Java8","slug":"Java8","permalink":"http://biezhi.me/tags/Java8/"},{"name":"features","slug":"features","permalink":"http://biezhi.me/tags/features/"}]},{"title":"分享我安装的Chrome插件","date":"2017-07-20T16:00:00.000Z","path":"2017/07/21/my-chrome-extensions.html","text":"ABP广告拦截插件 Adblock Plus 已被超过 1 亿台设备使用，是世界上最受欢迎的广告拦截软件。 商店地址 draw作图应用 draw.io 是一款免费的在线图表编辑工具, 可以用来编辑工作流, BPM, org charts, UML, ER图, 网络拓朴图等。 商店地址 Postman Postman可以帮助你更有效的针对API工作。Postman是一个scratch-your-own-itch项目。它需要的是开发者有效的在项目中创建APIS，能够对API测试进行收藏保留。 商店地址 REST 网页开发者辅助程序来创建和测试自定义HTTP请求。它是一款非常强大，使用简单的客户端测试工具，得到了程序员的好评。每周超过50k的开发者使用此应用程序。如此多的人是不会错的！ 商店地址 JsonView Jsonview是目前最热门的一款开发者工具插件，确切的来说JSONView是一款非常实用的格式化和语法高亮JSON格式数据查看器jQuery插件。 它是查看json数据的神器。 商店地址 Github代码查看 Octotree 是一个 Chrome 扩展，能让你以树形的方式显示 GitHub 项目的目录结构。 商店地址 特性： 类似 IDE 的非常方便的代码目录树 使用 PJAX 的超快代码浏览 支持公有库和私有库 Pixlr-Today Pixlr Today是一个Chrome新标签页扩展，支持自定义搜索，集成天气，带有备忘与 Todo，还可以每日更换壁纸。 商店地址 网站分析利器 Wappalyzer 网站是一个可以分析不同网站所使用的各种技术的工具，对于有自身经验的网站开发者而言可以通过代码开分析网站的构架和所采用的技术，不过现在你可以通过工具来获得网站技术的参数报告了。 商店地址 二维码生成 使用此插件可以生成当前网址的二维码,手机直接扫二维码就可以访问当前页面。 商店地址 划词翻译 让浏览任意语言的网站变得无比轻松的 Chrome 扩展程序。 商店地址 特点 划词即显示翻译结果，简单、方便、迅速，并且支持多种语言的朗读。 支持在 PDF 文档内使用。 支持多种翻译引擎：有道翻译、百度翻译、谷歌翻译（含谷歌中国翻译）、必应词典。 标签一键保存 标签一键保存：您必备的标签工具 当您打开多个标签时，通过标签一键保存可以立刻保存所有标签，当您下次想打开时，可以一键全部打开。 商店地址 功能介绍： 一键保存当前窗口所有标签 一键打开保存的所有标签 支持自定义标签文件夹名称 浏览标签文件夹下的标签内容 删除指定的标签或标签文件夹 打开单个标签页 流量节省程序 使用 Google 服务器优化您访问的网页，借此减少流量消耗。 加载更快，流量更省！ 启用此扩展程序后，Chrome 会在加载您要访问的网页之前先使用 Google 服务器对其进行压缩。Google 将不会优化您通过私密连接 (HTTPS) 或在隐身标签页中访问的网页，而且也检测不到这些网页。点击“详细信息”即可查看您访问的网站消耗的流量，从而进一步了解您的流量消耗情况。这可能有助于您根据所使用的网络连接的类型在流量消耗方面做出更明智的决策。 商店地址 以上是我使用的Chrome插件，分享给大家！","tags":[{"name":"chrome","slug":"chrome","permalink":"http://biezhi.me/tags/chrome/"},{"name":"插件","slug":"插件","permalink":"http://biezhi.me/tags/插件/"},{"name":"postman","slug":"postman","permalink":"http://biezhi.me/tags/postman/"}]},{"title":"跟上Java8 - 日期和时间实用技巧","date":"2017-07-19T16:00:00.000Z","path":"2017/07/20/keep-up-with-java8-datetime.html","text":"当你开始使用Java操作日期和时间的时候，会有一些棘手。你也许会通过System.currentTimeMillis() 来返回1970年1月1日到今天的毫秒数。或者使用Date类来操作日期；当遇到加减月份、天数的时候 你又需要用到Calendar类；当需要格式化日期的时候需要使用java.text.DateFormat类。 总而言之在Java中操作日期不是很方便，以至于很多开发者不得不使用第三方库，比如: joda-time 时间 现有API存在的问题 线程安全: Date和Calendar不是线程安全的，你需要编写额外的代码处理线程安全问题 API设计和易用性: 由于Date和Calendar的设计不当你无法完成日常的日期操作 ZonedDate和Time: 你必须编写额外的逻辑处理时区和那些旧的逻辑 好在JSR 310规范中为Java8添加了新的API， 在java.time包中，新的API纠正了过去的缺陷， 新的日期API ZoneId: 时区ID，用来确定Instant和LocalDateTime互相转换的规则 Instant: 用来表示时间线上的一个点 LocalDate: 表示没有时区的日期, LocalDate是不可变并且线程安全的 LocalTime: 表示没有时区的时间, LocalTime是不可变并且线程安全的 LocalDateTime: 表示没有时区的日期时间, LocalDateTime是不可变并且线程安全的 Clock: 用于访问当前时刻、日期、时间，用到时区 Duration: 用秒和纳秒表示时间的数量 最常用的就是LocalDate、LocalTime、LocalDateTime了，从它们的名字就可以看出是操作日期 和时间的。这些类是主要用于当时区不需要显式地指定的上下文。在本章节中我们将讨论最常用的api。 LocalDateLocalDate代表一个IOS格式(yyyy-MM-dd)的日期，可以存储 生日、纪念日等日期。 获取当前的日期： LocalDate localDate = LocalDate.now();System.out.println(\"localDate: \" + localDate); localDate: 2017-07-20 LocalDate可以指定特定的日期，调用of或parse方法返回该实例： LocalDate.of(2017, 07, 20);LocalDate.parse(\"2017-07-20\"); 当然它还有一些其他方法，我们一起来看看： 为今天添加一天，也就是获取明天 LocalDate tomorrow = LocalDate.now().plusDays(1); 从今天减去一个月 LocalDate prevMonth = LocalDate.now().minus(1, ChronoUnit.MONTHS); 下面写两个例子，分别解析日期 2017-07-20，获取每周中的星期和每月中的日： DayOfWeek thursday = LocalDate.parse(\"2017-07-20\").getDayOfWeek();System.out.println(\"周四: \" + thursday);int twenty = LocalDate.parse(\"2017-07-20\").getDayOfMonth();System.out.println(\"twenty: \" + twenty); 试试今年是不是闰年: boolean leapYear = LocalDate.now().isLeapYear();System.out.println(\"是否闰年: \" + leapYear); 判断是否在日期之前或之后: boolean notBefore = LocalDate.parse(\"2017-07-20\") .isBefore(LocalDate.parse(\"2017-07-22\"));System.out.println(\"notBefore: \" + notBefore);boolean isAfter = LocalDate.parse(\"2017-07-20\").isAfter(LocalDate.parse(\"2017-07-22\"));System.out.println(\"isAfter: \" + isAfter); 获取这个月的第一天: LocalDate firstDayOfMonth = LocalDate.parse(\"2017-07-20\") .with(TemporalAdjusters.firstDayOfMonth());System.out.println(\"这个月的第一天: \" + firstDayOfMonth);firstDayOfMonth = firstDayOfMonth.withDayOfMonth(1);System.out.println(\"这个月的第一天: \" + firstDayOfMonth); 判断今天是否是我的生日，例如我的生日是 2009-07-20 LocalDate birthday = LocalDate.of(2009, 07, 20);MonthDay birthdayMd = MonthDay.of(birthday.getMonth(), birthday.getDayOfMonth());MonthDay today = MonthDay.from(LocalDate.now());System.out.println(\"今天是否是我的生日: \" + today.equals(birthdayMd)); LocalTimeLocalTime表示一个时间，而不是日期，下面介绍一下它的使用方法。 获取现在的时间，输出15:01:22.144 LocalTime now = LocalTime.now();System.out.println(\"现在的时间: \" + now); 将一个字符串时间解析为LocalTime，输出15:02 LocalTime nowTime = LocalTime.parse(\"15:02\");System.out.println(\"时间是: \" + nowTime); 使用静态方法of创建一个时间 LocalTime nowTime = LocalTime.of(15, 02);System.out.println(\"时间是: \" + nowTime); 使用解析字符串的方式并添加一小时，输出16:02 LocalTime nextHour = LocalTime.parse(\"15:02\").plus(1, ChronoUnit.HOURS);System.out.println(\"下一个小时: \" + nextHour); 获取时间的小时、分钟 int hour = LocalTime.parse(\"15:02\").getHour();System.out.println(\"小时: \" + hour);int minute = LocalTime.parse(\"15:02\").getMinute();System.out.println(\"分钟: \" + minute); 我们也可以通过之前类似的API检查一个时间是否在另一个时间之前、之后 boolean isBefore = LocalTime.parse(\"15:02\").isBefore(LocalTime.parse(\"16:02\"));boolean isAfter = LocalTime.parse(\"15:02\").isAfter(LocalTime.parse(\"16:02\"));System.out.println(\"isBefore: \" + isBefore);System.out.println(\"isAfter: \" + isAfter); 输出 isBefore: true, isAfter: false。 在LocalTime类中也将每天的开始和结束作为常量供我们使用: System.out.println(LocalTime.MAX);System.out.println(LocalTime.MIN); 输出: 23:59:59.99999999900:00 LocalTime就这些了，下面我们来了解一下LocalDateTime LocalDateTimeLocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。 获取当前的日期和时间: LocalDateTime now = LocalDateTime.now();System.out.println(\"现在: \" + now); 输出 现在: 2017-07-20T15:17:19.926 下面使用静态方法和字符串的方式分别创建LocalDateTime对象 LocalDateTime.of(2017, Month.JULY, 20, 15, 18);LocalDateTime.parse(\"2017-07-20T15:18:00\");``同时`LocalDateTime`也提供了相关API来对日期和时间进行增减操作:```javaLocalDateTime tomorrow = now.plusDays(1);System.out.println(\"明天的这个时间: \" + tomorrow);LocalDateTime minusTowHour = now.minusHours(2);System.out.println(\"两小时前: \" + minusTowHour); 这个类也提供一系列的get方法来获取特定单位: Month month = now.getMonth();System.out.println(\"当前月份: \" + month); 日期格式化在日常开发中我们用到最多的也许就是日期、时间的格式化了，那在Java8种该如何操作呢？ LocalDateTime now = LocalDateTime.now();DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");System.out.println(\"默认格式化: \" + now);System.out.println(\"自定义格式化: \" + now.format(dateTimeFormatter));LocalDateTime localDateTime = LocalDateTime.parse(\"2017-07-20 15:27:44\", dateTimeFormatter);System.out.println(\"字符串转LocalDateTime: \" + localDateTime); 也可以使用DateTimeFormatter的format方法将日期、时间格式化为字符串 DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");String dateString = dateTimeFormatter.format(LocalDate.now());System.out.println(\"日期转字符串: \" + dateString); 日期周期Period类用于修改给定日期或获得的两个日期之间的区别。 给初始化的日期添加5天: LocalDate initialDate = LocalDate.parse(\"2017-07-20\");LocalDate finalDate = initialDate.plus(Period.ofDays(5));System.out.println(\"初始化日期: \" + initialDate);System.out.println(\"加日期之后: \" + finalDate); 周期API中提供给我们可以比较两个日期的差别，像下面这样获取差距天数: long between = ChronoUnit.DAYS.between(initialDate, finalDate);System.out.println(\"差距天数: \" + between); 上面的代码会返回5，当然你想获取两个日期相差多少小时也是简单的。 与遗留代码转换在之前的代码中你可能出现了大量的Date类，如何将它转换为Java8种的时间类呢？ Date和Instant互相转换 Date date = Date.from(Instant.now());Instant instant = date.toInstant(); Date转换为LocalDateTime LocalDateTime localDateTime = LocalDateTime.from(new Date());System.out.println(localDateTime); LocalDateTime转Date Date date = Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant()); LocalDate转Date Date date = Date.from(LocalDate.now().atStartOfDay().atZone(ZoneId.systemDefault()).toInstant());","tags":[{"name":"Java8","slug":"Java8","permalink":"http://biezhi.me/tags/Java8/"},{"name":"datetime","slug":"datetime","permalink":"http://biezhi.me/tags/datetime/"}]},{"title":"跟上Java8 - 函数式编程","date":"2017-07-18T16:00:00.000Z","path":"2017/07/19/keep-up-with-java8-functional-programming.html","text":"在前面的章节我们快速学习了lambda和Stream，本章节中我们来回顾和理解函数式编程的思想。 我们不断的提及函数式这个名词，它指的是lambda吗？如果是这样，采用函数式编程能为你带来什么好处呢? 函数式编程 函数式的思考命令式编程一般我们实现一个系统有两种思考方式，一种专注于如何实现，比如下厨做菜，通常按照自己熟悉的烹饪方法：首先洗菜， 然后切菜，热油，下菜，然后…… 这看起来像是一系列的命令合集。对于这种”如何做”式的编程风格我们称之为命令式编程， 它的特点非常像工厂的流水线、计算机的指令处理，都是串行化、命令式的。 CookingTask cookingTask = new CookingTask();cookingTask.wash();cookingTask.cut();cookingTask.deepFry();cookingTask.fried();... 声明式编程还有一种方式你关注的是要做什么，我们如果用lambda和函数式来解决上述问题应该是这样的： public class CookingDemo &#123; public void doTask(String material, Consumer&lt;String&gt; consumer) &#123; consumer.accept(material); &#125; public static void main(String[] args) &#123; CookingDemo cookingDemo = new CookingDemo(); cookingDemo.doTask(\"蔬菜\", material -&gt; System.out.println(\"清洗\" + material)); cookingDemo.doTask(\"蔬菜\", material -&gt; System.out.println(material + \"切片\")); cookingDemo.doTask(\"食用油\", material -&gt; System.out.println(material + \"烧热\")); cookingDemo.doTask(\"\", material -&gt; System.out.println(\"炒菜\")); &#125;&#125; 这里我们将烹饪的实现细节交给了函数库，它最大的优势在于你读起来就像是在问题陈述，采用这种方式我们很快可以理解它的功能， 当你在烹饪流程中添加其他步骤也变得非常简单，你只需要调用doTask方法将材料传递进去处理，比如在食用油烧热前我要打个鸡蛋 cookingDemo.doTask(\"鸡蛋\", material -&gt; System.out.println(material + \"打碎搅拌均匀\")); 而不用再编写一个处理鸡蛋的方法。 什么是函数式编程对于“什么是函数式编程”这一问题最简化的回答是“它是一种使用函数进行编程的方式”。 每个人的理解都是不同的，其核心是：在思考问题时，使用不可变值和函数，函数对一个值进行处理，映射成另一个值。 不同的语言社区往往对各自语言中的特性孤芳自赏。现在谈Java程序员如何定义函数式编程还为时尚早， 但是，这根本不重要！我们关心的是如何写出好代码，而不是符合函数式编程风格的代码。 我们想象一下设计一个函数，输入一个字符串类型和布尔类型参数，输出一个整形参数。 int pos = 0;public Integer foo(String str, boolea flag)&#123; if(flag &amp;&amp; null != str)&#123; pos++; &#125; return pos;&#125; 这个例子有输入也有输出，同时每次调用也可能会更新外部的变量值，这样的函数我们称之为是有副作用的函数。 在函数式编程的上下文中，一个“函数”对应于一个数学函数：它接受零个或多个参数，生成一个或多个结果，并且不会有任何副作用。 你可以把它看成一个黑盒，它接收输入并产生一些输出，像下面的函数 public Integer foo(String str, boolea flag)&#123; if(flag &amp;&amp; null != str)&#123; return 1; &#125; return 0;&#125; 这种类型的函数和你在Java编程语言中见到的函数之间的区别是非常重要的（我们无法想象，log或者sin这样的数学函数会有副作用）。 尤其是，使用同样的参数调用数学函数，它所返回的结果一定是相同的。这里，我们暂时不考虑Random.nextInt这样的方法， 函数的副作用当谈论“函数式”时，我们想说的其实是“像数学函数那样——没有副作用”。由此，编程上的一些精妙问题随之而来。 我们的意思是，每个函数都只能使用函数和像if-then-else这样的数学思想来构建吗？ 或者，我们也允许函数内部执行一些非函数式的操作，只要这些操作的结果不会暴露给系统中的其他部分？ 换句话说，如果程序有一定的副作用，不过该副作用不会为其他的调用者感知，是否我们能假设这种副作用不存在呢？ 调用者不需要知道，或者完全不在意这些副作用，因为这对它完全没有影响。 当我们希望能界定这二者之间的区别时，我们将第一种称为纯粹的函数式编程，后者称为函数式编程。 在编程实战中我们很难用Java语言以纯粹的函数式来完成一个程序的，因为很多老的代码包括标准库的函数都是有副作用的 （调用Scanner.nextLine就有副作用，它会从一个文件中读取一行， 通常情况两次调用的结果完全不同）。你希望为你的系统 编写接近纯函数式的实现，需要确保你的代码没有副作用。假设这样一个函数或者方法，它没有副作用，进入方法体执行时会对一个字段的值加一， 退出方法体之前会对该字段减一。对一个单线程的程序而言，这个方法是没有副作用的，可以看作函数式的实现。 我们构建函数式的准则是，被称为“函数式”的函数或方法都只能修改局部变量，除此之外，它引用的对象都应该是final的。 所有的引用类型字段都指向不可变对象。","tags":[{"name":"Java8","slug":"Java8","permalink":"http://biezhi.me/tags/Java8/"},{"name":"函数式","slug":"函数式","permalink":"http://biezhi.me/tags/函数式/"}]},{"title":"跟上Java8 - Stream API快速入门","date":"2017-07-17T16:00:00.000Z","path":"2017/07/18/keep-up-with-java8-stream.html","text":"在前面我们简单介绍了lambda表达式，Java8旨在帮助程序员写出更好的代码， 其对核心类库的改进也是关键的一部分，Stream是Java8种处理集合的抽象概念， 它可以指定你希望对集合的操作，但是执行操作的时间交给具体实现来决定。 为什么需要Stream?Java语言中集合是使用最多的API，几乎每个Java程序都会用到集合操作， 这里的Stream和IO中的Stream不同，它提供了对集合操作的增强，极大的提高了操作集合对象的便利性。 集合对于大多数编程任务而言都是基本的，为了解释集合是怎么工作，我们想象一下当下最火的外卖APP， 当我们点菜的时候需要按照距离、价格、销量等进行排序后筛选出自己满意的菜品。 你可能想选择距离自己最近的一家店铺点菜，尽管用集合可以完成这件事，但集合的操作远远算不上完美。 假如让你编写上面示例中的代码，你可能会写出如下： // 店铺属性public class Property &#123; String name; // 距离，单位:米 Integer distance; // 销量，月售 Integer sales; // 价格，这里简单起见就写一个级别代表价格段 Integer priceLevel; public Property(String name, int distance, int sales, int priceLevel) &#123; this.name = name; this.distance = distance; this.sales = sales; this.priceLevel = priceLevel; &#125; // getter setter 省略&#125; 我想要筛选距离我最近的店铺，你可能会写下这样的代码： public static void main(String[] args) &#123; Property p1 = new Property(\"叫了个鸡\", 1000, 500, 2); Property p2 = new Property(\"张三丰饺子馆\", 2300, 1500, 3); Property p3 = new Property(\"永和大王\", 580, 3000, 1); Property p4 = new Property(\"肯德基\", 6000, 200, 4); List&lt;Property&gt; properties = Arrays.asList(p1, p2, p3, p4); Collections.sort(properties, (x, y) -&gt; x.distance.compareTo(y.distance)); String name = properties.get(0).name; System.out.println(\"距离我最近的店铺是:\" + name);&#125; 这里也使用了部分lambda表达式，在Java8之前你可能写的更痛苦一些。 要是要处理大量元素又该怎么办呢？为了提高性能，你需要并行处理，并利用多核架构。 但写并行代码比用迭代器还要复杂，而且调试起来也够受的！ 但Stream中操作这些东西当然是非常简单的，小试牛刀: // Stream操作String name2 = properties.stream() .sorted(Comparator.comparingInt(x -&gt; x.distance)) .findFirst() .get().name;System.out.println(\"距离我最近的店铺是:\" + name); 新的API对所有的集合操作都提供了生成流操作的方法，写的代码也行云流水，我们非常简单的就筛选了离我最近的店铺。 在后面我们继续讲解Stream更多的特性和玩法。 外部迭代和内部迭代当你处理集合时，通常会对它进行迭代，然后处理返回的每个元素。比如我想看看月销量大于1000的店铺个数。 使用for循环进行迭代int count = 0;for (Property property : properties) &#123; if(property.sales &gt; 1000)&#123; count++; &#125;&#125; 上面的操作是可行的，但是当每次迭代的时候你需要些很多重复的代码。将for循环修改为并行执行也非常困难， 需要修改每个for的实现。 从集合背后的原理来看，for循环封装了迭代的语法糖，首先调用iterator方法，产生一个Iterator对象， 然后控制整个迭代，这就是外部迭代。迭代的过程通过调用Iterator对象的hasNext和next方法完成。 使用迭代器进行计算int count = 0;Iterator&lt;Property&gt; iterator = properties.iterator();while(iterator.hasNext())&#123; Property property = iterator.next(); if(property.sales &gt; 1000)&#123; count++; &#125;&#125; 而迭代器也是有问题的。它很难抽象出未知的不能操作；此外它本质上还是串行化的操作，总体来看使用 for循环会将行为和方法混为一谈。 另一种办法是使用内部迭代完成，properties.stream()该方法返回一个Stream而不是迭代器。 使用内部迭代进行计算long count2 = properties.stream() .filter(p -&gt; p.sales &gt; 1000) .count(); 上述代码是通过Stream API完成的，我们可以把它理解为2个步骤： 找出所有销量大于1000的店铺 计算出店铺个数 为了找出销量大于1000的店铺，需要先做一次过滤：filter，你可以看看这个方法的入参就是前面讲到的Predicate断言型函数式接口， 测试一个函数完成后，返回值为boolean。 由于Stream API的风格，我们没有改变集合的内容，而是描述了Stream的内容，最终调用count()方法计算出Stream 里包含了多少个过滤之后的对象，返回值为long。 创建Stream你已经知道Java8种在Collection接口添加了Stream方法，可以将任何集合转换成一个Stream。 如果你操作的是一个数组可以使用Stream.of(1, 2, 3)方法将它转换为一个流。 也许有人知道JDK7中添加了一些类库如Files.readAllLines(Paths.get(&quot;/home/biezhi/a.txt&quot;))这样的读取文件行方法。 List作为Collection的子类拥有转换流的方法，那么我们读取这个文本文件到一个字符串变量中将变得更简洁： String content = Files.readAllLines(Paths.get(\"/home/biezhi/a.txt\")).stream() .collect(Collectors.joining(\"\\n\")); 这里的collect是后面要讲解的收集器，对Stream进行了处理后得到一个文本文件的内容。 JDK8也为我们提供了一些便捷的Stream相关类库: java8提供的Stream类库 创建一个流是很简单的，下面我们试试用创建好的Stream做一些操作吧。 流操作java.util.stream.Stream中定义了许多流操作的方法，为了更好的理解Stream API掌握它常用的操作非常重要。 流的操作其实可以分为两类：处理操作、聚合操作。 处理操作：诸如filter、map等处理操作将Stream一层一层的进行抽离，返回一个流给下一层使用。 聚合操作：从最后一次流中生成一个结果给调用方，foreach只做处理不做返回。 filterfilter看名字也知道是过滤的意思，我们通常在筛选数据的时候用到，频率非常高。 filter方法的参数是Predicate&lt;T&gt; predicate即一个从T到boolean的函数。 筛选出距离我在1000米内的店铺 properties.stream() .filter(p -&gt; p.distance &lt; 1000) 筛选出名称大于5个字的店铺 properties.stream() .filter(p -&gt; p.name.length() &gt; 5); map有时候我们需要将流中处理的数据类型进行转换，这时候就可以使用map方法来完成，将流中的值转换为一个新的流。 列出所有店铺的名称 properties.stream() .map(p -&gt; p.name); 传给map的lambda表达式接收一个Property类型的参数，返回一个String。 参数和返回值不必属于同一种类型，但是lambda表达式必须是Function接口的一个实例。 flatMap有时候我们会遇到提取子流的操作，这种情况用的不多但是遇到flatMap将变得更容易处理。 例如我们有一个List&lt;List&lt;String&gt;&gt;结构的数据： List&lt;List&lt;String&gt;&gt; lists = new ArrayList&lt;&gt;(); lists.add(Arrays.asList(\"apple\", \"click\")); lists.add(Arrays.asList(\"boss\", \"dig\", \"qq\", \"vivo\")); lists.add(Arrays.asList(\"c#\", \"biezhi\")); 要做的操作是获取这些数据中长度大于2的单词个数 lists.stream() .flatMap(Collection::stream) .filter(str -&gt; str.length() &gt; 2) .count(); 在不使用flatMap前你可能需要做2次for循环。这里调用了List的stream方法将每个列表转换成Stream对象， 其他的就和之前的操作一样。 max和minStream中常用的操作之一是求最大值和最小值，Stream API 中的max和min操作足以解决这一问题。 我们需要筛选出价格最低的店铺: Property property = properties.stream() .max(Comparator.comparingInt(p -&gt; p.priceLevel)) .get(); 查找Stream中的最大或最小元素，首先要考虑的是用什么作为排序的指标。 以查找价格最低的店铺为例，排序的指标就是店铺的价格等级。 为了让Stream对象按照价格等级进行排序，需要传给它一个Comparator对象。 Java8提供了一个新的静态方法comparingInt，使用它可以方便地实现一个比较器。 放在以前，我们需要比较两个对象的某项属性的值，现在只需要提供一个存取方法就够了。 收集结果通常我们处理完流之后想查看一下结果，比如获取总数，转换结果，在前面的示例中你发现调用了 filter、map之后没有下文了，后续的操作应该调用Stream中的collect方法完成。 获取距离我最近的2个店铺 List&lt;Property&gt; properties = properties.stream() .sorted(Comparator.comparingInt(x -&gt; x.distance)) .limit(2) .collect(Collectors.toList()); 获取所有店铺的名称 List&lt;String&gt; names = properties.stream() .map(p -&gt; p.name) .collect(Collectors.toList()); 获取每个店铺的价格等级 Map&lt;String, Integer&gt; map = properties.stream() .collect(Collectors.toMap(Property::getName, Property::getPriceLevel)); 所有价格等级的店铺列表 Map&lt;Integer, List&lt;Property&gt;&gt; priceMap = properties.stream() .collect(Collectors.groupingBy(Property::getPriceLevel)); 并行数据处理并行和并发并发是两个任务共享时间段，并行则是两个任务在同一时间发生，比如运行在多核CPU上。 如果一个程序要运行两个任务，并且只有一个CPU给它们分配了不同的时间片，那么这就是并发，而不是并行。 并行化是指为缩短任务执行时间，将一个任务分解成几部分，然后并行执行。 这和顺序执行的任务量是一样的，区别就像用更多的马来拉车，花费的时间自然减少了。 实际上，和顺序执行相比，并行化执行任务时，CPU承载的工作量更大。 数据并行化是指将数据分成块，为每块数据分配单独的处理单元。 还是拿马拉车那个例子打比方，就像从车里取出一些货物，放到另一辆车上，两辆马车都沿着同样的路径到达目的地。 当需要在大量数据上执行同样的操作时，数据并行化很管用。 它将问题分解为可在多块数据上求解的形式，然后对每块数据执行运算，最后将各数据块上得到的结果汇总，从而获得最终答案。 人们经常拿任务并行化和数据并行化做比较，在任务并行化中，线程不同，工作各异。 我们最常遇到的JavaEE应用容器便是任务并行化的例子之一，每个线程不光可以为不同用户服务， 还可以为同一个用户执行不同的任务，比如登录或往购物车添加商品。 Stream并行流流使得计算变得容易，它的操作也非常简单，但你需要遵守一些约定。默认情况下我们使用集合的stream方法 创建的是一个串行流，你有两种办法让他变成并行流。 调用Stream对象的parallel方法 创建流的时候调用parallelStream而不是stream方法 我们来用具体的例子来解释串行和并行流 串行化计算 筛选出价格等级小于4，按照距离排序的2个店铺名 properties.stream() .filter(p -&gt; p.priceLevel &lt; 4) .sorted(Comparator.comparingInt(Property::getDistance)) .map(Property::getName) .limit(2) .collect(Collectors.toList()); 调用 parallelStream 方法即能并行处理 properties.parallelStream() .filter(p -&gt; p.priceLevel &lt; 4) .sorted(Comparator.comparingInt(Property::getDistance)) .map(Property::getName) .limit(2) .collect(Collectors.toList()); 读到这里，大家的第一反应可能是立即将手头代码中的stream方法替换为parallelStream方法， 因为这样做简直太简单了！先别忙，为了将硬件物尽其用，利用好并行化非常重要，但流类库提供的数据并行化只是其中的一种形式。 我们先要问自己一个问题：并行化运行基于流的代码是否比串行化运行更快？这不是一个简单的问题。 回到前面的例子，哪种方式花的时间更多取决于串行或并行化运行时的环境。","tags":[{"name":"Java8","slug":"Java8","permalink":"http://biezhi.me/tags/Java8/"},{"name":"stream","slug":"stream","permalink":"http://biezhi.me/tags/stream/"},{"name":"flatmap","slug":"flatmap","permalink":"http://biezhi.me/tags/flatmap/"},{"name":"filter","slug":"filter","permalink":"http://biezhi.me/tags/filter/"},{"name":"collect","slug":"collect","permalink":"http://biezhi.me/tags/collect/"}]},{"title":"跟上Java8 - 了解lambda","date":"2017-07-16T16:00:00.000Z","path":"2017/07/17/keep-up-with-java8-lambda.html","text":"从java8出现以来lambda是最重要的特性之一，它可以让我们用简洁流畅的代码完成一个功能。 很长一段时间java被吐槽是冗余和缺乏函数式编程能力的语言，随着函数式编程的流行java8种也引入了 这种编程风格。在此之前我们都在写匿名内部类干这些事，但有时候这不是好的做法，本文中将介绍和使用lambda， 带你体验函数式编程的魔力。 lambda表达式 什么是lambda?lambda表达式是一段可以传递的代码，它的核心思想是将面向对象中的传递数据变成传递行为。 我们回顾一下在使用java8之前要做的事，之前我们编写一个线程时是这样的： Runnable r = new Runnable() &#123; @Override public void run() &#123; System.out.println(\"do something.\"); &#125;&#125; 也有人会写一个类去实现Runnable接口，这样做没有问题，我们注意这个接口中只有一个run方法， 当把Runnable对象给Thread对象作为构造参数时创建一个线程，运行后将输出do something.。 我们使用匿名内部类的方式实现了该方法。 这实际上是一个代码即数据的例子，在run方法中是线程要执行的一个任务，但上面的代码中任务内容已经被规定死了。 当我们有多个不同的任务时，需要重复编写如上代码。 设计匿名内部类的目的，就是为了方便 Java 程序员将代码作为数据传递。不过，匿名内部 类还是不够简便。 为了执行一个简单的任务逻辑，不得不加上 6 行冗繁的样板代码。那如果是lambda该怎么做? Runnable r = () -&gt; System.out.println(\"do something.\"); 嗯，这代码看起来很酷，你可以看到我们用()和-&gt;的方式完成了这件事，这是一个没有名字的函数，也没有人和参数，再简单不过了。 使用-&gt;将参数和实现逻辑分离，当运行这个线程的时候执行的是-&gt;之后的代码片段，且编译器帮助我们做了类型推导； 这个代码片段可以是用{}包含的一段逻辑。下面一起来学习一下lambda的语法。 基础语法在lambda中我们遵循如下的表达式来编写： expression = (variable) -&gt; action variable: 这是一个变量,一个占位符。像x,y,z,可以是多个变量。 action: 这里我称它为action, 这是我们实现的代码逻辑部分,它可以是一行代码也可以是一个代码片段 可以看到Java中lambda表达式的格式：参数、箭头、以及动作实现，当一个动作实现无法用一行代码完成，可以编写 一段代码用{}包裹起来。 lambda表达式可以包含多个参数,例如： int sum = (x, y) -&gt; x + y; 这时候我们应该思考这段代码不是之前的x和y数字相加，而是创建了一个函数，用来计算两个操作数的和。 后面用int类型进行接收，在lambda中为我们省略去了return。 函数式接口函数式接口是只有一个方法的接口，用作lambda表达式的类型。前面写的例子就是一个函数式接口，来看看jdk中的Runnable源码 @FunctionalInterfacepublic interface Runnable &#123; /** * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used * to create a thread, starting the thread causes the object's * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing * thread. * &lt;p&gt; * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run();&#125; 这里只有一个抽象方法run，实际上你不写public abstract也是可以的，在接口中定义的方法都是public abstract的。 同时也使用注解@FunctionalInterface告诉编译器这是一个函数式接口，当然你不这么写也可以，标识后明确了这个函数中 只有一个抽象方法，当你尝试在接口中编写多个方法的时候编译器将不允许这么干。 尝试函数式接口我们来编写一个函数式接口，输入一个年龄，判断这个人是否是成人。 public class FunctionInterfaceDemo &#123; @FunctionalInterface interface Predicate&lt;T&gt; &#123; boolean test(T t); &#125; /** * 执行Predicate判断 * * @param age 年龄 * @param predicate Predicate函数式接口 * @return 返回布尔类型结果 */ public static boolean doPredicate(int age, Predicate&lt;Integer&gt; predicate) &#123; return predicate.test(age); &#125; public static void main(String[] args) &#123; boolean isAdult = doPredicate(20, x -&gt; x &gt;= 18); System.out.println(isAdult); &#125;&#125; 从这个例子我们很轻松的完成 是否是成人 的动作，其次判断是否是成人，在此之前我们的做法一般是编写一个 判断是否是成人的方法，是无法将 判断 共用的。而在本例只，你要做的是将 行为 (判断是否是成人，或者是判断是否大于30岁) 传递进去，函数式接口告诉你结果是什么。 实际上诸如上述例子中的接口，伟大的jdk设计者为我们准备了java.util.function包 我们前面写的Predicate函数式接口也是JDK种的一个实现，他们大致分为以下几类： 接口 参数 返回值 类别 示例 Consumer T void 消费型接口 输出一个值 Supplier None T 供给型接口 工厂方法 Function T R 函数型接口 获得 Artist 对象的名字 Predicate T boolean 断言型接口 这张唱片已经发行了吗 消费型接口示例 public static void donation(Integer money, Consumer&lt;Integer&gt; consumer)&#123; consumer.accept(money); &#125;public static void main(String[] args) &#123; donation(1000, money -&gt; System.out.println(\"好心的麦乐迪为Blade捐赠了\"+money+\"元\")) ;&#125; 供给型接口示例 public static List&lt;Integer&gt; supply(Integer num, Supplier&lt;Integer&gt; supplier)&#123; List&lt;Integer&gt; resultList = new ArrayList&lt;Integer&gt;() ; for(int x=0;x&lt;num;x++) resultList.add(supplier.get()); return resultList ;&#125;public static void main(String[] args) &#123; List&lt;Integer&gt; list = supply(10,() -&gt; (int)(Math.random()*100)); list.forEach(System.out::println);&#125; 函数型接口示例 转换字符串为Integer public static Integer convert(String str, Function&lt;String, Integer&gt; function) &#123; return function.apply(str);&#125;public static void main(String[] args) &#123; Integer value = convert(\"28\", x -&gt; Integer.parseInt(x));&#125; 断言型接口示例 筛选出只有2个字的水果 public static List&lt;String&gt; filter(List&lt;String&gt; fruit, Predicate&lt;String&gt; predicate)&#123; List&lt;String&gt; f = new ArrayList&lt;&gt;(); for (String s : fruit) &#123; if(predicate.test(s))&#123; f.add(s); &#125; &#125; return f;&#125;public static void main(String[] args) &#123; List&lt;String&gt; fruit = Arrays.asList(\"香蕉\", \"哈密瓜\", \"榴莲\", \"火龙果\", \"水蜜桃\"); List&lt;String&gt; newFruit = filter(fruit, (f) -&gt; f.length() == 2); System.out.println(newFruit);&#125; 默认方法在Java语言中，一个接口中定义的方法必须由实现类提供实现。但是当接口中加入新的API时， 实现类按照约定也要修改实现，而Java8的API对现有接口也添加了很多方法，比如List接口中添加了sort方法。 如果按照之前的做法，那么所有的实现类都要实现sort方法，JDK的编写者们一定非常抓狂。 幸运的是我们使用了Java8，这一问题将得到很好的解决，在Java8种引入新的机制，支持在接口中声明方法同时提供实现。 这令人激动不已，你有两种方式完成 1.在接口内声明静态方法 2.指定一个默认方法。 我们来看看在JDK8中上述List接口添加方法的问题是如何解决的 default void sort(Comparator&lt;? super E&gt; c) &#123; Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator&lt;E&gt; i = this.listIterator(); for (Object e : a) &#123; i.next(); i.set((E) e); &#125;&#125; 翻阅List接口的源码，其中加入一个默认方法default void sort(Comparator&lt;? super E&gt; c)。 在返回值之前加入default关键字，有了这个方法我们可以直接调用sort方法进行排序。 List&lt;Integer&gt; list = Arrays.asList(2, 7, 3, 1, 8, 6, 4);list.sort(Comparator.naturalOrder());System.out.println(list); Comparator.naturalOrder()是一个自然排序的实现，这里可以自定义排序方案。 你经常看到使用Java8操作集合的时候可以直接foreach的原因也是在Iterable接口中也新增了一个默认方法：forEach ， 该方法功能和 for 循环类似，但是允许 用户使用一个Lambda表达式作为循环体。 在后面的章节中我们再次通过案例来展示函数式编程的魅力 :)","tags":[{"name":"Java8","slug":"Java8","permalink":"http://biezhi.me/tags/Java8/"},{"name":"lambda","slug":"lambda","permalink":"http://biezhi.me/tags/lambda/"},{"name":"functional-interface","slug":"functional-interface","permalink":"http://biezhi.me/tags/functional-interface/"}]},{"title":"跟上Java8系列文章 - 带你实战Java8","date":"2017-07-15T16:00:00.000Z","path":"2017/07/16/keep-up-with-java8.html","text":"Java8从2014年出现至今已经三年有余，这里发布的新功能是自Java1.0发布18年来最大变化的。 没有去处任何API，我们仍然能兼容以前的代码，新功能中提供了更多的语法和设计，帮助开发者编写更清楚、简洁的代码。 Java8把函数式编程里一些最好的思想融入到大家熟知的Java语法中，让你用更少的时间写出高效代码。 开启Java8之路 而目前国内很多开发者的现状还处于Java6的语法之上，这确实没什么问题，可以保证你的企业软件稳定运行下去。 但时代总是变化的，我们熟悉的Spring框架也对java8做了更好的支持。 大势所趋，为何不跟上Java8的节奏一起体验现代高级编程语言中的新特性呢？ 现在我可以带你深入浅出跟上Java8，这一系列文章写了那些我认为有用所关注的一些内容，如果你对更详细的细节感兴趣可以查阅相关书籍。 优势 代码行更少 lambda表达式 Stream API 便于并行 减少空指针 jvm优化 兼容老版本 文章目录 跟上Java8 - 了解lambda 跟上Java8 - Stream API快速入门 跟上Java8 - 函数式编程 跟上Java8 - 日期和时间实用技巧 跟上Java8 - 你忽略了的新特性 跟上Java8 - 使用Java8进行并发编程 跟上Java8 - 七七八八的黑科技 跟上Java8 - 优化工作中那些屎代码 跟上Java8 - 复杂一点的例子 资料分享 在线查看Java8新增API java8-the-missing-tutorial java8-tutorial","tags":[{"name":"Java8","slug":"Java8","permalink":"http://biezhi.me/tags/Java8/"},{"name":"lambda","slug":"lambda","permalink":"http://biezhi.me/tags/lambda/"},{"name":"系列","slug":"系列","permalink":"http://biezhi.me/tags/系列/"},{"name":"stream-api","slug":"stream-api","permalink":"http://biezhi.me/tags/stream-api/"}]},{"title":"Hello World","date":"2017-07-14T16:00:00.000Z","path":"2017/07/15/hello-world.html","text":"博客换了主题，以前的文章在github的分支上保存，以后在这里重新写点东西。","tags":[{"name":"blog","slug":"blog","permalink":"http://biezhi.me/tags/blog/"},{"name":"hello-world","slug":"hello-world","permalink":"http://biezhi.me/tags/hello-world/"}]}]