<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王爵的技术博客</title>
  <subtitle>一个后端程序员的笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://biezhi.me/"/>
  <updated>2017-07-19T16:57:44.000Z</updated>
  <id>http://biezhi.me/</id>
  
  <author>
    <name>王爵nice</name>
    <email>biezhi.me@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>跟上Java8 - 函数式编程</title>
    <link href="http://biezhi.me/2017/07/19/keep-up-with-java8-functional-programming.html"/>
    <id>http://biezhi.me/2017/07/19/keep-up-with-java8-functional-programming.html</id>
    <published>2017-07-18T16:00:00.000Z</published>
    <updated>2017-07-19T16:57:44.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/java8-function-programing.jpg" alt="函数式编程" width="600" height="400" title="">
                </div>
                <div class="image-caption">函数式编程</div>
            </figure>
<p>在前面的章节我们快速学习了<code>lambda</code>和<code>Stream</code>，本章节中我们来回顾和理解函数式编程的思想。
我们不断的提及<code>函数式</code>这个名词，它指的是lambda吗？如果是这样，采用函数式编程能为你带来什么好处呢?</p>
<a id="more"></a>
<h2 id="函数式的思考"><a href="#函数式的思考" class="headerlink" title="函数式的思考"></a>函数式的思考</h2><h3 id="命令式编程"><a href="#命令式编程" class="headerlink" title="命令式编程"></a>命令式编程</h3><p>一般我们实现一个系统有两种思考方式，一种专注于如何实现，比如下厨做菜，通常按照自己熟悉的烹饪方法：首先洗菜，
然后切菜，热油，下菜，然后…… 这看起来像是一系列的命令合集。对于这种”如何做”式的编程风格我们称之为<strong>命令式编程</strong>，
它的特点非常像工厂的流水线、计算机的指令处理，都是串行化、命令式的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">CookingTask cookingTask = <span class="keyword">new</span> CookingTask();</div><div class="line">cookingTask.wash();</div><div class="line">cookingTask.cut();</div><div class="line">cookingTask.deepFry();</div><div class="line">cookingTask.fried();</div><div class="line">...</div></pre></td></tr></table></figure>
<h3 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h3><p>还有一种方式你关注的是要做什么，我们如果用<code>lambda</code>和函数式来解决上述问题应该是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookingDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">(String material, Consumer&lt;String&gt; consumer)</span> </span>&#123;</div><div class="line">        consumer.accept(material);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        CookingDemo cookingDemo = <span class="keyword">new</span> CookingDemo();</div><div class="line">        cookingDemo.doTask(<span class="string">"蔬菜"</span>, material -&gt; System.out.println(<span class="string">"清洗"</span> + material));</div><div class="line">        cookingDemo.doTask(<span class="string">"蔬菜"</span>, material -&gt; System.out.println(material + <span class="string">"切片"</span>));</div><div class="line">        cookingDemo.doTask(<span class="string">"食用油"</span>, material -&gt; System.out.println(material + <span class="string">"烧热"</span>));</div><div class="line">        cookingDemo.doTask(<span class="string">""</span>, material -&gt; System.out.println(<span class="string">"炒菜"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们将烹饪的实现细节交给了函数库，它最大的优势在于你读起来就像是在问题陈述，采用这种方式我们很快可以理解它的功能，
当你在烹饪流程中添加其他步骤也变得非常简单，你只需要调用<code>doTask</code>方法将材料传递进去处理，比如在食用油烧热前我要打个鸡蛋</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">cookingDemo.doTask(<span class="string">"鸡蛋"</span>, material -&gt; System.out.println(material + <span class="string">"打碎搅拌均匀"</span>));</div></pre></td></tr></table></figure>
<p>而不用再编写一个处理鸡蛋的方法。</p>
<h2 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h2><p>对于“什么是函数式编程”这一问题最简化的回答是“它是一种使用函数进行编程的方式”。
每个人的理解都是不同的，其核心是：<strong>在思考问题时，使用不可变值和函数，函数对一个值进行处理，映射成另一个值。</strong></p>
<p>不同的语言社区往往对各自语言中的特性孤芳自赏。现在谈Java程序员如何定义函数式编程还为时尚早，
但是，这根本不重要！我们关心的是如何写出好代码，而不是符合函数式编程风格的代码。</p>
<p>我们想象一下设计一个函数，输入一个字符串类型和布尔类型参数，输出一个整形参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">foo</span><span class="params">(String str, boolea flag)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(flag &amp;&amp; <span class="keyword">null</span> != str)&#123;</div><div class="line">        pos++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> pos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子有输入也有输出，同时每次调用也可能会更行外部的变量值，这样的函数我们称之为是有<strong>副作用</strong>的函数。</p>
<p>在函数式编程的上下文中，一个“函数”对应于一个数学函数：它接受零个或多个参数，生成一个或多个结果，并且不会有任何副作用。
你可以把它看成一个黑盒，它接收输入并产生一些输出，像下面的函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">foo</span><span class="params">(String str, boolea flag)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(flag &amp;&amp; <span class="keyword">null</span> != str)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种类型的函数和你在Java编程语言中见到的函数之间的区别是非常重要的（我们无法想象，log或者sin这样的数学函数会有副作用）。
尤其是，使用同样的参数调用数学函数，它所返回的结果一定是相同的。这里，我们暂时不考虑<code>Random.nextInt</code>这样的方法，</p>
<h2 id="函数的副作用"><a href="#函数的副作用" class="headerlink" title="函数的副作用"></a>函数的副作用</h2><p>当谈论“函数式”时，我们想说的其实是“像数学函数那样——没有副作用”。由此，编程上的一些精妙问题随之而来。
我们的意思是，每个函数都只能使用函数和像<code>if-then-else</code>这样的数学思想来构建吗？
或者，我们也允许函数内部执行一些非函数式的操作，只要这些操作的结果不会暴露给系统中的其他部分？
换句话说，如果程序有一定的副作用，不过该副作用不会为其他的调用者感知，是否我们能假设这种副作用不存在呢？
调用者不需要知道，或者完全不在意这些副作用，因为这对它完全没有影响。</p>
<p>当我们希望能界定这二者之间的区别时，我们将第一种称为纯粹的函数式编程，后者称为函数式编程。</p>
<p>在编程实战中我们很难用Java语言以纯粹的函数式来完成一个程序的，因为很多老的代码包括标准库的函数都是有副作用的
（调用<code>Scanner.nextLine</code>就有副作用，它会从一个文件中读取一行， 通常情况两次调用的结果完全不同）。你希望为你的系统
编写接近纯函数式的实现，需要确保你的代码没有副作用。假设这样一个函数或者方法，它没有副作用，进入方法体执行时会对一个字段的值加一，
退出方法体之前会对该字段减一。对一个单线程的程序而言，这个方法是没有副作用的，可以看作函数式的实现。</p>
<p>我们构建函数式的准则是，被称为“函数式”的函数或方法都只能修改局部变量，除此之外，它引用的对象都应该是<code>final</code>的。
所有的引用类型字段都指向不可变对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;/static/img/article/java8-function-programing.jpg&quot; alt=&quot;函数式编程&quot; width=&quot;600&quot; height=&quot;400&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;函数式编程&lt;/div&gt;
            &lt;/figure&gt;
&lt;p&gt;在前面的章节我们快速学习了&lt;code&gt;lambda&lt;/code&gt;和&lt;code&gt;Stream&lt;/code&gt;，本章节中我们来回顾和理解函数式编程的思想。
我们不断的提及&lt;code&gt;函数式&lt;/code&gt;这个名词，它指的是lambda吗？如果是这样，采用函数式编程能为你带来什么好处呢?&lt;/p&gt;
    
    </summary>
    
      <category term="跟上Java8" scheme="http://biezhi.me/categories/%E8%B7%9F%E4%B8%8AJava8/"/>
    
    
      <category term="Java8" scheme="http://biezhi.me/tags/Java8/"/>
    
      <category term="函数式" scheme="http://biezhi.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>跟上Java8 - Stream API快速入门</title>
    <link href="http://biezhi.me/2017/07/18/keep-up-with-java8-stream.html"/>
    <id>http://biezhi.me/2017/07/18/keep-up-with-java8-stream.html</id>
    <published>2017-07-17T16:00:00.000Z</published>
    <updated>2017-07-19T11:46:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前面我们简单介绍了<code>lambda</code>表达式，Java8旨在帮助程序员写出更好的代码，
其对核心类库的改进也是关键的一部分，<code>Stream</code>是Java8种处理集合的抽象概念，
它可以指定你希望对集合的操作，但是执行操作的时间交给具体实现来决定。</p>
<a id="more"></a>
<h2 id="为什么需要Stream"><a href="#为什么需要Stream" class="headerlink" title="为什么需要Stream?"></a>为什么需要Stream?</h2><p>Java语言中集合是使用最多的API，几乎每个Java程序都会用到集合操作，
这里的Stream和IO中的Stream不同，它提供了对集合操作的增强，极大的提高了操作集合对象的便利性。</p>
<p>集合对于大多数编程任务而言都是基本的，为了解释集合是怎么工作，我们想象一下当下最火的外卖APP，
当我们点菜的时候需要按照<strong>距离</strong>、<strong>价格</strong>、<strong>销量</strong>等进行排序后筛选出自己满意的菜品。
你可能想选择距离自己最近的一家店铺点菜，尽管用集合可以完成这件事，但集合的操作远远算不上完美。</p>
<p>假如让你编写上面示例中的代码，你可能会写出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 店铺属性</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Property</span> </span>&#123;</div><div class="line">    String  name;</div><div class="line">    <span class="comment">// 距离，单位:米</span></div><div class="line">    Integer distance;</div><div class="line">    <span class="comment">// 销量，月售</span></div><div class="line">    Integer sales;</div><div class="line">    <span class="comment">// 价格，这里简单起见就写一个级别代表价格段</span></div><div class="line">    Integer priceLevel;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Property</span><span class="params">(String name, <span class="keyword">int</span> distance, <span class="keyword">int</span> sales, <span class="keyword">int</span> priceLevel)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.distance = distance;</div><div class="line">        <span class="keyword">this</span>.sales = sales;</div><div class="line">        <span class="keyword">this</span>.priceLevel = priceLevel;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// getter setter 省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我想要筛选距离我最近的店铺，你可能会写下这样的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Property p1 = <span class="keyword">new</span> Property(<span class="string">"叫了个鸡"</span>, <span class="number">1000</span>, <span class="number">500</span>, <span class="number">2</span>);</div><div class="line">    Property p2 = <span class="keyword">new</span> Property(<span class="string">"张三丰饺子馆"</span>, <span class="number">2300</span>, <span class="number">1500</span>, <span class="number">3</span>);</div><div class="line">    Property p3 = <span class="keyword">new</span> Property(<span class="string">"永和大王"</span>, <span class="number">580</span>, <span class="number">3000</span>, <span class="number">1</span>);</div><div class="line">    Property p4 = <span class="keyword">new</span> Property(<span class="string">"肯德基"</span>, <span class="number">6000</span>, <span class="number">200</span>, <span class="number">4</span>);</div><div class="line"></div><div class="line">    List&lt;Property&gt; properties = Arrays.asList(p1, p2, p3, p4);</div><div class="line"></div><div class="line">    Collections.sort(properties, (x, y) -&gt; x.distance.compareTo(y.distance));</div><div class="line"></div><div class="line">    String name = properties.get(<span class="number">0</span>).name;</div><div class="line">    System.out.println(<span class="string">"距离我最近的店铺是:"</span> + name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里也使用了部分<code>lambda</code>表达式，在Java8之前你可能写的更痛苦一些。
要是要处理大量元素又该怎么办呢？为了提高性能，你需要并行处理，并利用多核架构。
但写并行代码比用迭代器还要复杂，而且调试起来也够受的！</p>
<p>但<code>Stream</code>中操作这些东西当然是非常简单的，小试牛刀:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Stream操作</span></div><div class="line">String name2 = properties.stream()</div><div class="line">                .sorted(Comparator.comparingInt(x -&gt; x.distance))</div><div class="line">                .findFirst()</div><div class="line">                .get().name;</div><div class="line">System.out.println(<span class="string">"距离我最近的店铺是:"</span> + name);</div></pre></td></tr></table></figure>
<p>新的API对所有的集合操作都提供了生成流操作的方法，写的代码也行云流水，我们非常简单的就筛选了离我最近的店铺。
在后面我们继续讲解<code>Stream</code>更多的特性和玩法。</p>
<h2 id="外部迭代和内部迭代"><a href="#外部迭代和内部迭代" class="headerlink" title="外部迭代和内部迭代"></a>外部迭代和内部迭代</h2><p>当你处理集合时，通常会对它进行迭代，然后处理返回的每个元素。比如我想看看月销量大于1000的店铺个数。</p>
<h3 id="使用for循环进行迭代"><a href="#使用for循环进行迭代" class="headerlink" title="使用for循环进行迭代"></a>使用for循环进行迭代</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (Property property : properties) &#123;</div><div class="line">    <span class="keyword">if</span>(property.sales &gt; <span class="number">1000</span>)&#123;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的操作是可行的，但是当每次迭代的时候你需要些很多重复的代码。将<code>for</code>循环修改为并行执行也非常困难，
需要修改每个<code>for</code>的实现。</p>
<p>从集合背后的原理来看，<code>for</code>循环封装了迭代的语法糖，首先调用<code>iterator</code>方法，产生一个<code>Iterator</code>对象，
然后控制整个迭代，这就是<strong>外部迭代</strong>。迭代的过程通过调用<code>Iterator</code>对象的<code>hasNext</code>和<code>next</code>方法完成。</p>
<h3 id="使用迭代器进行计算"><a href="#使用迭代器进行计算" class="headerlink" title="使用迭代器进行计算"></a>使用迭代器进行计算</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">Iterator&lt;Property&gt; iterator = properties.iterator();</div><div class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</div><div class="line">    Property property = iterator.next();</div><div class="line">    <span class="keyword">if</span>(property.sales &gt; <span class="number">1000</span>)&#123;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而迭代器也是有问题的。它很难抽象出<strong>未知的不能操作</strong>；此外它本质上还是串行化的操作，总体来看使用
<code>for</code>循环会将行为和方法混为一谈。</p>
<p>另一种办法是使用内部迭代完成，<code>properties.stream()</code>该方法返回一个<code>Stream</code>而不是迭代器。</p>
<h3 id="使用内部迭代进行计算"><a href="#使用内部迭代进行计算" class="headerlink" title="使用内部迭代进行计算"></a>使用内部迭代进行计算</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">long</span> count2 = properties.stream()</div><div class="line">                .filter(p -&gt; p.sales &gt; <span class="number">1000</span>)</div><div class="line">                .count();</div></pre></td></tr></table></figure>
<p>上述代码是通过<code>Stream API</code>完成的，我们可以把它理解为2个步骤：</p>
<ol>
<li>找出所有销量大于1000的店铺</li>
<li>计算出店铺个数</li>
</ol>
<p>为了找出销量大于1000的店铺，需要先做一次过滤：<code>filter</code>，你可以看看这个方法的入参就是前面讲到的<code>Predicate</code>断言型函数式接口，
测试一个函数完成后，返回值为<code>boolean</code>。
由于<code>Stream API</code>的风格，我们没有改变集合的内容，而是描述了<code>Stream</code>的内容，最终调用<code>count()</code>方法计算出<code>Stream</code>
里包含了多少个过滤之后的对象，返回值为<code>long</code>。</p>
<h2 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h2><p>你已经知道Java8种在<code>Collection</code>接口添加了<code>Stream</code>方法，可以将任何集合转换成一个<code>Stream</code>。
如果你操作的是一个数组可以使用<code>Stream.of(1, 2, 3)</code>方法将它转换为一个流。</p>
<p>也许有人知道JDK7中添加了一些类库如<code>Files.readAllLines(Paths.get(&quot;/home/biezhi/a.txt&quot;))</code>这样的读取文件行方法。
<code>List</code>作为<code>Collection</code>的子类拥有转换流的方法，那么我们读取这个文本文件到一个字符串变量中将变得更简洁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String content = Files.readAllLines(Paths.get(<span class="string">"/home/biezhi/a.txt"</span>)).stream()</div><div class="line">            .collect(Collectors.joining(<span class="string">"\n"</span>));</div></pre></td></tr></table></figure>
<p>这里的<code>collect</code>是后面要讲解的<strong>收集器</strong>，对<code>Stream</code>进行了处理后得到一个文本文件的内容。</p>
<p>JDK8也为我们提供了一些便捷的<code>Stream</code>相关类库:</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/java8-stream-class.png" alt="java8提供的Stream类库" width="320" height="500" title="">
                </div>
                <div class="image-caption">java8提供的Stream类库</div>
            </figure>
<p>创建一个流是很简单的，下面我们试试用创建好的<code>Stream</code>做一些操作吧。</p>
<h2 id="流操作"><a href="#流操作" class="headerlink" title="流操作"></a>流操作</h2><p><code>java.util.stream.Stream</code>中定义了许多流操作的方法，为了更好的理解<code>Stream API</code>掌握它常用的操作非常重要。
流的操作其实可以分为两类：<strong>处理操作</strong>、<strong>聚合操作</strong>。</p>
<ul>
<li>处理操作：诸如<code>filter</code>、<code>map</code>等处理操作将<code>Stream</code>一层一层的进行抽离，返回一个流给下一层使用。</li>
<li>聚合操作：从最后一次流中生成一个结果给调用方，<code>foreach</code>只做处理不做返回。</li>
</ul>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><code>filter</code>看名字也知道是过滤的意思，我们通常在筛选数据的时候用到，频率非常高。
<code>filter</code>方法的参数是<code>Predicate&lt;T&gt; predicate</code>即一个从<code>T</code>到boolean的函数。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/java8-filter.png" alt="" width="300" height="200" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>筛选出距离我在1000米内的店铺</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">properties.stream()</div><div class="line">            .filter(p -&gt; p.distance &lt; <span class="number">1000</span>)</div></pre></td></tr></table></figure>
<p><strong>筛选出名称大于5个字的店铺</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">properties.stream()</div><div class="line">            .filter(p -&gt; p.name.length() &gt; <span class="number">5</span>);</div></pre></td></tr></table></figure>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>有时候我们需要将流中处理的数据类型进行转换，这时候就可以使用<code>map</code>方法来完成，将流中的值转换为一个新的流。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/java8-map.png" alt="" width="300" height="200" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>列出所有店铺的名称</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">properties.stream()</div><div class="line">            .map(p -&gt; p.name);</div></pre></td></tr></table></figure>
<p>传给<code>map</code>的<code>lambda</code>表达式接收一个<code>Property</code>类型的参数，返回一个<code>String</code>。
参数和返回值不必属于同一种类型，但是<code>lambda</code>表达式必须是<code>Function</code>接口的一个实例。</p>
<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>有时候我们会遇到提取子流的操作，这种情况用的不多但是遇到<code>flatMap</code>将变得更容易处理。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/java8-flatmap.png" alt="" width="300" height="200" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>例如我们有一个<code>List&lt;List&lt;String&gt;&gt;</code>结构的数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">List&lt;List&lt;String&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        lists.add(Arrays.asList(<span class="string">"apple"</span>, <span class="string">"click"</span>));</div><div class="line">        lists.add(Arrays.asList(<span class="string">"boss"</span>, <span class="string">"dig"</span>, <span class="string">"qq"</span>, <span class="string">"vivo"</span>));</div><div class="line">        lists.add(Arrays.asList(<span class="string">"c#"</span>, <span class="string">"biezhi"</span>));</div></pre></td></tr></table></figure>
<p>要做的操作是获取这些数据中长度大于2的单词个数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">lists.stream()</div><div class="line">        .flatMap(Collection::stream)</div><div class="line">        .filter(str -&gt; str.length() &gt; <span class="number">2</span>)</div><div class="line">        .count();</div></pre></td></tr></table></figure>
<p>在不使用<code>flatMap</code>前你可能需要做2次<code>for</code>循环。这里调用了<code>List</code>的<code>stream</code>方法将每个列表转换成<code>Stream</code>对象，
其他的就和之前的操作一样。</p>
<h2 id="max和min"><a href="#max和min" class="headerlink" title="max和min"></a>max和min</h2><p><code>Stream</code>中常用的操作之一是求最大值和最小值，<code>Stream API</code> 中的<code>max</code>和<code>min</code>操作足以解决这一问题。</p>
<p>我们需要筛选出价格最低的店铺:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Property property = properties.stream()</div><div class="line">            .max(Comparator.comparingInt(p -&gt; p.priceLevel))</div><div class="line">            .get();</div></pre></td></tr></table></figure>
<p>查找<code>Stream</code>中的最大或最小元素，首先要考虑的是用什么作为排序的指标。
以查找价格最低的店铺为例，排序的指标就是<strong>店铺的价格等级</strong>。</p>
<p>为了让<code>Stream</code>对象按照价格等级进行排序，需要传给它一个<code>Comparator</code>对象。
Java8提供了一个新的静态方法<code>comparingInt</code>，使用它可以方便地实现一个比较器。
放在以前，我们需要比较两个对象的某项属性的值，现在只需要提供一个存取方法就够了。</p>
<h2 id="收集结果"><a href="#收集结果" class="headerlink" title="收集结果"></a>收集结果</h2><p>通常我们处理完流之后想查看一下结果，比如获取总数，转换结果，在前面的示例中你发现调用了
<code>filter</code>、<code>map</code>之后没有下文了，后续的操作应该调用<code>Stream</code>中的<code>collect</code>方法完成。</p>
<p><strong>获取距离我最近的2个店铺</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">List&lt;Property&gt; properties = properties.stream()</div><div class="line">            .sorted(Comparator.comparingInt(x -&gt; x.distance))</div><div class="line">            .limit(<span class="number">2</span>)</div><div class="line">            .collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p><strong>获取所有店铺的名称</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">List&lt;String&gt; names = properties.stream()</div><div class="line">                      .map(p -&gt; p.name)</div><div class="line">                      .collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p><strong>获取每个店铺的价格等级</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Map&lt;String, Integer&gt; map = properties.stream()</div><div class="line">        .collect(Collectors.toMap(Property::getName, Property::getPriceLevel));</div></pre></td></tr></table></figure>
<p><strong>所有价格等级的店铺列表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Map&lt;Integer, List&lt;Property&gt;&gt; priceMap = properties.stream()</div><div class="line">                .collect(Collectors.groupingBy(Property::getPriceLevel));</div></pre></td></tr></table></figure>
<h2 id="并行数据处理"><a href="#并行数据处理" class="headerlink" title="并行数据处理"></a>并行数据处理</h2><h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><p>并发是两个任务共享时间段，并行则是两个任务在同一时间发生，比如运行在多核CPU上。
如果一个程序要运行两个任务，并且只有一个CPU给它们分配了不同的时间片，那么这就是并发，而不是并行。</p>
<blockquote>
<p>并行化是指为缩短任务执行时间，将一个任务分解成几部分，然后并行执行。</p>
</blockquote>
<p>这和顺序执行的任务量是一样的，区别就像用更多的马来拉车，花费的时间自然减少了。
实际上，和顺序执行相比，并行化执行任务时，CPU承载的工作量更大。</p>
<blockquote>
<p>数据并行化是指将数据分成块，为每块数据分配单独的处理单元。</p>
</blockquote>
<p>还是拿马拉车那个例子打比方，就像从车里取出一些货物，放到另一辆车上，两辆马车都沿着同样的路径到达目的地。</p>
<p>当需要在大量数据上执行同样的操作时，数据并行化很管用。
它将问题分解为可在多块数据上求解的形式，然后对每块数据执行运算，最后将各数据块上得到的结果汇总，从而获得最终答案。</p>
<p>人们经常拿任务并行化和数据并行化做比较，在任务并行化中，线程不同，工作各异。
我们最常遇到的JavaEE应用容器便是任务并行化的例子之一，每个线程不光可以为不同用户服务，
还可以为同一个用户执行不同的任务，比如登录或往购物车添加商品。</p>
<h3 id="Stream并行流"><a href="#Stream并行流" class="headerlink" title="Stream并行流"></a>Stream并行流</h3><p>流使得计算变得容易，它的操作也非常简单，但你需要遵守一些约定。默认情况下我们使用集合的<code>stream</code>方法
创建的是一个串行流，你有两种办法让他变成并行流。</p>
<ol>
<li>调用<code>Stream</code>对象的<code>parallel</code>方法</li>
<li>创建流的时候调用<code>parallelStream</code>而不是<code>stream</code>方法</li>
</ol>
<p>我们来用具体的例子来解释串行和并行流</p>
<p><strong>串行化计算</strong></p>
<p>筛选出价格等级小于4，按照距离排序的2个店铺名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">properties.stream()</div><div class="line">            .filter(p -&gt; p.priceLevel &lt; <span class="number">4</span>)</div><div class="line">            .sorted(Comparator.comparingInt(Property::getDistance))</div><div class="line">            .map(Property::getName)</div><div class="line">            .limit(<span class="number">2</span>)</div><div class="line">            .collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p>调用 parallelStream 方法即能并行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">properties.parallelStream()</div><div class="line">            .filter(p -&gt; p.priceLevel &lt; <span class="number">4</span>)</div><div class="line">            .sorted(Comparator.comparingInt(Property::getDistance))</div><div class="line">            .map(Property::getName)</div><div class="line">            .limit(<span class="number">2</span>)</div><div class="line">            .collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p>读到这里，大家的第一反应可能是立即将手头代码中的<code>stream</code>方法替换为<code>parallelStream</code>方法，
因为这样做简直太简单了！先别忙，为了将硬件物尽其用，利用好并行化非常重要，但流类库提供的数据并行化只是其中的一种形式。</p>
<p>我们先要问自己一个问题：<code>并行化运行基于流的代码是否比串行化运行更快？</code>这不是一个简单的问题。
回到前面的例子，哪种方式花的时间更多取决于串行或并行化运行时的环境。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面我们简单介绍了&lt;code&gt;lambda&lt;/code&gt;表达式，Java8旨在帮助程序员写出更好的代码，
其对核心类库的改进也是关键的一部分，&lt;code&gt;Stream&lt;/code&gt;是Java8种处理集合的抽象概念，
它可以指定你希望对集合的操作，但是执行操作的时间交给具体实现来决定。&lt;/p&gt;
    
    </summary>
    
      <category term="跟上Java8" scheme="http://biezhi.me/categories/%E8%B7%9F%E4%B8%8AJava8/"/>
    
    
      <category term="Java8" scheme="http://biezhi.me/tags/Java8/"/>
    
      <category term="stream" scheme="http://biezhi.me/tags/stream/"/>
    
      <category term="flatmap" scheme="http://biezhi.me/tags/flatmap/"/>
    
      <category term="filter" scheme="http://biezhi.me/tags/filter/"/>
    
      <category term="collect" scheme="http://biezhi.me/tags/collect/"/>
    
  </entry>
  
  <entry>
    <title>跟上Java8 - 了解lambda</title>
    <link href="http://biezhi.me/2017/07/17/keep-up-with-java8-lambda.html"/>
    <id>http://biezhi.me/2017/07/17/keep-up-with-java8-lambda.html</id>
    <published>2017-07-16T16:00:00.000Z</published>
    <updated>2017-07-19T11:38:38.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/lambda-expression.png" alt="lambda表达式" width="500" height="180" title="">
                </div>
                <div class="image-caption">lambda表达式</div>
            </figure>
<p>从<code>java8</code>出现以来<code>lambda</code>是最重要的特性之一，它可以让我们用简洁流畅的代码完成一个功能。
很长一段时间<code>java</code>被吐槽是冗余和缺乏函数式编程能力的语言，随着函数式编程的流行<code>java8</code>种也引入了
这种编程风格。在此之前我们都在写匿名内部类干这些事，但有时候这不是好的做法，本文中将介绍和使用<code>lambda</code>，
带你体验函数式编程的魔力。</p>
<a id="more"></a>
<h2 id="什么是lambda"><a href="#什么是lambda" class="headerlink" title="什么是lambda?"></a>什么是lambda?</h2><p>lambda表达式是一段可以传递的代码，它的核心思想是将面向对象中的传递数据变成传递行为。
我们回顾一下在使用java8之前要做的事，之前我们编写一个线程时是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Runnable r = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"do something."</span>);      </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也有人会写一个类去实现<code>Runnable</code>接口，这样做没有问题，我们注意这个接口中只有一个<code>run</code>方法，
当把<code>Runnable</code>对象给<code>Thread</code>对象作为构造参数时创建一个线程，运行后将输出<code>do something.</code>。
我们使用匿名内部类的方式实现了该方法。</p>
<blockquote>
<p>这实际上是一个代码即数据的例子，在<code>run</code>方法中是线程要执行的一个任务，但上面的代码中任务内容已经被规定死了。
当我们有多个不同的任务时，需要重复编写如上代码。</p>
</blockquote>
<p>设计匿名内部类的目的，就是为了方便 Java 程序员将代码作为数据传递。不过，匿名内部 类还是不够简便。
为了执行一个简单的任务逻辑，不得不加上 6 行冗繁的样板代码。那如果是<code>lambda</code>该怎么做?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Runnable r = () -&gt; System.out.println(<span class="string">"do something."</span>);</div></pre></td></tr></table></figure>
<p>嗯，这代码看起来很酷，你可以看到我们用<code>()</code>和<code>-&gt;</code>的方式完成了这件事，这是一个没有名字的函数，也没有人和参数，再简单不过了。
使用<code>-&gt;</code>将参数和实现逻辑分离，当运行这个线程的时候执行的是<code>-&gt;</code>之后的代码片段，且编译器帮助我们做了类型推导；
这个代码片段可以是用<code>{}</code>包含的一段逻辑。下面一起来学习一下<code>lambda</code>的语法。</p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p>在<code>lambda</code>中我们遵循如下的表达式来编写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">expression = (variable) -&gt; action</div></pre></td></tr></table></figure>
<ul>
<li><strong>variable</strong>: 这是一个变量,一个占位符。像<code>x</code>,<code>y</code>,<code>z</code>,可以是多个变量。</li>
<li><strong>action</strong>: 这里我称它为<code>action</code>, 这是我们实现的代码逻辑部分,它可以是一行代码也可以是一个代码片段</li>
</ul>
<p>可以看到Java中lambda表达式的格式：参数、箭头、以及动作实现，当一个动作实现无法用一行代码完成，可以编写
一段代码用<code>{}</code>包裹起来。</p>
<p>lambda表达式可以包含多个参数,例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> sum = (x, y) -&gt; x + y;</div></pre></td></tr></table></figure>
<p>这时候我们应该思考这段代码不是之前的x和y数字相加，而是创建了一个函数，用来计算两个操作数的和。
后面用<code>int</code>类型进行接收，在lambda中为我们省略去了<code>return</code>。</p>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口是只有一个方法的接口，用作lambda表达式的类型。前面写的例子就是一个函数式接口，来看看jdk中的<code>Runnable</code>源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</div><div class="line">     * to create a thread, starting the thread causes the object's</div><div class="line">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</div><div class="line">     * thread.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</div><div class="line">     * take any action whatsoever.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@see</span>     java.lang.Thread#run()</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里只有一个抽象方法<code>run</code>，实际上你不写<code>public abstract</code>也是可以的，在接口中定义的方法都是<code>public abstract</code>的。
同时也使用注解<code>@FunctionalInterface</code>告诉编译器这是一个函数式接口，当然你不这么写也可以，标识后明确了这个函数中
只有一个抽象方法，当你尝试在接口中编写多个方法的时候编译器将不允许这么干。</p>
<h3 id="尝试函数式接口"><a href="#尝试函数式接口" class="headerlink" title="尝试函数式接口"></a>尝试函数式接口</h3><p>我们来编写一个函数式接口，输入一个年龄，判断这个人是否是成人。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionInterfaceDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@FunctionalInterface</span></div><div class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行Predicate判断</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> age       年龄</div><div class="line">     * <span class="doctag">@param</span> predicate Predicate函数式接口</div><div class="line">     * <span class="doctag">@return</span>          返回布尔类型结果</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">doPredicate</span><span class="params">(<span class="keyword">int</span> age, Predicate&lt;Integer&gt; predicate)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> predicate.test(age);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> isAdult = doPredicate(<span class="number">20</span>, x -&gt; x &gt;= <span class="number">18</span>);</div><div class="line">        System.out.println(isAdult);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这个例子我们很轻松的完成 <strong>是否是成人</strong> 的动作，其次判断是否是成人，在此之前我们的做法一般是编写一个
判断是否是成人的方法，是无法将 <strong>判断</strong> 共用的。而在本例只，你要做的是将 <strong>行为</strong> (判断是否是成人，或者是判断是否大于30岁)
传递进去，函数式接口告诉你结果是什么。</p>
<p>实际上诸如上述例子中的接口，伟大的jdk设计者为我们准备了<code>java.util.function</code>包</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/java8-util-function-package.png" alt="" width="300" height="500" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>我们前面写的<code>Predicate</code>函数式接口也是JDK种的一个实现，他们大致分为以下几类：</p>
<table>
<thead>
<tr>
<th>接口</th>
<th style="text-align:center">参数</th>
<th style="text-align:center">返回值</th>
<th>类别</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Consumer<t></t></td>
<td style="text-align:center">T</td>
<td style="text-align:center">void</td>
<td>消费型接口</td>
<td>输出一个值</td>
</tr>
<tr>
<td>Supplier<t></t></td>
<td style="text-align:center">None</td>
<td style="text-align:center">T</td>
<td>供给型接口</td>
<td>工厂方法</td>
</tr>
<tr>
<td>Function<t, r=""></t,></td>
<td style="text-align:center">T</td>
<td style="text-align:center">R</td>
<td>函数型接口</td>
<td>获得 Artist 对象的名字</td>
</tr>
<tr>
<td>Predicate<t></t></td>
<td style="text-align:center">T</td>
<td style="text-align:center">boolean</td>
<td>断言型接口</td>
<td>这张唱片已经发行了吗</td>
</tr>
</tbody>
</table>
<p><strong>消费型接口示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">donation</span><span class="params">(Integer money, Consumer&lt;Integer&gt; consumer)</span></span>&#123;</div><div class="line">    consumer.accept(money);  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    donation(<span class="number">1000</span>, money -&gt; System.out.println(<span class="string">"好心的麦乐迪为Blade捐赠了"</span>+money+<span class="string">"元"</span>)) ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>供给型接口示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">supply</span><span class="params">(Integer num, Supplier&lt;Integer&gt; supplier)</span></span>&#123;</div><div class="line">       List&lt;Integer&gt; resultList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;()   ;</div><div class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;num;x++)  </div><div class="line">           resultList.add(supplier.get());</div><div class="line">       <span class="keyword">return</span> resultList ;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; list = supply(<span class="number">10</span>,() -&gt; (<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>));</div><div class="line">    list.forEach(System.out::println);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>函数型接口示例</strong></p>
<p>转换字符串为<code>Integer</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">convert</span><span class="params">(String str, Function&lt;String, Integer&gt; function)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> function.apply(str);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Integer value = convert(<span class="string">"28"</span>, x -&gt; Integer.parseInt(x));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>断言型接口示例</strong></p>
<p>筛选出只有2个字的水果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">filter</span><span class="params">(List&lt;String&gt; fruit, Predicate&lt;String&gt; predicate)</span></span>&#123;</div><div class="line">    List&lt;String&gt; f = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (String s : fruit) &#123;</div><div class="line">        <span class="keyword">if</span>(predicate.test(s))&#123;</div><div class="line">            f.add(s);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> f;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    List&lt;String&gt; fruit = Arrays.asList(<span class="string">"香蕉"</span>, <span class="string">"哈密瓜"</span>, <span class="string">"榴莲"</span>, <span class="string">"火龙果"</span>, <span class="string">"水蜜桃"</span>);</div><div class="line">    List&lt;String&gt; newFruit = filter(fruit, (f) -&gt; f.length() == <span class="number">2</span>);</div><div class="line">    System.out.println(newFruit);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>在Java语言中，一个接口中定义的方法必须由实现类提供实现。但是当接口中加入新的API时，
实现类按照约定也要修改实现，而Java8的API对现有接口也添加了很多方法，比如<code>List</code>接口中添加了<code>sort</code>方法。
如果按照之前的做法，那么所有的实现类都要实现<code>sort</code>方法，JDK的编写者们一定非常抓狂。</p>
<p>幸运的是我们使用了Java8，这一问题将得到很好的解决，在Java8种引入新的机制，<strong>支持在接口中声明方法同时提供实现</strong>。
这令人激动不已，你有两种方式完成 1.在接口内声明静态方法 2.指定一个默认方法。</p>
<p>我们来看看在JDK8中上述<code>List</code>接口添加方法的问题是如何解决的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</div><div class="line">    Object[] a = <span class="keyword">this</span>.toArray();</div><div class="line">    Arrays.sort(a, (Comparator) c);</div><div class="line">    ListIterator&lt;E&gt; i = <span class="keyword">this</span>.listIterator();</div><div class="line">    <span class="keyword">for</span> (Object e : a) &#123;</div><div class="line">        i.next();</div><div class="line">        i.set((E) e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>翻阅<code>List</code>接口的源码，其中加入一个默认方法<code>default void sort(Comparator&lt;? super E&gt; c)</code>。
在返回值之前加入<code>default</code>关键字，有了这个方法我们可以直接调用<code>sort</code>方法进行排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>);</div><div class="line">list.sort(Comparator.naturalOrder());</div><div class="line">System.out.println(list);</div></pre></td></tr></table></figure>
<p><code>Comparator.naturalOrder()</code>是一个自然排序的实现，这里可以自定义排序方案。
你经常看到使用Java8操作集合的时候可以直接foreach的原因也是在<code>Iterable</code>接口中也新增了一个默认方法：<code>forEach</code> ，
该方法功能和 for 循环类似，但是允许 用户使用一个<code>Lambda</code>表达式作为循环体。</p>
<p>在后面的章节中我们再次通过案例来展示函数式编程的魅力 :)</p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;/static/img/article/lambda-expression.png&quot; alt=&quot;lambda表达式&quot; width=&quot;500&quot; height=&quot;180&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;lambda表达式&lt;/div&gt;
            &lt;/figure&gt;
&lt;p&gt;从&lt;code&gt;java8&lt;/code&gt;出现以来&lt;code&gt;lambda&lt;/code&gt;是最重要的特性之一，它可以让我们用简洁流畅的代码完成一个功能。
很长一段时间&lt;code&gt;java&lt;/code&gt;被吐槽是冗余和缺乏函数式编程能力的语言，随着函数式编程的流行&lt;code&gt;java8&lt;/code&gt;种也引入了
这种编程风格。在此之前我们都在写匿名内部类干这些事，但有时候这不是好的做法，本文中将介绍和使用&lt;code&gt;lambda&lt;/code&gt;，
带你体验函数式编程的魔力。&lt;/p&gt;
    
    </summary>
    
      <category term="跟上Java8" scheme="http://biezhi.me/categories/%E8%B7%9F%E4%B8%8AJava8/"/>
    
    
      <category term="Java8" scheme="http://biezhi.me/tags/Java8/"/>
    
      <category term="lambda" scheme="http://biezhi.me/tags/lambda/"/>
    
      <category term="functional-interface" scheme="http://biezhi.me/tags/functional-interface/"/>
    
  </entry>
  
  <entry>
    <title>跟上Java8系列文章 - 带你实战Java8</title>
    <link href="http://biezhi.me/2017/07/16/keep-up-with-java8.html"/>
    <id>http://biezhi.me/2017/07/16/keep-up-with-java8.html</id>
    <published>2017-07-15T16:00:00.000Z</published>
    <updated>2017-07-19T16:57:32.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/java8-banner.png" alt="开启Java8之路" width="500" height="300" title="">
                </div>
                <div class="image-caption">开启Java8之路</div>
            </figure>
<p><code>Java8</code>从<code>2014</code>年出现至今已经三年有余，这里发布的新功能是自Java1.0发布18年来最大变化的。
没有去处任何API，我们仍然能兼容以前的代码，新功能中提供了更多的语法和设计，帮助开发者编写更清楚、简洁的代码。
Java8把函数式编程里一些最好的思想融入到大家熟知的Java语法中，让你用更少的时间写出高效代码。</p>
<a id="more"></a>
<p>而目前国内很多开发者的现状还处于<code>Java6</code>的语法之上，这确实没什么问题，可以保证你的企业软件稳定运行下去。
但时代总是变化的，我们熟悉的Spring框架也对java8做了更好的支持。
大势所趋，为何不跟上<code>Java8</code>的节奏一起体验现代高级编程语言中的新特性呢？
现在我可以带你深入浅出跟上<code>Java8</code>，这一系列文章写了那些我认为有用所关注的一些内容，如果你对更详细的细节感兴趣可以查阅相关书籍。</p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul>
<li>代码行更少</li>
<li>lambda表达式</li>
<li>Stream API</li>
<li>便于并行</li>
<li>减少空指针</li>
<li>jvm优化</li>
<li>兼容老版本</li>
</ul>
<h2 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h2><ol>
<li><a href="/2017/07/17/keep-up-with-java8-lambda.html">跟上Java8 - 了解lambda</a></li>
<li><a href="/2017/07/18/keep-up-with-java8-stream.html">跟上Java8 - Stream API快速入门</a></li>
<li><a href="/2017/07/19/keep-up-with-java8-functional-programming.html">跟上Java8 - 函数式编程</a></li>
<li><a href="/2017/07/20/keep-up-with-java8-datetime.html">跟上Java8 - 日期和时间最实用技巧</a></li>
<li><a href="/2017/07/21/keep-up-with-java8-features.html">跟上Java8 - 你忽略了的新特性</a></li>
<li><a href="/2017/07/22/keep-up-with-java8-concurrent.html">跟上Java8 - 使用lambda并发编程</a></li>
<li><a href="/2017/07/23/keep-up-with-java8-tips.html">跟上Java8 - 七七八八的黑科技</a></li>
<li><a href="/2017/07/23/keep-up-with-java8-tips.html">跟上Java8 - 七七八八的黑科技</a></li>
<li><a href="/2017/07/24/keep-up-with-java8-complex-examples.html">跟上Java8 - 复杂一点的例子</a></li>
</ol>
<h2 id="资料分享"><a href="#资料分享" class="headerlink" title="资料分享"></a>资料分享</h2><ul>
<li><a href="http://winterbe.com/projects/java8-explorer" target="_blank" rel="external">在线查看Java8新增API</a></li>
<li><a href="https://github.com/shekhargulati/java8-the-missing-tutorial" target="_blank" rel="external">java8-the-missing-tutorial</a></li>
<li><a href="https://github.com/winterbe/java8-tutorial" target="_blank" rel="external">java8-tutorial</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;/static/img/article/java8-banner.png&quot; alt=&quot;开启Java8之路&quot; width=&quot;500&quot; height=&quot;300&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;开启Java8之路&lt;/div&gt;
            &lt;/figure&gt;
&lt;p&gt;&lt;code&gt;Java8&lt;/code&gt;从&lt;code&gt;2014&lt;/code&gt;年出现至今已经三年有余，这里发布的新功能是自Java1.0发布18年来最大变化的。
没有去处任何API，我们仍然能兼容以前的代码，新功能中提供了更多的语法和设计，帮助开发者编写更清楚、简洁的代码。
Java8把函数式编程里一些最好的思想融入到大家熟知的Java语法中，让你用更少的时间写出高效代码。&lt;/p&gt;
    
    </summary>
    
      <category term="跟上Java8" scheme="http://biezhi.me/categories/%E8%B7%9F%E4%B8%8AJava8/"/>
    
    
      <category term="Java8" scheme="http://biezhi.me/tags/Java8/"/>
    
      <category term="系列" scheme="http://biezhi.me/tags/%E7%B3%BB%E5%88%97/"/>
    
      <category term="lambda" scheme="http://biezhi.me/tags/lambda/"/>
    
      <category term="stream-api" scheme="http://biezhi.me/tags/stream-api/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://biezhi.me/2017/07/15/hello-world.html"/>
    <id>http://biezhi.me/2017/07/15/hello-world.html</id>
    <published>2017-07-14T16:00:00.000Z</published>
    <updated>2017-07-16T02:39:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>博客换了主题，以前的文章在github的分支上保存，以后在这里重新写点东西。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客换了主题，以前的文章在github的分支上保存，以后在这里重新写点东西。&lt;/p&gt;

    
    </summary>
    
    
      <category term="blog" scheme="http://biezhi.me/tags/blog/"/>
    
      <category term="hello-world" scheme="http://biezhi.me/tags/hello-world/"/>
    
  </entry>
  
</feed>
