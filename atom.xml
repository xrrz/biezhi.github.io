<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王爵的技术博客</title>
  <subtitle>一个后端程序员的笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://biezhi.me/"/>
  <updated>2017-07-21T15:02:47.000Z</updated>
  <id>http://biezhi.me/</id>
  
  <author>
    <name>王爵nice</name>
    <email>biezhi.me@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分享我安装的Chrome插件</title>
    <link href="http://biezhi.me/2017/07/21/my-chrome-extensions.html"/>
    <id>http://biezhi.me/2017/07/21/my-chrome-extensions.html</id>
    <published>2017-07-20T16:00:00.000Z</published>
    <updated>2017-07-21T15:02:47.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/abp-block.png" alt="ABP广告拦截插件" width="300" height="300" title="">
                </div>
                <div class="image-caption">ABP广告拦截插件</div>
            </figure>
<p>Adblock Plus 已被超过 1 亿台设备使用，是世界上最受欢迎的广告拦截软件。
<a href="https://chrome.google.com/webstore/detail/cfhdojbkjhnklbpkdaibdccddilifddb" target="_blank" rel="external">商店地址</a></p>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/draw-io.png" alt="draw作图应用" width="600" height="400" title="">
                </div>
                <div class="image-caption">draw作图应用</div>
            </figure>
<p>draw.io 是一款免费的在线图表编辑工具, 可以用来编辑工作流, BPM, org charts, UML, ER图, 网络拓朴图等。
<a href="https://chrome.google.com/webstore/detail/pebppomjfocnoigkeepgbmcifnnlndla" target="_blank" rel="external">商店地址</a></p>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/chrome-ext-postman.png" alt="Postman" width="600" height="450" title="">
                </div>
                <div class="image-caption">Postman</div>
            </figure>
<p>Postman可以帮助你更有效的针对API工作。Postman是一个scratch-your-own-itch项目。它需要的是开发者有效的在项目中创建APIS，能够对API测试进行收藏保留。
<a href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop" target="_blank" rel="external">商店地址</a></p>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/chrome-ext-rest-client.png" alt="Advanced" width="600" height="350" title="REST">
                </div>
                <div class="image-caption">REST</div>
            </figure>
<p>网页开发者辅助程序来创建和测试自定义HTTP请求。它是一款非常强大，使用简单的客户端测试工具，得到了程序员的好评。每周超过50k的开发者使用此应用程序。如此多的人是不会错的！
<a href="https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo" target="_blank" rel="external">商店地址</a></p>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/json-view.png" alt="JsonView" width="600" height="400" title="">
                </div>
                <div class="image-caption">JsonView</div>
            </figure>
<p>Jsonview是目前最热门的一款开发者工具插件，确切的来说JSONView是一款非常实用的格式化和语法高亮JSON格式数据查看器jQuery插件。
它是查看json数据的神器。
<a href="https://chrome.google.com/webstore/detail/chklaanhfefbnpoihckbnefhakgolnmc" target="_blank" rel="external">商店地址</a></p>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/octotree-github.png" alt="Github代码查看" width="600" height="350" title="">
                </div>
                <div class="image-caption">Github代码查看</div>
            </figure>
<p>Octotree 是一个 Chrome 扩展，能让你以树形的方式显示 GitHub 项目的目录结构。
<a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc" target="_blank" rel="external">商店地址</a></p>
<p>特性：</p>
<ul>
<li>类似 IDE 的非常方便的代码目录树</li>
<li>使用 PJAX 的超快代码浏览</li>
<li>支持公有库和私有库</li>
</ul>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/pixlr-today.png" alt="Pixlr-Today" width="600" height="350" title="">
                </div>
                <div class="image-caption">Pixlr-Today</div>
            </figure>
<p>Pixlr Today是一个Chrome新标签页扩展，支持自定义搜索，集成天气，带有备忘与 Todo，还可以每日更换壁纸。
<a href="https://chrome.google.com/webstore/detail/pixlr-today/nkgmhpdhaaijoaeaokmhdpfegfmbmfjg" target="_blank" rel="external">商店地址</a></p>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/wappalyzer.png" alt="网站分析利器" width="600" height="350" title="">
                </div>
                <div class="image-caption">网站分析利器</div>
            </figure>
<p>Wappalyzer 网站是一个可以分析不同网站所使用的各种技术的工具，对于有自身经验的网站开发者而言可以通过代码开分析网站的构架和所采用的技术，不过现在你可以通过工具来获得网站技术的参数报告了。
<a href="https://chrome.google.com/webstore/detail/wappalyzer/gppongmhjkpfnbhagpmjfkannfbllamg" target="_blank" rel="external">商店地址</a></p>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/chrome-ext-qrcode.png" alt="二维码生成" width="600" height="350" title="">
                </div>
                <div class="image-caption">二维码生成</div>
            </figure>
<p>使用此插件可以生成当前网址的二维码,手机直接扫二维码就可以访问当前页面。
<a href="https://chrome.google.com/webstore/detail/%E4%BA%8C%E7%BB%B4%E7%A0%81qr%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8qr-code-generato/pflgjjogbmmcmfhfcnlohagkablhbpmg" target="_blank" rel="external">商店地址</a></p>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/crx-selection-translate.png" alt="划词翻译" width="600" height="450" title="">
                </div>
                <div class="image-caption">划词翻译</div>
            </figure>
<p>让浏览任意语言的网站变得无比轻松的 Chrome 扩展程序。
<a href="https://chrome.google.com/webstore/detail/ikhdkkncnoglghljlkmcimlnlhkeamad" target="_blank" rel="external">商店地址</a></p>
<p><strong>特点</strong></p>
<ul>
<li>划词即显示翻译结果，简单、方便、迅速，并且支持多种语言的朗读。</li>
<li>支持在 PDF 文档内使用。</li>
<li>支持多种翻译引擎：有道翻译、百度翻译、谷歌翻译（含谷歌中国翻译）、必应词典。</li>
</ul>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/chrome-ext-tab.png" alt="标签一键保存" width="600" height="400" title="">
                </div>
                <div class="image-caption">标签一键保存</div>
            </figure>
<p>标签一键保存：您必备的标签工具
当您打开多个标签时，通过标签一键保存可以立刻保存所有标签，当您下次想打开时，可以一键全部打开。
<a href="https://chrome.google.com/webstore/detail/%E6%A0%87%E7%AD%BE%E4%B8%80%E9%94%AE%E4%BF%9D%E5%AD%98/inmdclijgcfddiagnepffcmknfgghiho" target="_blank" rel="external">商店地址</a></p>
<p><strong>功能介绍：</strong></p>
<ol>
<li>一键保存当前窗口所有标签</li>
<li>一键打开保存的所有标签</li>
<li>支持自定义标签文件夹名称</li>
<li>浏览标签文件夹下的标签内容</li>
<li>删除指定的标签或标签文件夹</li>
<li>打开单个标签页</li>
</ol>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/data-saver.png" alt="流量节省程序" width="600" height="420" title="">
                </div>
                <div class="image-caption">流量节省程序</div>
            </figure>
<p>使用 Google 服务器优化您访问的网页，借此减少流量消耗。</p>
<p>加载更快，流量更省！
启用此扩展程序后，Chrome 会在加载您要访问的网页之前先使用 Google 服务器对其进行压缩。Google 将不会优化您通过私密连接 (HTTPS) 或在隐身标签页中访问的网页，而且也检测不到这些网页。点击“详细信息”即可查看您访问的网站消耗的流量，从而进一步了解您的流量消耗情况。这可能有助于您根据所使用的网络连接的类型在流量消耗方面做出更明智的决策。
<a href="https://chrome.google.com/webstore/detail/%E6%A0%87%E7%AD%BE%E4%B8%80%E9%94%AE%E4%BF%9D%E5%AD%98/inmdclijgcfddiagnepffcmknfgghiho" target="_blank" rel="external">商店地址</a></p>
<p>以上是我使用的Chrome插件，分享给大家！</p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                   
    
    </summary>
    
    
      <category term="chrome" scheme="http://biezhi.me/tags/chrome/"/>
    
      <category term="插件" scheme="http://biezhi.me/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="postman" scheme="http://biezhi.me/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>跟上Java8 - 日期和时间实用技巧</title>
    <link href="http://biezhi.me/2017/07/20/keep-up-with-java8-datetime.html"/>
    <id>http://biezhi.me/2017/07/20/keep-up-with-java8-datetime.html</id>
    <published>2017-07-19T16:00:00.000Z</published>
    <updated>2017-07-22T08:02:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你开始使用Java操作日期和时间的时候，会有一些棘手。你也许会通过<code>System.currentTimeMillis()</code>
来返回<code>1970年1月1日</code>到今天的毫秒数。或者使用<code>Date</code>类来操作日期；当遇到加减月份、天数的时候
你又需要用到<code>Calendar</code>类；当需要格式化日期的时候需要使用<code>java.text.DateFormat</code>类。
总而言之在Java中操作日期不是很方便，以至于很多开发者不得不使用第三方库，比如: <a href="http://joda-time.sourceforge.net" target="_blank" rel="external">joda-time</a></p>
<a id="more"></a>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/java8-clock.jpeg" alt="时间" width="600" height="380" title="">
                </div>
                <div class="image-caption">时间</div>
            </figure>
<h2 id="现有API存在的问题"><a href="#现有API存在的问题" class="headerlink" title="现有API存在的问题"></a>现有API存在的问题</h2><ul>
<li>线程安全: <code>Date</code>和<code>Calendar</code>不是线程安全的，你需要编写额外的代码处理线程安全问题</li>
<li>API设计和易用性: 由于<code>Date</code>和<code>Calendar</code>的设计不当你无法完成日常的日期操作</li>
<li><code>ZonedDate</code>和<code>Time</code>: 你必须编写额外的逻辑处理时区和那些旧的逻辑</li>
</ul>
<p>好在<a href="http://jcp.org/en/jsr/detail?id=310" target="_blank" rel="external">JSR 310</a>规范中为Java8添加了新的API，
在<code>java.time</code>包中，新的API纠正了过去的缺陷，</p>
<h2 id="新的日期API"><a href="#新的日期API" class="headerlink" title="新的日期API"></a>新的日期API</h2><ul>
<li><code>ZoneId</code>: 时区ID，用来确定Instant和LocalDateTime互相转换的规则</li>
<li><code>Instant</code>: 用来表示时间线上的一个点</li>
<li><code>LocalDate</code>: 表示没有时区的日期, LocalDate是不可变并且线程安全的</li>
<li><code>LocalTime</code>: 表示没有时区的时间, LocalTime是不可变并且线程安全的</li>
<li><code>LocalDateTime</code>: 表示没有时区的日期时间, LocalDateTime是不可变并且线程安全的</li>
<li><code>Clock</code>: 用于访问当前时刻、日期、时间，用到时区</li>
<li><code>Duration</code>: 用秒和纳秒表示时间的数量</li>
</ul>
<p>最常用的就是<code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>了，从它们的名字就可以看出是操作日期
和时间的。这些类是主要用于当时区不需要显式地指定的上下文。在本章节中我们将讨论最常用的api。</p>
<h3 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h3><p><code>LocalDate</code>代表一个IOS格式(yyyy-MM-dd)的日期，可以存储 <code>生日</code>、<code>纪念日</code>等日期。
获取当前的日期：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalDate localDate = LocalDate.now();</div><div class="line">System.out.println(<span class="string">"localDate: "</span> + localDate);</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">localDate: 2017-07-20</div></pre></td></tr></table></figure>
<p><code>LocalDate</code>可以指定特定的日期，调用<code>of</code>或<code>parse</code>方法返回该实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalDate.of(<span class="number">2017</span>, <span class="number">07</span>, <span class="number">20</span>);</div><div class="line"></div><div class="line">LocalDate.parse(<span class="string">"2017-07-20"</span>);</div></pre></td></tr></table></figure>
<p>当然它还有一些其他方法，我们一起来看看：</p>
<p><strong>为今天添加一天，也就是获取明天</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalDate tomorrow = LocalDate.now().plusDays(<span class="number">1</span>);</div></pre></td></tr></table></figure>
<p><strong>从今天减去一个月</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalDate prevMonth = LocalDate.now().minus(<span class="number">1</span>, ChronoUnit.MONTHS);</div></pre></td></tr></table></figure>
<p>下面写两个例子，分别解析日期 <code>2017-07-20</code>，获取每周中的<code>星期</code>和每月中的<code>日</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">DayOfWeek thursday = LocalDate.parse(<span class="string">"2017-07-20"</span>).getDayOfWeek();</div><div class="line">System.out.println(<span class="string">"周四: "</span> + thursday);</div><div class="line"></div><div class="line"><span class="keyword">int</span> twenty = LocalDate.parse(<span class="string">"2017-07-20"</span>).getDayOfMonth();</div><div class="line">System.out.println(<span class="string">"twenty: "</span> + twenty);</div></pre></td></tr></table></figure>
<p>试试今年是不是闰年:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">boolean</span> leapYear = LocalDate.now().isLeapYear();</div><div class="line">System.out.println(<span class="string">"是否闰年: "</span> + leapYear);</div></pre></td></tr></table></figure>
<p>判断是否在日期之前或之后:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">boolean</span> notBefore = LocalDate.parse(<span class="string">"2017-07-20"</span>)</div><div class="line">                .isBefore(LocalDate.parse(<span class="string">"2017-07-22"</span>));</div><div class="line">System.out.println(<span class="string">"notBefore: "</span> + notBefore);</div><div class="line"></div><div class="line"><span class="keyword">boolean</span> isAfter = LocalDate.parse(<span class="string">"2017-07-20"</span>).isAfter(LocalDate.parse(<span class="string">"2017-07-22"</span>));</div><div class="line">System.out.println(<span class="string">"isAfter: "</span> + isAfter);</div></pre></td></tr></table></figure>
<p>获取这个月的第一天:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalDate firstDayOfMonth = LocalDate.parse(<span class="string">"2017-07-20"</span>)</div><div class="line">                .with(TemporalAdjusters.firstDayOfMonth());</div><div class="line">System.out.println(<span class="string">"这个月的第一天: "</span> + firstDayOfMonth);</div><div class="line"></div><div class="line">firstDayOfMonth = firstDayOfMonth.withDayOfMonth(<span class="number">1</span>);</div><div class="line">System.out.println(<span class="string">"这个月的第一天: "</span> + firstDayOfMonth);</div></pre></td></tr></table></figure>
<p>判断今天是否是我的生日，例如我的生日是 <code>2009-07-20</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalDate birthday = LocalDate.of(<span class="number">2009</span>, <span class="number">07</span>, <span class="number">20</span>);</div><div class="line">MonthDay birthdayMd = MonthDay.of(birthday.getMonth(), birthday.getDayOfMonth());</div><div class="line">MonthDay today = MonthDay.from(LocalDate.now());</div><div class="line">System.out.println(<span class="string">"今天是否是我的生日: "</span> + today.equals(birthdayMd));</div></pre></td></tr></table></figure>
<h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><p><code>LocalTime</code>表示一个时间，而不是日期，下面介绍一下它的使用方法。</p>
<p>获取现在的时间，输出<code>15:01:22.144</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalTime now = LocalTime.now();</div><div class="line">System.out.println(<span class="string">"现在的时间: "</span> + now);</div></pre></td></tr></table></figure>
<p>将一个字符串时间解析为<code>LocalTime</code>，输出<code>15:02</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalTime nowTime = LocalTime.parse(<span class="string">"15:02"</span>);</div><div class="line">System.out.println(<span class="string">"时间是: "</span> + nowTime);</div></pre></td></tr></table></figure>
<p>使用静态方法<code>of</code>创建一个时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalTime nowTime = LocalTime.of(<span class="number">15</span>, <span class="number">02</span>);</div><div class="line">System.out.println(<span class="string">"时间是: "</span> + nowTime);</div></pre></td></tr></table></figure>
<p>使用解析字符串的方式并添加一小时，输出<code>16:02</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalTime nextHour = LocalTime.parse(<span class="string">"15:02"</span>).plus(<span class="number">1</span>, ChronoUnit.HOURS);</div><div class="line">System.out.println(<span class="string">"下一个小时: "</span> + nextHour);</div></pre></td></tr></table></figure>
<p>获取时间的<code>小时</code>、<code>分钟</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> hour = LocalTime.parse(<span class="string">"15:02"</span>).getHour();</div><div class="line">System.out.println(<span class="string">"小时: "</span> + hour);</div><div class="line"><span class="keyword">int</span> minute = LocalTime.parse(<span class="string">"15:02"</span>).getMinute();</div><div class="line">System.out.println(<span class="string">"分钟: "</span> + minute);</div></pre></td></tr></table></figure>
<p>我们也可以通过之前类似的API检查一个时间是否在另一个时间之前、之后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">boolean</span> isBefore = LocalTime.parse(<span class="string">"15:02"</span>).isBefore(LocalTime.parse(<span class="string">"16:02"</span>));</div><div class="line"><span class="keyword">boolean</span> isAfter = LocalTime.parse(<span class="string">"15:02"</span>).isAfter(LocalTime.parse(<span class="string">"16:02"</span>));</div><div class="line">System.out.println(<span class="string">"isBefore: "</span> + isBefore);</div><div class="line">System.out.println(<span class="string">"isAfter: "</span> + isAfter);</div></pre></td></tr></table></figure>
<p>输出 <code>isBefore: true</code>, <code>isAfter: false</code>。</p>
<p>在<code>LocalTime</code>类中也将每天的开始和结束作为常量供我们使用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">System.out.println(LocalTime.MAX);</div><div class="line">System.out.println(LocalTime.MIN);</div></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="number">23</span>:<span class="number">59</span>:<span class="number">59.999999999</span></div><div class="line"><span class="number">00</span>:<span class="number">00</span></div></pre></td></tr></table></figure>
<p><code>LocalTime</code>就这些了，下面我们来了解一下<code>LocalDateTime</code></p>
<h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p><code>LocalDateTime</code>是用来表示日期和时间的，这是一个最常用的类之一。</p>
<p>获取当前的日期和时间:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalDateTime now = LocalDateTime.now();</div><div class="line">System.out.println(<span class="string">"现在: "</span> + now);</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">现在: 2017-07-20T15:17:19.926</div></pre></td></tr></table></figure>
<p>下面使用静态方法和字符串的方式分别创建<code>LocalDateTime</code>对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalDateTime.of(<span class="number">2017</span>, Month.JULY, <span class="number">20</span>, <span class="number">15</span>, <span class="number">18</span>);</div><div class="line"></div><div class="line">LocalDateTime.parse(<span class="string">"2017-07-20T15:18:00"</span>);</div><div class="line">``</div><div class="line"></div><div class="line">同时`LocalDateTime`也提供了相关API来对日期和时间进行增减操作:</div><div class="line"></div><div class="line">```java</div><div class="line">LocalDateTime tomorrow = now.plusDays(<span class="number">1</span>);</div><div class="line">System.out.println(<span class="string">"明天的这个时间: "</span> + tomorrow);</div><div class="line"></div><div class="line">LocalDateTime minusTowHour = now.minusHours(<span class="number">2</span>);</div><div class="line">System.out.println(<span class="string">"两小时前: "</span> + minusTowHour);</div></pre></td></tr></table></figure>
<p>这个类也提供一系列的<code>get</code>方法来获取特定单位:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Month month = now.getMonth();</div><div class="line">System.out.println(<span class="string">"当前月份: "</span> + month);</div></pre></td></tr></table></figure>
<h2 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h2><p>在日常开发中我们用到最多的也许就是日期、时间的格式化了，那在Java8种该如何操作呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalDateTime now = LocalDateTime.now();</div><div class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</div><div class="line"></div><div class="line">System.out.println(<span class="string">"默认格式化: "</span> + now);</div><div class="line">System.out.println(<span class="string">"自定义格式化: "</span> + now.format(dateTimeFormatter));</div><div class="line"></div><div class="line">LocalDateTime localDateTime = LocalDateTime.parse(<span class="string">"2017-07-20 15:27:44"</span>, dateTimeFormatter);</div><div class="line">System.out.println(<span class="string">"字符串转LocalDateTime: "</span> + localDateTime);</div></pre></td></tr></table></figure>
<p>也可以使用<code>DateTimeFormatter</code>的<code>format</code>方法将日期、时间格式化为字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</div><div class="line">String dateString = dateTimeFormatter.format(LocalDate.now());</div><div class="line">System.out.println(<span class="string">"日期转字符串: "</span> + dateString);</div></pre></td></tr></table></figure>
<h2 id="日期周期"><a href="#日期周期" class="headerlink" title="日期周期"></a>日期周期</h2><p><code>Period</code>类用于修改给定日期或获得的两个日期之间的区别。</p>
<p>给初始化的日期添加5天:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalDate initialDate = LocalDate.parse(<span class="string">"2017-07-20"</span>);</div><div class="line">LocalDate finalDate   = initialDate.plus(Period.ofDays(<span class="number">5</span>));</div><div class="line">System.out.println(<span class="string">"初始化日期: "</span> + initialDate);</div><div class="line">System.out.println(<span class="string">"加日期之后: "</span> + finalDate);</div></pre></td></tr></table></figure>
<p>周期API中提供给我们可以比较两个日期的差别，像下面这样获取差距天数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">long</span> between = ChronoUnit.DAYS.between(initialDate, finalDate);</div><div class="line">System.out.println(<span class="string">"差距天数: "</span> + between);</div></pre></td></tr></table></figure>
<p>上面的代码会返回5，当然你想获取两个日期相差多少小时也是简单的。</p>
<h2 id="与遗留代码转换"><a href="#与遗留代码转换" class="headerlink" title="与遗留代码转换"></a>与遗留代码转换</h2><p>在之前的代码中你可能出现了大量的<code>Date</code>类，如何将它转换为Java8种的时间类呢？</p>
<p><code>Date</code>和<code>Instant</code>互相转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Date date = Date.from(Instant.now());</div><div class="line">Instant instant = date.toInstant();</div></pre></td></tr></table></figure>
<p><code>Date</code>转换为<code>LocalDateTime</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalDateTime localDateTime = LocalDateTime.from(<span class="keyword">new</span> Date());</div><div class="line">System.out.println(localDateTime);</div></pre></td></tr></table></figure>
<p><code>LocalDateTime</code>转<code>Date</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Date date =</div><div class="line">    Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());</div></pre></td></tr></table></figure>
<p><code>LocalDate</code>转<code>Date</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Date date =</div><div class="line">    Date.from(LocalDate.now().atStartOfDay().atZone(ZoneId.systemDefault()).toInstant());</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你开始使用Java操作日期和时间的时候，会有一些棘手。你也许会通过&lt;code&gt;System.currentTimeMillis()&lt;/code&gt;
来返回&lt;code&gt;1970年1月1日&lt;/code&gt;到今天的毫秒数。或者使用&lt;code&gt;Date&lt;/code&gt;类来操作日期；当遇到加减月份、天数的时候
你又需要用到&lt;code&gt;Calendar&lt;/code&gt;类；当需要格式化日期的时候需要使用&lt;code&gt;java.text.DateFormat&lt;/code&gt;类。
总而言之在Java中操作日期不是很方便，以至于很多开发者不得不使用第三方库，比如: &lt;a href=&quot;http://joda-time.sourceforge.net&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;joda-time&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="跟上Java8" scheme="http://biezhi.me/categories/%E8%B7%9F%E4%B8%8AJava8/"/>
    
    
      <category term="Java8" scheme="http://biezhi.me/tags/Java8/"/>
    
      <category term="datetime" scheme="http://biezhi.me/tags/datetime/"/>
    
  </entry>
  
  <entry>
    <title>跟上Java8 - 函数式编程</title>
    <link href="http://biezhi.me/2017/07/19/keep-up-with-java8-functional-programming.html"/>
    <id>http://biezhi.me/2017/07/19/keep-up-with-java8-functional-programming.html</id>
    <published>2017-07-18T16:00:00.000Z</published>
    <updated>2017-07-21T15:22:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的章节我们快速学习了<code>lambda</code>和<code>Stream</code>，本章节中我们来回顾和理解函数式编程的思想。
我们不断的提及<code>函数式</code>这个名词，它指的是lambda吗？如果是这样，采用函数式编程能为你带来什么好处呢?</p>
<a id="more"></a>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/java8-function-programing.jpg" alt="函数式编程" width="600" height="400" title="">
                </div>
                <div class="image-caption">函数式编程</div>
            </figure>
<h2 id="函数式的思考"><a href="#函数式的思考" class="headerlink" title="函数式的思考"></a>函数式的思考</h2><h3 id="命令式编程"><a href="#命令式编程" class="headerlink" title="命令式编程"></a>命令式编程</h3><p>一般我们实现一个系统有两种思考方式，一种专注于如何实现，比如下厨做菜，通常按照自己熟悉的烹饪方法：首先洗菜，
然后切菜，热油，下菜，然后…… 这看起来像是一系列的命令合集。对于这种”如何做”式的编程风格我们称之为<strong>命令式编程</strong>，
它的特点非常像工厂的流水线、计算机的指令处理，都是串行化、命令式的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">CookingTask cookingTask = <span class="keyword">new</span> CookingTask();</div><div class="line">cookingTask.wash();</div><div class="line">cookingTask.cut();</div><div class="line">cookingTask.deepFry();</div><div class="line">cookingTask.fried();</div><div class="line">...</div></pre></td></tr></table></figure>
<h3 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h3><p>还有一种方式你关注的是要做什么，我们如果用<code>lambda</code>和函数式来解决上述问题应该是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookingDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">(String material, Consumer&lt;String&gt; consumer)</span> </span>&#123;</div><div class="line">        consumer.accept(material);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        CookingDemo cookingDemo = <span class="keyword">new</span> CookingDemo();</div><div class="line">        cookingDemo.doTask(<span class="string">"蔬菜"</span>, material -&gt; System.out.println(<span class="string">"清洗"</span> + material));</div><div class="line">        cookingDemo.doTask(<span class="string">"蔬菜"</span>, material -&gt; System.out.println(material + <span class="string">"切片"</span>));</div><div class="line">        cookingDemo.doTask(<span class="string">"食用油"</span>, material -&gt; System.out.println(material + <span class="string">"烧热"</span>));</div><div class="line">        cookingDemo.doTask(<span class="string">""</span>, material -&gt; System.out.println(<span class="string">"炒菜"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们将烹饪的实现细节交给了函数库，它最大的优势在于你读起来就像是在问题陈述，采用这种方式我们很快可以理解它的功能，
当你在烹饪流程中添加其他步骤也变得非常简单，你只需要调用<code>doTask</code>方法将材料传递进去处理，比如在食用油烧热前我要打个鸡蛋</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">cookingDemo.doTask(<span class="string">"鸡蛋"</span>, material -&gt; System.out.println(material + <span class="string">"打碎搅拌均匀"</span>));</div></pre></td></tr></table></figure>
<p>而不用再编写一个处理鸡蛋的方法。</p>
<h2 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h2><p>对于“什么是函数式编程”这一问题最简化的回答是“它是一种使用函数进行编程的方式”。
每个人的理解都是不同的，其核心是：<strong>在思考问题时，使用不可变值和函数，函数对一个值进行处理，映射成另一个值。</strong></p>
<p>不同的语言社区往往对各自语言中的特性孤芳自赏。现在谈Java程序员如何定义函数式编程还为时尚早，
但是，这根本不重要！我们关心的是如何写出好代码，而不是符合函数式编程风格的代码。</p>
<p>我们想象一下设计一个函数，输入一个字符串类型和布尔类型参数，输出一个整形参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">foo</span><span class="params">(String str, boolea flag)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(flag &amp;&amp; <span class="keyword">null</span> != str)&#123;</div><div class="line">        pos++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> pos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子有输入也有输出，同时每次调用也可能会更行外部的变量值，这样的函数我们称之为是有<strong>副作用</strong>的函数。</p>
<p>在函数式编程的上下文中，一个“函数”对应于一个数学函数：它接受零个或多个参数，生成一个或多个结果，并且不会有任何副作用。
你可以把它看成一个黑盒，它接收输入并产生一些输出，像下面的函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">foo</span><span class="params">(String str, boolea flag)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(flag &amp;&amp; <span class="keyword">null</span> != str)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种类型的函数和你在Java编程语言中见到的函数之间的区别是非常重要的（我们无法想象，log或者sin这样的数学函数会有副作用）。
尤其是，使用同样的参数调用数学函数，它所返回的结果一定是相同的。这里，我们暂时不考虑<code>Random.nextInt</code>这样的方法，</p>
<h2 id="函数的副作用"><a href="#函数的副作用" class="headerlink" title="函数的副作用"></a>函数的副作用</h2><p>当谈论“函数式”时，我们想说的其实是“像数学函数那样——没有副作用”。由此，编程上的一些精妙问题随之而来。
我们的意思是，每个函数都只能使用函数和像<code>if-then-else</code>这样的数学思想来构建吗？
或者，我们也允许函数内部执行一些非函数式的操作，只要这些操作的结果不会暴露给系统中的其他部分？
换句话说，如果程序有一定的副作用，不过该副作用不会为其他的调用者感知，是否我们能假设这种副作用不存在呢？
调用者不需要知道，或者完全不在意这些副作用，因为这对它完全没有影响。</p>
<p>当我们希望能界定这二者之间的区别时，我们将第一种称为纯粹的函数式编程，后者称为函数式编程。</p>
<p>在编程实战中我们很难用Java语言以纯粹的函数式来完成一个程序的，因为很多老的代码包括标准库的函数都是有副作用的
（调用<code>Scanner.nextLine</code>就有副作用，它会从一个文件中读取一行， 通常情况两次调用的结果完全不同）。你希望为你的系统
编写接近纯函数式的实现，需要确保你的代码没有副作用。假设这样一个函数或者方法，它没有副作用，进入方法体执行时会对一个字段的值加一，
退出方法体之前会对该字段减一。对一个单线程的程序而言，这个方法是没有副作用的，可以看作函数式的实现。</p>
<p>我们构建函数式的准则是，被称为“函数式”的函数或方法都只能修改局部变量，除此之外，它引用的对象都应该是<code>final</code>的。
所有的引用类型字段都指向不可变对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面的章节我们快速学习了&lt;code&gt;lambda&lt;/code&gt;和&lt;code&gt;Stream&lt;/code&gt;，本章节中我们来回顾和理解函数式编程的思想。
我们不断的提及&lt;code&gt;函数式&lt;/code&gt;这个名词，它指的是lambda吗？如果是这样，采用函数式编程能为你带来什么好处呢?&lt;/p&gt;
    
    </summary>
    
      <category term="跟上Java8" scheme="http://biezhi.me/categories/%E8%B7%9F%E4%B8%8AJava8/"/>
    
    
      <category term="Java8" scheme="http://biezhi.me/tags/Java8/"/>
    
      <category term="函数式" scheme="http://biezhi.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>跟上Java8 - Stream API快速入门</title>
    <link href="http://biezhi.me/2017/07/18/keep-up-with-java8-stream.html"/>
    <id>http://biezhi.me/2017/07/18/keep-up-with-java8-stream.html</id>
    <published>2017-07-17T16:00:00.000Z</published>
    <updated>2017-07-19T11:46:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前面我们简单介绍了<code>lambda</code>表达式，Java8旨在帮助程序员写出更好的代码，
其对核心类库的改进也是关键的一部分，<code>Stream</code>是Java8种处理集合的抽象概念，
它可以指定你希望对集合的操作，但是执行操作的时间交给具体实现来决定。</p>
<a id="more"></a>
<h2 id="为什么需要Stream"><a href="#为什么需要Stream" class="headerlink" title="为什么需要Stream?"></a>为什么需要Stream?</h2><p>Java语言中集合是使用最多的API，几乎每个Java程序都会用到集合操作，
这里的Stream和IO中的Stream不同，它提供了对集合操作的增强，极大的提高了操作集合对象的便利性。</p>
<p>集合对于大多数编程任务而言都是基本的，为了解释集合是怎么工作，我们想象一下当下最火的外卖APP，
当我们点菜的时候需要按照<strong>距离</strong>、<strong>价格</strong>、<strong>销量</strong>等进行排序后筛选出自己满意的菜品。
你可能想选择距离自己最近的一家店铺点菜，尽管用集合可以完成这件事，但集合的操作远远算不上完美。</p>
<p>假如让你编写上面示例中的代码，你可能会写出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 店铺属性</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Property</span> </span>&#123;</div><div class="line">    String  name;</div><div class="line">    <span class="comment">// 距离，单位:米</span></div><div class="line">    Integer distance;</div><div class="line">    <span class="comment">// 销量，月售</span></div><div class="line">    Integer sales;</div><div class="line">    <span class="comment">// 价格，这里简单起见就写一个级别代表价格段</span></div><div class="line">    Integer priceLevel;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Property</span><span class="params">(String name, <span class="keyword">int</span> distance, <span class="keyword">int</span> sales, <span class="keyword">int</span> priceLevel)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.distance = distance;</div><div class="line">        <span class="keyword">this</span>.sales = sales;</div><div class="line">        <span class="keyword">this</span>.priceLevel = priceLevel;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// getter setter 省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我想要筛选距离我最近的店铺，你可能会写下这样的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Property p1 = <span class="keyword">new</span> Property(<span class="string">"叫了个鸡"</span>, <span class="number">1000</span>, <span class="number">500</span>, <span class="number">2</span>);</div><div class="line">    Property p2 = <span class="keyword">new</span> Property(<span class="string">"张三丰饺子馆"</span>, <span class="number">2300</span>, <span class="number">1500</span>, <span class="number">3</span>);</div><div class="line">    Property p3 = <span class="keyword">new</span> Property(<span class="string">"永和大王"</span>, <span class="number">580</span>, <span class="number">3000</span>, <span class="number">1</span>);</div><div class="line">    Property p4 = <span class="keyword">new</span> Property(<span class="string">"肯德基"</span>, <span class="number">6000</span>, <span class="number">200</span>, <span class="number">4</span>);</div><div class="line"></div><div class="line">    List&lt;Property&gt; properties = Arrays.asList(p1, p2, p3, p4);</div><div class="line"></div><div class="line">    Collections.sort(properties, (x, y) -&gt; x.distance.compareTo(y.distance));</div><div class="line"></div><div class="line">    String name = properties.get(<span class="number">0</span>).name;</div><div class="line">    System.out.println(<span class="string">"距离我最近的店铺是:"</span> + name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里也使用了部分<code>lambda</code>表达式，在Java8之前你可能写的更痛苦一些。
要是要处理大量元素又该怎么办呢？为了提高性能，你需要并行处理，并利用多核架构。
但写并行代码比用迭代器还要复杂，而且调试起来也够受的！</p>
<p>但<code>Stream</code>中操作这些东西当然是非常简单的，小试牛刀:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Stream操作</span></div><div class="line">String name2 = properties.stream()</div><div class="line">                .sorted(Comparator.comparingInt(x -&gt; x.distance))</div><div class="line">                .findFirst()</div><div class="line">                .get().name;</div><div class="line">System.out.println(<span class="string">"距离我最近的店铺是:"</span> + name);</div></pre></td></tr></table></figure>
<p>新的API对所有的集合操作都提供了生成流操作的方法，写的代码也行云流水，我们非常简单的就筛选了离我最近的店铺。
在后面我们继续讲解<code>Stream</code>更多的特性和玩法。</p>
<h2 id="外部迭代和内部迭代"><a href="#外部迭代和内部迭代" class="headerlink" title="外部迭代和内部迭代"></a>外部迭代和内部迭代</h2><p>当你处理集合时，通常会对它进行迭代，然后处理返回的每个元素。比如我想看看月销量大于1000的店铺个数。</p>
<h3 id="使用for循环进行迭代"><a href="#使用for循环进行迭代" class="headerlink" title="使用for循环进行迭代"></a>使用for循环进行迭代</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (Property property : properties) &#123;</div><div class="line">    <span class="keyword">if</span>(property.sales &gt; <span class="number">1000</span>)&#123;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的操作是可行的，但是当每次迭代的时候你需要些很多重复的代码。将<code>for</code>循环修改为并行执行也非常困难，
需要修改每个<code>for</code>的实现。</p>
<p>从集合背后的原理来看，<code>for</code>循环封装了迭代的语法糖，首先调用<code>iterator</code>方法，产生一个<code>Iterator</code>对象，
然后控制整个迭代，这就是<strong>外部迭代</strong>。迭代的过程通过调用<code>Iterator</code>对象的<code>hasNext</code>和<code>next</code>方法完成。</p>
<h3 id="使用迭代器进行计算"><a href="#使用迭代器进行计算" class="headerlink" title="使用迭代器进行计算"></a>使用迭代器进行计算</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">Iterator&lt;Property&gt; iterator = properties.iterator();</div><div class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</div><div class="line">    Property property = iterator.next();</div><div class="line">    <span class="keyword">if</span>(property.sales &gt; <span class="number">1000</span>)&#123;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而迭代器也是有问题的。它很难抽象出<strong>未知的不能操作</strong>；此外它本质上还是串行化的操作，总体来看使用
<code>for</code>循环会将行为和方法混为一谈。</p>
<p>另一种办法是使用内部迭代完成，<code>properties.stream()</code>该方法返回一个<code>Stream</code>而不是迭代器。</p>
<h3 id="使用内部迭代进行计算"><a href="#使用内部迭代进行计算" class="headerlink" title="使用内部迭代进行计算"></a>使用内部迭代进行计算</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">long</span> count2 = properties.stream()</div><div class="line">                .filter(p -&gt; p.sales &gt; <span class="number">1000</span>)</div><div class="line">                .count();</div></pre></td></tr></table></figure>
<p>上述代码是通过<code>Stream API</code>完成的，我们可以把它理解为2个步骤：</p>
<ol>
<li>找出所有销量大于1000的店铺</li>
<li>计算出店铺个数</li>
</ol>
<p>为了找出销量大于1000的店铺，需要先做一次过滤：<code>filter</code>，你可以看看这个方法的入参就是前面讲到的<code>Predicate</code>断言型函数式接口，
测试一个函数完成后，返回值为<code>boolean</code>。
由于<code>Stream API</code>的风格，我们没有改变集合的内容，而是描述了<code>Stream</code>的内容，最终调用<code>count()</code>方法计算出<code>Stream</code>
里包含了多少个过滤之后的对象，返回值为<code>long</code>。</p>
<h2 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h2><p>你已经知道Java8种在<code>Collection</code>接口添加了<code>Stream</code>方法，可以将任何集合转换成一个<code>Stream</code>。
如果你操作的是一个数组可以使用<code>Stream.of(1, 2, 3)</code>方法将它转换为一个流。</p>
<p>也许有人知道JDK7中添加了一些类库如<code>Files.readAllLines(Paths.get(&quot;/home/biezhi/a.txt&quot;))</code>这样的读取文件行方法。
<code>List</code>作为<code>Collection</code>的子类拥有转换流的方法，那么我们读取这个文本文件到一个字符串变量中将变得更简洁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String content = Files.readAllLines(Paths.get(<span class="string">"/home/biezhi/a.txt"</span>)).stream()</div><div class="line">            .collect(Collectors.joining(<span class="string">"\n"</span>));</div></pre></td></tr></table></figure>
<p>这里的<code>collect</code>是后面要讲解的<strong>收集器</strong>，对<code>Stream</code>进行了处理后得到一个文本文件的内容。</p>
<p>JDK8也为我们提供了一些便捷的<code>Stream</code>相关类库:</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/java8-stream-class.png" alt="java8提供的Stream类库" width="320" height="500" title="">
                </div>
                <div class="image-caption">java8提供的Stream类库</div>
            </figure>
<p>创建一个流是很简单的，下面我们试试用创建好的<code>Stream</code>做一些操作吧。</p>
<h2 id="流操作"><a href="#流操作" class="headerlink" title="流操作"></a>流操作</h2><p><code>java.util.stream.Stream</code>中定义了许多流操作的方法，为了更好的理解<code>Stream API</code>掌握它常用的操作非常重要。
流的操作其实可以分为两类：<strong>处理操作</strong>、<strong>聚合操作</strong>。</p>
<ul>
<li>处理操作：诸如<code>filter</code>、<code>map</code>等处理操作将<code>Stream</code>一层一层的进行抽离，返回一个流给下一层使用。</li>
<li>聚合操作：从最后一次流中生成一个结果给调用方，<code>foreach</code>只做处理不做返回。</li>
</ul>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><code>filter</code>看名字也知道是过滤的意思，我们通常在筛选数据的时候用到，频率非常高。
<code>filter</code>方法的参数是<code>Predicate&lt;T&gt; predicate</code>即一个从<code>T</code>到boolean的函数。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/java8-filter.png" alt="" width="300" height="200" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>筛选出距离我在1000米内的店铺</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">properties.stream()</div><div class="line">            .filter(p -&gt; p.distance &lt; <span class="number">1000</span>)</div></pre></td></tr></table></figure>
<p><strong>筛选出名称大于5个字的店铺</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">properties.stream()</div><div class="line">            .filter(p -&gt; p.name.length() &gt; <span class="number">5</span>);</div></pre></td></tr></table></figure>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>有时候我们需要将流中处理的数据类型进行转换，这时候就可以使用<code>map</code>方法来完成，将流中的值转换为一个新的流。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/java8-map.png" alt="" width="300" height="200" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>列出所有店铺的名称</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">properties.stream()</div><div class="line">            .map(p -&gt; p.name);</div></pre></td></tr></table></figure>
<p>传给<code>map</code>的<code>lambda</code>表达式接收一个<code>Property</code>类型的参数，返回一个<code>String</code>。
参数和返回值不必属于同一种类型，但是<code>lambda</code>表达式必须是<code>Function</code>接口的一个实例。</p>
<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>有时候我们会遇到提取子流的操作，这种情况用的不多但是遇到<code>flatMap</code>将变得更容易处理。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/java8-flatmap.png" alt="" width="300" height="200" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>例如我们有一个<code>List&lt;List&lt;String&gt;&gt;</code>结构的数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">List&lt;List&lt;String&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        lists.add(Arrays.asList(<span class="string">"apple"</span>, <span class="string">"click"</span>));</div><div class="line">        lists.add(Arrays.asList(<span class="string">"boss"</span>, <span class="string">"dig"</span>, <span class="string">"qq"</span>, <span class="string">"vivo"</span>));</div><div class="line">        lists.add(Arrays.asList(<span class="string">"c#"</span>, <span class="string">"biezhi"</span>));</div></pre></td></tr></table></figure>
<p>要做的操作是获取这些数据中长度大于2的单词个数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">lists.stream()</div><div class="line">        .flatMap(Collection::stream)</div><div class="line">        .filter(str -&gt; str.length() &gt; <span class="number">2</span>)</div><div class="line">        .count();</div></pre></td></tr></table></figure>
<p>在不使用<code>flatMap</code>前你可能需要做2次<code>for</code>循环。这里调用了<code>List</code>的<code>stream</code>方法将每个列表转换成<code>Stream</code>对象，
其他的就和之前的操作一样。</p>
<h2 id="max和min"><a href="#max和min" class="headerlink" title="max和min"></a>max和min</h2><p><code>Stream</code>中常用的操作之一是求最大值和最小值，<code>Stream API</code> 中的<code>max</code>和<code>min</code>操作足以解决这一问题。</p>
<p>我们需要筛选出价格最低的店铺:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Property property = properties.stream()</div><div class="line">            .max(Comparator.comparingInt(p -&gt; p.priceLevel))</div><div class="line">            .get();</div></pre></td></tr></table></figure>
<p>查找<code>Stream</code>中的最大或最小元素，首先要考虑的是用什么作为排序的指标。
以查找价格最低的店铺为例，排序的指标就是<strong>店铺的价格等级</strong>。</p>
<p>为了让<code>Stream</code>对象按照价格等级进行排序，需要传给它一个<code>Comparator</code>对象。
Java8提供了一个新的静态方法<code>comparingInt</code>，使用它可以方便地实现一个比较器。
放在以前，我们需要比较两个对象的某项属性的值，现在只需要提供一个存取方法就够了。</p>
<h2 id="收集结果"><a href="#收集结果" class="headerlink" title="收集结果"></a>收集结果</h2><p>通常我们处理完流之后想查看一下结果，比如获取总数，转换结果，在前面的示例中你发现调用了
<code>filter</code>、<code>map</code>之后没有下文了，后续的操作应该调用<code>Stream</code>中的<code>collect</code>方法完成。</p>
<p><strong>获取距离我最近的2个店铺</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">List&lt;Property&gt; properties = properties.stream()</div><div class="line">            .sorted(Comparator.comparingInt(x -&gt; x.distance))</div><div class="line">            .limit(<span class="number">2</span>)</div><div class="line">            .collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p><strong>获取所有店铺的名称</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">List&lt;String&gt; names = properties.stream()</div><div class="line">                      .map(p -&gt; p.name)</div><div class="line">                      .collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p><strong>获取每个店铺的价格等级</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Map&lt;String, Integer&gt; map = properties.stream()</div><div class="line">        .collect(Collectors.toMap(Property::getName, Property::getPriceLevel));</div></pre></td></tr></table></figure>
<p><strong>所有价格等级的店铺列表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Map&lt;Integer, List&lt;Property&gt;&gt; priceMap = properties.stream()</div><div class="line">                .collect(Collectors.groupingBy(Property::getPriceLevel));</div></pre></td></tr></table></figure>
<h2 id="并行数据处理"><a href="#并行数据处理" class="headerlink" title="并行数据处理"></a>并行数据处理</h2><h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><p>并发是两个任务共享时间段，并行则是两个任务在同一时间发生，比如运行在多核CPU上。
如果一个程序要运行两个任务，并且只有一个CPU给它们分配了不同的时间片，那么这就是并发，而不是并行。</p>
<blockquote>
<p>并行化是指为缩短任务执行时间，将一个任务分解成几部分，然后并行执行。</p>
</blockquote>
<p>这和顺序执行的任务量是一样的，区别就像用更多的马来拉车，花费的时间自然减少了。
实际上，和顺序执行相比，并行化执行任务时，CPU承载的工作量更大。</p>
<blockquote>
<p>数据并行化是指将数据分成块，为每块数据分配单独的处理单元。</p>
</blockquote>
<p>还是拿马拉车那个例子打比方，就像从车里取出一些货物，放到另一辆车上，两辆马车都沿着同样的路径到达目的地。</p>
<p>当需要在大量数据上执行同样的操作时，数据并行化很管用。
它将问题分解为可在多块数据上求解的形式，然后对每块数据执行运算，最后将各数据块上得到的结果汇总，从而获得最终答案。</p>
<p>人们经常拿任务并行化和数据并行化做比较，在任务并行化中，线程不同，工作各异。
我们最常遇到的JavaEE应用容器便是任务并行化的例子之一，每个线程不光可以为不同用户服务，
还可以为同一个用户执行不同的任务，比如登录或往购物车添加商品。</p>
<h3 id="Stream并行流"><a href="#Stream并行流" class="headerlink" title="Stream并行流"></a>Stream并行流</h3><p>流使得计算变得容易，它的操作也非常简单，但你需要遵守一些约定。默认情况下我们使用集合的<code>stream</code>方法
创建的是一个串行流，你有两种办法让他变成并行流。</p>
<ol>
<li>调用<code>Stream</code>对象的<code>parallel</code>方法</li>
<li>创建流的时候调用<code>parallelStream</code>而不是<code>stream</code>方法</li>
</ol>
<p>我们来用具体的例子来解释串行和并行流</p>
<p><strong>串行化计算</strong></p>
<p>筛选出价格等级小于4，按照距离排序的2个店铺名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">properties.stream()</div><div class="line">            .filter(p -&gt; p.priceLevel &lt; <span class="number">4</span>)</div><div class="line">            .sorted(Comparator.comparingInt(Property::getDistance))</div><div class="line">            .map(Property::getName)</div><div class="line">            .limit(<span class="number">2</span>)</div><div class="line">            .collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p>调用 parallelStream 方法即能并行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">properties.parallelStream()</div><div class="line">            .filter(p -&gt; p.priceLevel &lt; <span class="number">4</span>)</div><div class="line">            .sorted(Comparator.comparingInt(Property::getDistance))</div><div class="line">            .map(Property::getName)</div><div class="line">            .limit(<span class="number">2</span>)</div><div class="line">            .collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p>读到这里，大家的第一反应可能是立即将手头代码中的<code>stream</code>方法替换为<code>parallelStream</code>方法，
因为这样做简直太简单了！先别忙，为了将硬件物尽其用，利用好并行化非常重要，但流类库提供的数据并行化只是其中的一种形式。</p>
<p>我们先要问自己一个问题：<code>并行化运行基于流的代码是否比串行化运行更快？</code>这不是一个简单的问题。
回到前面的例子，哪种方式花的时间更多取决于串行或并行化运行时的环境。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面我们简单介绍了&lt;code&gt;lambda&lt;/code&gt;表达式，Java8旨在帮助程序员写出更好的代码，
其对核心类库的改进也是关键的一部分，&lt;code&gt;Stream&lt;/code&gt;是Java8种处理集合的抽象概念，
它可以指定你希望对集合的操作，但是执行操作的时间交给具体实现来决定。&lt;/p&gt;
    
    </summary>
    
      <category term="跟上Java8" scheme="http://biezhi.me/categories/%E8%B7%9F%E4%B8%8AJava8/"/>
    
    
      <category term="Java8" scheme="http://biezhi.me/tags/Java8/"/>
    
      <category term="stream" scheme="http://biezhi.me/tags/stream/"/>
    
      <category term="flatmap" scheme="http://biezhi.me/tags/flatmap/"/>
    
      <category term="filter" scheme="http://biezhi.me/tags/filter/"/>
    
      <category term="collect" scheme="http://biezhi.me/tags/collect/"/>
    
  </entry>
  
  <entry>
    <title>跟上Java8 - 了解lambda</title>
    <link href="http://biezhi.me/2017/07/17/keep-up-with-java8-lambda.html"/>
    <id>http://biezhi.me/2017/07/17/keep-up-with-java8-lambda.html</id>
    <published>2017-07-16T16:00:00.000Z</published>
    <updated>2017-07-21T15:22:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>从<code>java8</code>出现以来<code>lambda</code>是最重要的特性之一，它可以让我们用简洁流畅的代码完成一个功能。
很长一段时间<code>java</code>被吐槽是冗余和缺乏函数式编程能力的语言，随着函数式编程的流行<code>java8</code>种也引入了
这种编程风格。在此之前我们都在写匿名内部类干这些事，但有时候这不是好的做法，本文中将介绍和使用<code>lambda</code>，
带你体验函数式编程的魔力。</p>
<a id="more"></a>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/lambda-expression.png" alt="lambda表达式" width="500" height="180" title="">
                </div>
                <div class="image-caption">lambda表达式</div>
            </figure>
<h2 id="什么是lambda"><a href="#什么是lambda" class="headerlink" title="什么是lambda?"></a>什么是lambda?</h2><p>lambda表达式是一段可以传递的代码，它的核心思想是将面向对象中的传递数据变成传递行为。
我们回顾一下在使用java8之前要做的事，之前我们编写一个线程时是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Runnable r = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"do something."</span>);      </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也有人会写一个类去实现<code>Runnable</code>接口，这样做没有问题，我们注意这个接口中只有一个<code>run</code>方法，
当把<code>Runnable</code>对象给<code>Thread</code>对象作为构造参数时创建一个线程，运行后将输出<code>do something.</code>。
我们使用匿名内部类的方式实现了该方法。</p>
<blockquote>
<p>这实际上是一个代码即数据的例子，在<code>run</code>方法中是线程要执行的一个任务，但上面的代码中任务内容已经被规定死了。
当我们有多个不同的任务时，需要重复编写如上代码。</p>
</blockquote>
<p>设计匿名内部类的目的，就是为了方便 Java 程序员将代码作为数据传递。不过，匿名内部 类还是不够简便。
为了执行一个简单的任务逻辑，不得不加上 6 行冗繁的样板代码。那如果是<code>lambda</code>该怎么做?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Runnable r = () -&gt; System.out.println(<span class="string">"do something."</span>);</div></pre></td></tr></table></figure>
<p>嗯，这代码看起来很酷，你可以看到我们用<code>()</code>和<code>-&gt;</code>的方式完成了这件事，这是一个没有名字的函数，也没有人和参数，再简单不过了。
使用<code>-&gt;</code>将参数和实现逻辑分离，当运行这个线程的时候执行的是<code>-&gt;</code>之后的代码片段，且编译器帮助我们做了类型推导；
这个代码片段可以是用<code>{}</code>包含的一段逻辑。下面一起来学习一下<code>lambda</code>的语法。</p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p>在<code>lambda</code>中我们遵循如下的表达式来编写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">expression = (variable) -&gt; action</div></pre></td></tr></table></figure>
<ul>
<li><strong>variable</strong>: 这是一个变量,一个占位符。像<code>x</code>,<code>y</code>,<code>z</code>,可以是多个变量。</li>
<li><strong>action</strong>: 这里我称它为<code>action</code>, 这是我们实现的代码逻辑部分,它可以是一行代码也可以是一个代码片段</li>
</ul>
<p>可以看到Java中lambda表达式的格式：参数、箭头、以及动作实现，当一个动作实现无法用一行代码完成，可以编写
一段代码用<code>{}</code>包裹起来。</p>
<p>lambda表达式可以包含多个参数,例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> sum = (x, y) -&gt; x + y;</div></pre></td></tr></table></figure>
<p>这时候我们应该思考这段代码不是之前的x和y数字相加，而是创建了一个函数，用来计算两个操作数的和。
后面用<code>int</code>类型进行接收，在lambda中为我们省略去了<code>return</code>。</p>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口是只有一个方法的接口，用作lambda表达式的类型。前面写的例子就是一个函数式接口，来看看jdk中的<code>Runnable</code>源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</div><div class="line">     * to create a thread, starting the thread causes the object's</div><div class="line">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</div><div class="line">     * thread.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</div><div class="line">     * take any action whatsoever.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@see</span>     java.lang.Thread#run()</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里只有一个抽象方法<code>run</code>，实际上你不写<code>public abstract</code>也是可以的，在接口中定义的方法都是<code>public abstract</code>的。
同时也使用注解<code>@FunctionalInterface</code>告诉编译器这是一个函数式接口，当然你不这么写也可以，标识后明确了这个函数中
只有一个抽象方法，当你尝试在接口中编写多个方法的时候编译器将不允许这么干。</p>
<h3 id="尝试函数式接口"><a href="#尝试函数式接口" class="headerlink" title="尝试函数式接口"></a>尝试函数式接口</h3><p>我们来编写一个函数式接口，输入一个年龄，判断这个人是否是成人。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionInterfaceDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@FunctionalInterface</span></div><div class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行Predicate判断</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> age       年龄</div><div class="line">     * <span class="doctag">@param</span> predicate Predicate函数式接口</div><div class="line">     * <span class="doctag">@return</span>          返回布尔类型结果</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">doPredicate</span><span class="params">(<span class="keyword">int</span> age, Predicate&lt;Integer&gt; predicate)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> predicate.test(age);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> isAdult = doPredicate(<span class="number">20</span>, x -&gt; x &gt;= <span class="number">18</span>);</div><div class="line">        System.out.println(isAdult);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这个例子我们很轻松的完成 <strong>是否是成人</strong> 的动作，其次判断是否是成人，在此之前我们的做法一般是编写一个
判断是否是成人的方法，是无法将 <strong>判断</strong> 共用的。而在本例只，你要做的是将 <strong>行为</strong> (判断是否是成人，或者是判断是否大于30岁)
传递进去，函数式接口告诉你结果是什么。</p>
<p>实际上诸如上述例子中的接口，伟大的jdk设计者为我们准备了<code>java.util.function</code>包</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/java8-util-function-package.png" alt="" width="300" height="500" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>我们前面写的<code>Predicate</code>函数式接口也是JDK种的一个实现，他们大致分为以下几类：</p>
<table>
<thead>
<tr>
<th>接口</th>
<th style="text-align:center">参数</th>
<th style="text-align:center">返回值</th>
<th>类别</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Consumer<t></t></td>
<td style="text-align:center">T</td>
<td style="text-align:center">void</td>
<td>消费型接口</td>
<td>输出一个值</td>
</tr>
<tr>
<td>Supplier<t></t></td>
<td style="text-align:center">None</td>
<td style="text-align:center">T</td>
<td>供给型接口</td>
<td>工厂方法</td>
</tr>
<tr>
<td>Function<t, r=""></t,></td>
<td style="text-align:center">T</td>
<td style="text-align:center">R</td>
<td>函数型接口</td>
<td>获得 Artist 对象的名字</td>
</tr>
<tr>
<td>Predicate<t></t></td>
<td style="text-align:center">T</td>
<td style="text-align:center">boolean</td>
<td>断言型接口</td>
<td>这张唱片已经发行了吗</td>
</tr>
</tbody>
</table>
<p><strong>消费型接口示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">donation</span><span class="params">(Integer money, Consumer&lt;Integer&gt; consumer)</span></span>&#123;</div><div class="line">    consumer.accept(money);  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    donation(<span class="number">1000</span>, money -&gt; System.out.println(<span class="string">"好心的麦乐迪为Blade捐赠了"</span>+money+<span class="string">"元"</span>)) ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>供给型接口示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">supply</span><span class="params">(Integer num, Supplier&lt;Integer&gt; supplier)</span></span>&#123;</div><div class="line">       List&lt;Integer&gt; resultList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;()   ;</div><div class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;num;x++)  </div><div class="line">           resultList.add(supplier.get());</div><div class="line">       <span class="keyword">return</span> resultList ;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; list = supply(<span class="number">10</span>,() -&gt; (<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>));</div><div class="line">    list.forEach(System.out::println);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>函数型接口示例</strong></p>
<p>转换字符串为<code>Integer</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">convert</span><span class="params">(String str, Function&lt;String, Integer&gt; function)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> function.apply(str);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Integer value = convert(<span class="string">"28"</span>, x -&gt; Integer.parseInt(x));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>断言型接口示例</strong></p>
<p>筛选出只有2个字的水果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">filter</span><span class="params">(List&lt;String&gt; fruit, Predicate&lt;String&gt; predicate)</span></span>&#123;</div><div class="line">    List&lt;String&gt; f = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (String s : fruit) &#123;</div><div class="line">        <span class="keyword">if</span>(predicate.test(s))&#123;</div><div class="line">            f.add(s);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> f;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    List&lt;String&gt; fruit = Arrays.asList(<span class="string">"香蕉"</span>, <span class="string">"哈密瓜"</span>, <span class="string">"榴莲"</span>, <span class="string">"火龙果"</span>, <span class="string">"水蜜桃"</span>);</div><div class="line">    List&lt;String&gt; newFruit = filter(fruit, (f) -&gt; f.length() == <span class="number">2</span>);</div><div class="line">    System.out.println(newFruit);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>在Java语言中，一个接口中定义的方法必须由实现类提供实现。但是当接口中加入新的API时，
实现类按照约定也要修改实现，而Java8的API对现有接口也添加了很多方法，比如<code>List</code>接口中添加了<code>sort</code>方法。
如果按照之前的做法，那么所有的实现类都要实现<code>sort</code>方法，JDK的编写者们一定非常抓狂。</p>
<p>幸运的是我们使用了Java8，这一问题将得到很好的解决，在Java8种引入新的机制，<strong>支持在接口中声明方法同时提供实现</strong>。
这令人激动不已，你有两种方式完成 1.在接口内声明静态方法 2.指定一个默认方法。</p>
<p>我们来看看在JDK8中上述<code>List</code>接口添加方法的问题是如何解决的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</div><div class="line">    Object[] a = <span class="keyword">this</span>.toArray();</div><div class="line">    Arrays.sort(a, (Comparator) c);</div><div class="line">    ListIterator&lt;E&gt; i = <span class="keyword">this</span>.listIterator();</div><div class="line">    <span class="keyword">for</span> (Object e : a) &#123;</div><div class="line">        i.next();</div><div class="line">        i.set((E) e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>翻阅<code>List</code>接口的源码，其中加入一个默认方法<code>default void sort(Comparator&lt;? super E&gt; c)</code>。
在返回值之前加入<code>default</code>关键字，有了这个方法我们可以直接调用<code>sort</code>方法进行排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>);</div><div class="line">list.sort(Comparator.naturalOrder());</div><div class="line">System.out.println(list);</div></pre></td></tr></table></figure>
<p><code>Comparator.naturalOrder()</code>是一个自然排序的实现，这里可以自定义排序方案。
你经常看到使用Java8操作集合的时候可以直接foreach的原因也是在<code>Iterable</code>接口中也新增了一个默认方法：<code>forEach</code> ，
该方法功能和 for 循环类似，但是允许 用户使用一个<code>Lambda</code>表达式作为循环体。</p>
<p>在后面的章节中我们再次通过案例来展示函数式编程的魅力 :)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从&lt;code&gt;java8&lt;/code&gt;出现以来&lt;code&gt;lambda&lt;/code&gt;是最重要的特性之一，它可以让我们用简洁流畅的代码完成一个功能。
很长一段时间&lt;code&gt;java&lt;/code&gt;被吐槽是冗余和缺乏函数式编程能力的语言，随着函数式编程的流行&lt;code&gt;java8&lt;/code&gt;种也引入了
这种编程风格。在此之前我们都在写匿名内部类干这些事，但有时候这不是好的做法，本文中将介绍和使用&lt;code&gt;lambda&lt;/code&gt;，
带你体验函数式编程的魔力。&lt;/p&gt;
    
    </summary>
    
      <category term="跟上Java8" scheme="http://biezhi.me/categories/%E8%B7%9F%E4%B8%8AJava8/"/>
    
    
      <category term="Java8" scheme="http://biezhi.me/tags/Java8/"/>
    
      <category term="lambda" scheme="http://biezhi.me/tags/lambda/"/>
    
      <category term="functional-interface" scheme="http://biezhi.me/tags/functional-interface/"/>
    
  </entry>
  
  <entry>
    <title>跟上Java8系列文章 - 带你实战Java8</title>
    <link href="http://biezhi.me/2017/07/16/keep-up-with-java8.html"/>
    <id>http://biezhi.me/2017/07/16/keep-up-with-java8.html</id>
    <published>2017-07-15T16:00:00.000Z</published>
    <updated>2017-07-22T07:02:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Java8</code>从<code>2014</code>年出现至今已经三年有余，这里发布的新功能是自Java1.0发布18年来最大变化的。
没有去处任何API，我们仍然能兼容以前的代码，新功能中提供了更多的语法和设计，帮助开发者编写更清楚、简洁的代码。
Java8把函数式编程里一些最好的思想融入到大家熟知的Java语法中，让你用更少的时间写出高效代码。</p>
<a id="more"></a>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/java8-banner.png" alt="开启Java8之路" width="500" height="300" title="">
                </div>
                <div class="image-caption">开启Java8之路</div>
            </figure>
<p>而目前国内很多开发者的现状还处于<code>Java6</code>的语法之上，这确实没什么问题，可以保证你的企业软件稳定运行下去。
但时代总是变化的，我们熟悉的Spring框架也对java8做了更好的支持。
大势所趋，为何不跟上<code>Java8</code>的节奏一起体验现代高级编程语言中的新特性呢？
现在我可以带你深入浅出跟上<code>Java8</code>，这一系列文章写了那些我认为有用所关注的一些内容，如果你对更详细的细节感兴趣可以查阅相关书籍。</p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul>
<li>代码行更少</li>
<li>lambda表达式</li>
<li>Stream API</li>
<li>便于并行</li>
<li>减少空指针</li>
<li>jvm优化</li>
<li>兼容老版本</li>
</ul>
<h2 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h2><ol>
<li><a href="/2017/07/17/keep-up-with-java8-lambda.html">跟上Java8 - 了解lambda</a></li>
<li><a href="/2017/07/18/keep-up-with-java8-stream.html">跟上Java8 - Stream API快速入门</a></li>
<li><a href="/2017/07/19/keep-up-with-java8-functional-programming.html">跟上Java8 - 函数式编程</a></li>
<li><a href="/2017/07/20/keep-up-with-java8-datetime.html">跟上Java8 - 日期和时间实用技巧</a></li>
<li><a href="/2017/07/21/keep-up-with-java8-features.html">跟上Java8 - 你忽略了的新特性</a></li>
<li><a href="/2017/07/22/keep-up-with-java8-concurrent.html">跟上Java8 - 使用lambda并发编程</a></li>
<li><a href="/2017/07/23/keep-up-with-java8-tips.html">跟上Java8 - 七七八八的黑科技</a></li>
<li><a href="/2017/07/23/keep-up-with-java8-tips.html">跟上Java8 - 优化工作中那些屎代码</a></li>
<li><a href="/2017/07/24/keep-up-with-java8-complex-examples.html">跟上Java8 - 复杂一点的例子</a></li>
</ol>
<h2 id="资料分享"><a href="#资料分享" class="headerlink" title="资料分享"></a>资料分享</h2><ul>
<li><a href="http://winterbe.com/projects/java8-explorer" target="_blank" rel="external">在线查看Java8新增API</a></li>
<li><a href="https://github.com/shekhargulati/java8-the-missing-tutorial" target="_blank" rel="external">java8-the-missing-tutorial</a></li>
<li><a href="https://github.com/winterbe/java8-tutorial" target="_blank" rel="external">java8-tutorial</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Java8&lt;/code&gt;从&lt;code&gt;2014&lt;/code&gt;年出现至今已经三年有余，这里发布的新功能是自Java1.0发布18年来最大变化的。
没有去处任何API，我们仍然能兼容以前的代码，新功能中提供了更多的语法和设计，帮助开发者编写更清楚、简洁的代码。
Java8把函数式编程里一些最好的思想融入到大家熟知的Java语法中，让你用更少的时间写出高效代码。&lt;/p&gt;
    
    </summary>
    
      <category term="跟上Java8" scheme="http://biezhi.me/categories/%E8%B7%9F%E4%B8%8AJava8/"/>
    
    
      <category term="Java8" scheme="http://biezhi.me/tags/Java8/"/>
    
      <category term="系列" scheme="http://biezhi.me/tags/%E7%B3%BB%E5%88%97/"/>
    
      <category term="lambda" scheme="http://biezhi.me/tags/lambda/"/>
    
      <category term="stream-api" scheme="http://biezhi.me/tags/stream-api/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://biezhi.me/2017/07/15/hello-world.html"/>
    <id>http://biezhi.me/2017/07/15/hello-world.html</id>
    <published>2017-07-14T16:00:00.000Z</published>
    <updated>2017-07-16T02:39:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>博客换了主题，以前的文章在github的分支上保存，以后在这里重新写点东西。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客换了主题，以前的文章在github的分支上保存，以后在这里重新写点东西。&lt;/p&gt;

    
    </summary>
    
    
      <category term="blog" scheme="http://biezhi.me/tags/blog/"/>
    
      <category term="hello-world" scheme="http://biezhi.me/tags/hello-world/"/>
    
  </entry>
  
</feed>
