<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王爵的技术博客</title>
  <subtitle>一个后端程序员的笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://biezhi.me/"/>
  <updated>2017-07-25T07:25:09.000Z</updated>
  <id>http://biezhi.me/</id>
  
  <author>
    <name>王爵nice</name>
    <email>biezhi.me@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>十个JDBC的最佳实践</title>
    <link href="http://biezhi.me/2017/07/24/top-10-jdbc-best-practices-for-java.html"/>
    <id>http://biezhi.me/2017/07/24/top-10-jdbc-best-practices-for-java.html</id>
    <published>2017-07-23T16:00:00.000Z</published>
    <updated>2017-07-25T07:25:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>JDBC是Java为多种关系型数据库提供的统一的访问接口，以下是我长期使用JDBC总结的十个最佳实践。</p>
<h2 id="1-使用PrearedStatement"><a href="#1-使用PrearedStatement" class="headerlink" title="1. 使用PrearedStatement"></a>1. 使用PrearedStatement</h2><p>任何一个使用过JDBC的Java程序员几乎都知道这个，<code>PreparedStatment</code>可以通过预编译的方式避免我们在拼接SQL时造成SQL注入。</p>
<a id="more"></a>
<h2 id="2-使用ConnectionPool（连接池）"><a href="#2-使用ConnectionPool（连接池）" class="headerlink" title="2. 使用ConnectionPool（连接池）"></a>2. 使用ConnectionPool（连接池）</h2><p>使用连接池作为最佳实践几乎都成了公认的标准。一些框架已经提供了内建的连接池支持，
例如Spring中的<code>Database Connection Pool</code>，如果你的应用部署在JavaEE的应用服务器中，
例如JBoss，WAS，这些服务器也会有内建的连接池支持，例如DBCP。
使用连接的原因简单的说就是因为创建JDBC连接耗时比较长，如果每次查询都重新打开一个连接，
然后关闭，性能将会非常低，而如果事先创建好一批连接缓存起来，使用的时候取出，
不使用的时候仍不关闭，将会节省大量的创建关闭连接的时间。</p>
<h2 id="3-禁用自动提交"><a href="#3-禁用自动提交" class="headerlink" title="3. 禁用自动提交"></a>3. 禁用自动提交</h2><p>这个最佳实践在我们使用JDBC的批量提交的时候显得非常有用，将自动提交禁用后，
你可以将一组数据库操作放在一个事务中，而自动提交模式每次执行SQL语句都将执行自己的事务，
并且在执行结束提交。</p>
<h2 id="4-使用Batch-Update"><a href="#4-使用Batch-Update" class="headerlink" title="4. 使用Batch Update"></a>4. 使用Batch Update</h2><p>JDBC的API提供了通过addBatch()方法向batch中添加SQL查询，然后通过<code>executeBatch()</code>执行批量的查询。
<code>JDBC batch update</code>可以减少数据库数据传输的往返次数，从而提高性能。</p>
<h2 id="5-使用列名获取ResultSet中的数据，从而避免invalidColumIndexError"><a href="#5-使用列名获取ResultSet中的数据，从而避免invalidColumIndexError" class="headerlink" title="5. 使用列名获取ResultSet中的数据，从而避免invalidColumIndexError"></a>5. 使用列名获取ResultSet中的数据，从而避免invalidColumIndexError</h2><p>JDBC中的查询结果封装在ResultSet中，我们可以通过列名和列序号两种方 式获取查询的数据，
当我们传入的列序号不正确的时候，就会抛出invalidColumIndexException，
例如你传入了0，就会出错，因为<code>ResultSet</code>中的列序号是从1开始的。
另外，如果你更改了数据表中列的顺序，你也不必更改JDBC代码，保持了程序的健壮性。
有一些Java程序员 可能会说通过序号访问列要比列名访问快一些，确实是这样，但是为了程序的健壮性、可读性，我还是更推荐你使用列名来访问。</p>
<h2 id="6-使用变量绑定而不是字符串拼接"><a href="#6-使用变量绑定而不是字符串拼接" class="headerlink" title="6. 使用变量绑定而不是字符串拼接"></a>6. 使用变量绑定而不是字符串拼接</h2><p>在第一条最佳实践中，我们已经说过要使用PreparedStatment可以防止注入，而使用？
或者其他占位符也会提升性能，因为这样数据库就可以使用不同的参数执行相同的查询，
这个最佳实践带来更高的性能的同时也防止了SQL注入。</p>
<h2 id="7-要记住关闭Statement、PreparedStatement和Connection"><a href="#7-要记住关闭Statement、PreparedStatement和Connection" class="headerlink" title="7. 要记住关闭Statement、PreparedStatement和Connection"></a>7. 要记住关闭Statement、PreparedStatement和Connection</h2><p>通常的做法是在<code>finally</code>块中关闭它们，这样做的好处是不论语句执行正确与否，
不管是否有异常抛出，都能保证资源被释放。在Java7中，可以通过<code>Automatic Resource Management Block</code>来自动的关闭资源。</p>
<h2 id="8-选择合适的JDBC驱动"><a href="#8-选择合适的JDBC驱动" class="headerlink" title="8. 选择合适的JDBC驱动"></a>8. 选择合适的JDBC驱动</h2><p>有四种JDBC驱动，分别是</p>
<ol>
<li>JDBC-ODBC Bridge driver (bridge driver)</li>
<li>Native-API/partly Java driver (native driver)</li>
<li>AllJava/Net-protocol driver (middleware driver)</li>
<li>All Java/Native-protocol driver (Pure java driver)</li>
</ol>
<h2 id="9-尽量使用标准的SQL语句，从而在某种程度上避免数据库对SQL支持的差异"><a href="#9-尽量使用标准的SQL语句，从而在某种程度上避免数据库对SQL支持的差异" class="headerlink" title="9. 尽量使用标准的SQL语句，从而在某种程度上避免数据库对SQL支持的差异"></a>9. 尽量使用标准的SQL语句，从而在某种程度上避免数据库对SQL支持的差异</h2><p>不同的数据库厂商的数据库产品支持的SQL的语法会有一定的出入，为了方便移植，我推荐使用标准的ANSI SQL标准写SQL语句。</p>
<h2 id="10-使用正确的getXXX-方法"><a href="#10-使用正确的getXXX-方法" class="headerlink" title="10. 使用正确的getXXX()方法"></a>10. 使用正确的getXXX()方法</h2><p>当从ResultSet中读取数据的时候，虽然JDBC允许你使用<code>getString()</code>和<code>getObject()</code>方法获取任何数据类型，
推荐使用正确的<code>getXXX</code>方法，这样可以避免数据类型转换。</p>
<p>原文地址：<a href="http://javarevisited.blogspot.in/2012/08/top-10-jdbc-best-practices-for-java.html" target="_blank" rel="external">http://javarevisited.blogspot.in/2012/08/top-10-jdbc-best-practices-for-java.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JDBC是Java为多种关系型数据库提供的统一的访问接口，以下是我长期使用JDBC总结的十个最佳实践。&lt;/p&gt;
&lt;h2 id=&quot;1-使用PrearedStatement&quot;&gt;&lt;a href=&quot;#1-使用PrearedStatement&quot; class=&quot;headerlink&quot; title=&quot;1. 使用PrearedStatement&quot;&gt;&lt;/a&gt;1. 使用PrearedStatement&lt;/h2&gt;&lt;p&gt;任何一个使用过JDBC的Java程序员几乎都知道这个，&lt;code&gt;PreparedStatment&lt;/code&gt;可以通过预编译的方式避免我们在拼接SQL时造成SQL注入。&lt;/p&gt;
    
    </summary>
    
    
      <category term="最佳实践" scheme="http://biezhi.me/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="JDBC" scheme="http://biezhi.me/tags/JDBC/"/>
    
      <category term="连接池" scheme="http://biezhi.me/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>跟上Java8 - 你忽略了的新特性</title>
    <link href="http://biezhi.me/2017/07/21/keep-up-with-java8-features.html"/>
    <id>http://biezhi.me/2017/07/21/keep-up-with-java8-features.html</id>
    <published>2017-07-20T16:00:00.000Z</published>
    <updated>2017-07-28T02:28:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然我们开始了Java8的旅程，但是很多人直接从java6上手了java8，
也许有一些JDK7的特性你还不知道，在本章节中带你回顾一下我们忘记了的那些特性。
尽管我们不能讲所有特性都讲一遍，挑出常用的核心特性拎出来一起学习。</p>
<a id="more"></a>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/java8-new-features.jpg" alt="新特新" width="550" height="350" title="">
                </div>
                <div class="image-caption">新特新</div>
            </figure>
<h2 id="异常改进"><a href="#异常改进" class="headerlink" title="异常改进"></a>异常改进</h2><h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h3><p>这个特性是在JDK7种出现的，我们在之前操作一个流对象的时候大概是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 使用流对象</span></div><div class="line">    stream.read();</div><div class="line">    stream.write();</div><div class="line">&#125; <span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">    <span class="comment">// 处理异常</span></div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="comment">// 关闭流资源</span></div><div class="line">    <span class="keyword">if</span>(stream != <span class="keyword">null</span>)&#123;</div><div class="line">        stream.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样无疑有些繁琐，而且<code>finally</code>块还有可能抛出异常。在JDK7种提出了<code>try-with-resources</code>机制，
它规定你操作的类只要是实现了<code>AutoCloseable</code>接口就可以在<code>try</code>语句块退出的时候自动调用<code>close</code>
方法关闭流资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tryWithResources</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">try</span>( InputStream ins = <span class="keyword">new</span> FileInputStream(<span class="string">"/home/biezhi/a.txt"</span>) )&#123;</div><div class="line">        <span class="keyword">char</span> charStr = (<span class="keyword">char</span>) ins.read();</div><div class="line">        System.out.print(charStr);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>使用多个资源</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">try</span> ( InputStream is  = <span class="keyword">new</span> FileInputStream(<span class="string">"/home/biezhi/a.txt"</span>);</div><div class="line">      OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">"/home/biezhi/b.txt"</span>)</div><div class="line">) &#123;</div><div class="line">    <span class="keyword">char</span> charStr = (<span class="keyword">char</span>) is.read();</div><div class="line">    os.write(charStr);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然如果你使用的是非标准库的类也可以自定义<code>AutoCloseable</code>，只要实现其<code>close</code>方法即可。</p>
<h3 id="捕获多个Exception"><a href="#捕获多个Exception" class="headerlink" title="捕获多个Exception"></a>捕获多个Exception</h3><p>当我们在操作一个对象的时候，有时候它会抛出多个异常，像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    Thread.sleep(<span class="number">20000</span>);</div><div class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"/a/b.txt"</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样代码写起来要捕获很多异常，不是很优雅，JDK7种允许你捕获多个异常:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    Thread.sleep(<span class="number">20000</span>);</div><div class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"/a/b.txt"</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException | IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>并且<code>catch</code>语句后面的异常参数是<code>final</code>的，不可以再修改/复制。</p>
<h3 id="处理反射异常"><a href="#处理反射异常" class="headerlink" title="处理反射异常"></a>处理反射异常</h3><p>使用过反射的同学可能知道我们有时候操作反射方法的时候会抛出很多不相关的检查异常，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.biezhi.apple.User"</span>);</div><div class="line">    clazz.getMethods()[<span class="number">0</span>].invoke(object);</div><div class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>尽管你可以使用<code>catch</code>多个异常的方法将上述异常都捕获，但这也让人感到痛苦。
JDK7修复了这个缺陷，引入了一个新类<code>ReflectiveOperationException</code>可以帮你捕获这些反射异常:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.biezhi.apple.User"</span>);</div><div class="line">    clazz.getMethods()[<span class="number">0</span>].invoke(object);</div><div class="line">&#125; <span class="keyword">catch</span> (ReflectiveOperationException e)&#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>我们知道在JDK6甚至之前的时候，我们想要读取一个文本文件也是非常麻烦的一件事，而现在他们都变得简单了，
这要归功于<code>NIO2</code>，我们先看看之前的做法:</p>
<p><strong>读取一个文本文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">BufferedReader br = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"file.txt"</span>));</div><div class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">    String line      = br.readLine();</div><div class="line">    <span class="keyword">while</span> (line != <span class="keyword">null</span>) &#123;</div><div class="line">        sb.append(line);</div><div class="line">        sb.append(System.lineSeparator());</div><div class="line">        line = br.readLine();</div><div class="line">    &#125;</div><div class="line">    String everything = sb.toString();</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        br.close();</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大家对这样的一段代码一定不陌生，但这样太繁琐了，我只想读取一个文本文件，要写这么多代码还要
处理让人头大的一堆异常，怪不得别人吐槽Java臃肿，是在下输了。。。</p>
<p>下面我要介绍在JDK7中是如何改善这些问题的。</p>
<h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><p><code>Path</code>用于来表示文件路径和文件，和<code>File</code>对象类似，<code>Path</code>对象并不一定要对应一个实际存在的文件，
它只是一个路径的抽象序列。</p>
<p>要创建一个<code>Path</code>对象有多种方法，首先是final类Paths的两个static方法，如何从一个路径字符串来构造Path对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Path path1   = Paths.get(<span class="string">"/home/biezhi"</span>, <span class="string">"a.txt"</span>);</div><div class="line">Path path2   = Paths.get(<span class="string">"/home/biezhi/a.txt"</span>);</div><div class="line"></div><div class="line">URI  u       = URI.create(<span class="string">"file:////home/biezhi/a.txt"</span>);</div><div class="line">Path pathURI = Paths.get(u);</div></pre></td></tr></table></figure>
<p>通过<code>FileSystems</code>构造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Path filePath = FileSystems.getDefault().getPath(<span class="string">"/home/biezhi"</span>, <span class="string">"a.txt"</span>);</div></pre></td></tr></table></figure>
<p><code>Path</code>、<code>URI</code>、<code>File</code>之间的转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">File file  = <span class="keyword">new</span> File(<span class="string">"/home/biezhi/a.txt"</span>);</div><div class="line">Path p1    = file.toPath();</div><div class="line">p1.toFile();</div><div class="line">file.toURI();</div></pre></td></tr></table></figure>
<h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>你可以使用<code>Files</code>类快速实现文件操作，例如读取文件内容:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">byte</span>[] data    = Files.readAllBytes(Paths.get(<span class="string">"/home/biezhi/a.txt"</span>));</div><div class="line">String content = <span class="keyword">new</span> String(data, StandardCharsets.UTF_8);</div></pre></td></tr></table></figure>
<p>如果希望按照行读取文件，可以调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">List&lt;String&gt; lines = Files.readAllLines(Paths.get(<span class="string">"/home/biezhi/a.txt"</span>));</div></pre></td></tr></table></figure>
<p>反之你想将字符串写入到文件可以调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Files.write(Paths.get(<span class="string">"/home/biezhi/b.txt"</span>), <span class="string">"Hello JDK7!"</span>.getBytes());</div></pre></td></tr></table></figure>
<p>你也可以按照行写入文件，<code>Files.write</code>方法的参数中支持传递一个实现<code>Iterable</code>接口的类实例。
将内容追加到指定文件可以使用<code>write</code>方法的第三个参数<code>OpenOption</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Files.write(Paths.get(<span class="string">"/home/biezhi/b.txt"</span>), <span class="string">"Hello JDK7!"</span>.getBytes(),</div><div class="line"> StandardOpenOption.APPEND);</div></pre></td></tr></table></figure>
<blockquote>
<p>默认情况Files类中的所有方法都会使用UTF-8编码进行操作，当你不愿意这么干的时候可以传递Charset参数进去变更。</p>
</blockquote>
<p>当然<code>Files</code>还有一些其他的常用方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">InputStream ins  = Files.newInputStream(path);</div><div class="line">OutputStream ops = Files.newOutputStream(path);</div><div class="line">Reader reader    = Files.newBufferedReader(path);</div><div class="line">Writer writer    = Files.newBufferedWriter(path);</div></pre></td></tr></table></figure>
<h3 id="创建、移动、删除"><a href="#创建、移动、删除" class="headerlink" title="创建、移动、删除"></a>创建、移动、删除</h3><p>创建文件、目录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (!Files.exists(path)) &#123;</div><div class="line">    Files.createFile(path);</div><div class="line">    Files.createDirectory(path);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Files</code>还提供了一些方法让我们创建临时文件/临时目录:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Files.createTempFile(dir, prefix, suffix);</div><div class="line">Files.createTempFile(prefix, suffix);</div><div class="line">Files.createTempDirectory(dir, prefix);</div><div class="line">Files.createTempDirectory(prefix);</div></pre></td></tr></table></figure>
<p>这里的<code>dir</code>是一个<code>Path</code>对象，并且字符串prefix和suffix都可能为null。
例如调用<code>Files.createTempFile(null, &quot;.txt&quot;)</code>会返回一个类似<code>/tmp/21238719283331124678.txt</code></p>
<blockquote>
<p>读取一个目录下的文件请使用<code>Files.list</code>和<code>Files.walk</code>方法</p>
</blockquote>
<p>复制、移动一个文件内容到某个路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Files.copy(in, path);</div><div class="line">Files.move(path, path);</div></pre></td></tr></table></figure>
<p>删除一个文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Files.delete(path);</div></pre></td></tr></table></figure>
<h2 id="小的改进"><a href="#小的改进" class="headerlink" title="小的改进"></a>小的改进</h2><p>Java8是一个较大改变的版本，包含了API和库方面的修正，它还对我们常用的API进行很多微小的调整，
下面我会带你了解字符串、集合、注解等新方法。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>使用过JavaScript语言的人可能会知道当我们将一个数组中的元素组合起来变成字符串有一个方法<code>join</code>，
例如我们经常用到将数组中的字符串拼接成用逗号分隔的一长串，这在Java中是要写for循环来完成的。</p>
<p>Java8种添加了<code>join</code>方法帮你搞定这一切:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String str = String.join(<span class="string">","</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</div></pre></td></tr></table></figure>
<p>第一个参数是分隔符，后面接收一个<code>CharSequence</code>类型的可变参数数组或一个<code>Iterable</code>。</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合改变中最大的当属前面章节中提到的<code>Stream API</code>，除此之外还有一些小的改动。</p>
<table>
<thead>
<tr>
<th>类/接口</th>
<th>新方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Iterable</td>
<td>foreach</td>
</tr>
<tr>
<td>Collection</td>
<td>removeIf</td>
</tr>
<tr>
<td>List</td>
<td>replaceAll, sort</td>
</tr>
<tr>
<td>Map</td>
<td>forEach, replace, replaceAll, remove(key, value),<br> putIfAbsent, compute, computeIf, merge</td>
</tr>
<tr>
<td>Iterator</td>
<td>forEachRemaining</td>
</tr>
<tr>
<td>BitSet</td>
<td>stream</td>
</tr>
</tbody>
</table>
<ul>
<li>Map中的很多方法对并发访问十分重要，我们将在后面的章节中介绍</li>
<li>Iterator提供forEachRemaining将剩余的元素传递给一个函数</li>
<li>BitSet可以产生一个Stream对象</li>
</ul>
<p><strong>通用目标类型判断</strong></p>
<p>Java8对泛型参数的推断进行了增强。相信你对Java8之前版本中的类型推断已经比较熟悉了。
比如，Collections中的方法<code>emptyList</code>方法定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">emptyList</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p><code>emptyList</code>方法使用了类型参数T进行参数化。
你可以像下面这样为该类型参数提供一个显式的类型进行函数调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">List&lt;Person&gt; persons = Collections.&lt;Person&gt;emptyList();</div></pre></td></tr></table></figure>
<p>不过编译器也可以推断泛型参数的类型，上面的代码和下面这段代码是等价的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">List&lt;Person&gt; persons = Collections.emptyList();</div></pre></td></tr></table></figure>
<p>我还是习惯于这样书写。</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>Java 8在两个方面对注解机制进行了改进，分别为：</p>
<ul>
<li>可以定义重复注解</li>
<li>可以为任何类型添加注解</li>
</ul>
<h3 id="重复注解"><a href="#重复注解" class="headerlink" title="重复注解"></a>重复注解</h3><p>之前版本的Java禁止对同样的注解类型声明多次。由于这个原因，下面的第二句代码是无效的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@interface</span> Basic &#123;</div><div class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Basic</span>(name=<span class="string">"fix"</span>)</div><div class="line"><span class="meta">@Basic</span>(name=<span class="string">"todo"</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; &#125;</div></pre></td></tr></table></figure>
<p>我们之前可能会通过数组的做法绕过这一限制:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@interface</span> Basic &#123;</div><div class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@interface</span> Basics &#123;</div><div class="line">    Basic[] value();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Basics</span>( &#123; <span class="meta">@Basic</span>(name=<span class="string">"fix"</span>) , <span class="meta">@Basic</span>(name=<span class="string">"todo"</span>) &#125; )</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; &#125;</div></pre></td></tr></table></figure>
<p>Book类的嵌套注解相当难看。这就是Java8想要从根本上移除这一限制的原因，去掉这一限制后，
代码的可读性会好很多。现在，如果你的配置允许重复注解，你可以毫无顾虑地一次声明多个同一种类型的注解。
它目前还不是默认行为，你需要显式地要求进行重复注解。</p>
<p><strong>创建一个重复注解</strong></p>
<p>如果一个注解在设计之初就是可重复的，你可以直接使用它。但是，如果你提供的注解是为用户提供的，
那么就需要做一些工作，说明该注解可以重复。下面是你需要执行的两个步骤：</p>
<ol>
<li>将注解标记为<code>@Repeatable</code></li>
<li>提供一个注解的容器下面的例子展示了如何将<code>@Basic</code>注解修改为可重复注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Repeatable</span>(Basics.class)</div><div class="line"><span class="meta">@interface</span> Basic &#123;</div><div class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@interface</span> Basics &#123;</div><div class="line">    Basic[] value();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完成了这样的定义之后，<code>Person</code>类可以通过多个<code>@Basic</code>注解进行注释，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Basic</span>(name=<span class="string">"fix"</span>)</div><div class="line"><span class="meta">@Basic</span>(name=<span class="string">"todo"</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; &#125;</div></pre></td></tr></table></figure>
<p>编译时， Person 会被认为使用了 <code>@Basics( { @Basic(name=&quot;fix&quot;) , @Basic(name=&quot;todo&quot;)} )</code>
这样的形式进行了注解，所以，你可以把这种新的机制看成是一种语法糖，
它提供了程序员之前利用的惯用法类似的功能。为了确保与反射方法在行为上的一致性，
注解会被封装到一个容器中。 Java API中的<code>getAnnotation(Class&lt;T&gt; annotationClass)</code>方法会为注解元素返回类型为<code>T</code>的注解。
如果实际情况有多个类型为<code>T</code>的注解，该方法的返回到底是哪一个呢？</p>
<p>我们不希望一下子就陷入细节的魔咒，类<code>Class</code>提供了一个新的<code>getAnnotationsByType</code>方法，
它可以帮助我们更好地使用重复注解。比如，你可以像下面这样打印输出<code>Person</code>类的所有<code>Basic</code>注解：</p>
<p>返回一个由重复注解<code>Basic</code>组成的数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Basic[] basics = Person.class.getAnnotationsByType(Basic.class);</div><div class="line">    Arrays.asList(basics).forEach(a -&gt; &#123;</div><div class="line">        System.out.println(a.name());</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Null检查"><a href="#Null检查" class="headerlink" title="Null检查"></a>Null检查</h3><p><code>Objects</code>类添加了两个静态方法<code>isNull</code>和<code>nonNull</code>，在使用流的时候非常有用。</p>
<p>例如获取一个流的所有不为null的对象:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Stream.of(<span class="string">"a"</span>, <span class="string">"c"</span>, <span class="keyword">null</span>, <span class="string">"d"</span>)</div><div class="line">        .filter(Objects::nonNull)</div><div class="line">        .forEach(System.out::println);</div></pre></td></tr></table></figure>
<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>空指针异常一直是困扰Java程序员的问题，也是我们必须要考虑的。当业务代码中充满了<code>if else</code>判断<code>null</code>
的时候程序变得不再优雅，在Java8中提供了<code>Optional</code>类为我们解决<code>NullPointerException</code>。</p>
<p>我们先来看看这段代码有什么问题?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">    String name;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUserName</span><span class="params">(User user)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> user.getName();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码看起来很正常，每个<code>User</code>都会有一个名字。所以调用<code>getUserName</code>方法会发生什么呢？
实际这是不健壮的程序代码，当<code>User</code>对象为null的时候会抛出一个空指针异常。</p>
<p>我们普遍的做法是通过判断<code>user != null</code>然后获取名称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUserName</span><span class="params">(User user)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(user != <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> user.getName();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是如果对象嵌套的层次比较深的时候这样的判断我们需要编写多少次呢？难以想象</p>
<h3 id="处理空指针"><a href="#处理空指针" class="headerlink" title="处理空指针"></a>处理空指针</h3><p><strong>使用Optional优化代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUserNameByOptional</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">    Optional&lt;String&gt; userName = Optional.ofNullable(user).map(User::getName);</div><div class="line">    <span class="keyword">return</span> userName.orElse(<span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当<code>user</code>为null的时候我们设置UserName的值为null，否则返回<code>getName</code>的返回值，但此时不会抛出空指针。</p>
<p>在之前的代码片段中是我们最熟悉的命令式编程思维，写下的代码可以描述程序的执行逻辑，得到什么样的结果。
后面的这种方式是函数式思维方式，在函数式的思维方式里，结果比过程更重要，不需要关注执行的细节。程序的具体执行由编译器来决定。
这种情况下提高程序的性能是一个不容易的事情。</p>
<p>我们再次了解下<code>Optional</code>中的一些使用方法</p>
<h3 id="Optional方法"><a href="#Optional方法" class="headerlink" title="Optional方法"></a>Optional方法</h3><p><strong>创建 Optional 对象</strong></p>
<p>你可以通过静态工厂方法<code>Optional.empty</code>，创建一个空的Optional对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Optional&lt;User&gt; emptyUser = Optional.empty();</div></pre></td></tr></table></figure>
<p>创建一个非空值的Optional</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Optional&lt;User&gt; userOptional = Optional.of(user);</div></pre></td></tr></table></figure>
<p>如果user是一个null，这段代码会立即抛出一个<code>NullPointerException</code>，而不是等到你试图访问<code>user</code>的属性值时才返回一个错误。</p>
<p>可接受null的Optional</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Optional&lt;User&gt; ofNullOptional = Optional.ofNullable(user);</div></pre></td></tr></table></figure>
<p>使用静态工厂方法<code>Optional.ofNullable</code>，你可以创建一个允许null值的Optional对象。</p>
<p>如果user是null，那么得到的Optional对象就是个空对象，但不会让你导致空指针。</p>
<p>使用<code>map</code>从Optional对象中提取和转换值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Optional&lt;User&gt; ofNullOptional = Optional.ofNullable(user);</div><div class="line">Optional&lt;String&gt; userName = ofNullOptional.map(User::getName);</div></pre></td></tr></table></figure>
<p>这种操作就像我们之前在操作<code>Stream</code>是一样的，获取的只是<code>User</code>中的一个属性。</p>
<p><strong>默认行为及解引用Optional对象</strong></p>
<p>我们决定采用orElse方法读取这个变量的值，使用这种方式你还可以定义一个默认值，
遭遇空的Optional变量时，默认值会作为该方法的调用返回值。
Optional类提供了多种方法读取 Optional实例中的变量值。</p>
<ul>
<li>get()是这些方法中最简单但又最不安全的方法。如果变量存在，它直接返回封装的变量 值，否则就抛出一个NoSuchElementException异常。所以，除非你非常确定Optional 变量一定包含值，否则使用这个方法是个相当糟糕的主意。此外，这种方式即便相对于 嵌套式的null检查，也并未体现出多大的改进。</li>
<li>orElse(T other)是我们在代码清单10-5中使用的方法，正如之前提到的，它允许你在 Optional对象不包含值时提供一个默认值。</li>
<li>orElseGet(Supplier&lt;? extends T&gt; other)是orElse方法的延迟调用版，Supplier 方法只有在Optional对象不含值时才执行调用。如果创建默认值是件耗时费力的工作， 你应该考虑采用这种方式（借此提升程序的性能），或者你需要非常确定某个方法仅在 Optional为空时才进行调用，也可以考虑该方式（这种情况有严格的限制条件）。</li>
<li>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)和get方法非常类似， 它们遭遇Optional对象为空时都会抛出一个异常，但是使用orElseThrow你可以定制希 望抛出的异常类型。</li>
<li>ifPresent(Consumer&lt;? super T&gt;)让你能在变量值存在时执行一个作为参数传入的 方法，否则就不进行任何操作。</li>
</ul>
<p>当前除了这些Optional类也具备一些和Stream类似的API，我们先看看Optional类方法:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>empty</td>
<td>返回一个空的 Optional 实例</td>
</tr>
<tr>
<td>get</td>
<td>如果该值存在，将该值用Optional包装返回，否则抛出一个<code>NoSuchElementException</code>异常</td>
</tr>
<tr>
<td>ifPresent</td>
<td>如果值存在，就执行使用该值的方法调用，否则什么也不做</td>
</tr>
<tr>
<td>isPresent</td>
<td>如果值存在就返回true，否则返回false</td>
</tr>
<tr>
<td>filter</td>
<td>如果值存在并且满足提供的谓词，就返回包含该值的 Optional 对象;<br>否则返回一个空的Optional对象</td>
</tr>
<tr>
<td>map</td>
<td>如果值存在，就对该值执行提供的 mapping 函数调用</td>
</tr>
<tr>
<td>flatMap</td>
<td>如果值存在，就对该值执行提供的 mapping 函数调用，<br>返回一个 Optional 类型的值，否则就返 回一个空的Optional对象</td>
</tr>
<tr>
<td>of</td>
<td>将指定值用 Optional 封装之后返回，如果该值为null，则抛出一个<code>NullPointerException</code>异常</td>
</tr>
<tr>
<td>ofNullable</td>
<td>将指定值用 Optional 封装之后返回，如果该值为 null，则返回一个空的Optional对象</td>
</tr>
<tr>
<td>orElse</td>
<td>如果有值则将其返回，否则返回一个默认值</td>
</tr>
<tr>
<td>orElseGet</td>
<td>如果有值则将其返回，否则返回一个由指定的 Supplier 接口生成的值</td>
</tr>
<tr>
<td>orElseThrow</td>
<td>如果有值则将其返回，否则抛出一个由指定的 Supplier 接口生成的异常</td>
</tr>
</tbody>
</table>
<p><strong>用Optional封装可能为null的值</strong></p>
<p>目前我们写的大部分Java代码都会使用返回NULL的方式来表示不存在值，比如Map中通过Key获取值，
当不存在该值会返回一个null。
但是，正如我们之前介绍的，大多数情况下，你可能希望这些方法能返回一个Optional对象。
你无法修改这些方法的签名，但是你很容易用Optional对这些方法的返回值进行封装。</p>
<p>我们接着用Map做例子，假设你有一个<code>Map&lt;String, Object&gt;</code>类型的map，访问由key的值时，
如果map中没有与key关联的值，该次调用就会返回一个null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Object value = map.get(<span class="string">"key"</span>);</div></pre></td></tr></table></figure>
<p>使用Optional封装map的返回值，你可以对这段代码进行优化。要达到这个目的有两种方式：
你可以使用笨拙的<code>if-then-else</code>判断语句，毫无疑问这种方式会增加代码的复杂度；
或者你可以采用<code>Optional.ofNullable</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Optional&lt;Object&gt; value = Optional.ofNullable(map.get(<span class="string">"key"</span>));</div></pre></td></tr></table></figure>
<p>每次你希望安全地对潜在为null的对象进行转换，将其替换为Optional对象时，都可以考虑使用这种方法。</p>
<p>参考资料：<a href="http://www.cnblogs.com/digdeep/p/4478734.html" target="_blank" rel="external">Java文件IO操作应该抛弃File拥抱Paths和Files</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然我们开始了Java8的旅程，但是很多人直接从java6上手了java8，
也许有一些JDK7的特性你还不知道，在本章节中带你回顾一下我们忘记了的那些特性。
尽管我们不能讲所有特性都讲一遍，挑出常用的核心特性拎出来一起学习。&lt;/p&gt;
    
    </summary>
    
      <category term="跟上Java8" scheme="http://biezhi.me/categories/%E8%B7%9F%E4%B8%8AJava8/"/>
    
    
      <category term="Java8" scheme="http://biezhi.me/tags/Java8/"/>
    
      <category term="features" scheme="http://biezhi.me/tags/features/"/>
    
  </entry>
  
  <entry>
    <title>分享我安装的Chrome插件</title>
    <link href="http://biezhi.me/2017/07/21/my-chrome-extensions.html"/>
    <id>http://biezhi.me/2017/07/21/my-chrome-extensions.html</id>
    <published>2017-07-20T16:00:00.000Z</published>
    <updated>2017-07-21T15:02:47.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/abp-block.png" alt="ABP广告拦截插件" width="300" height="300" title="">
                </div>
                <div class="image-caption">ABP广告拦截插件</div>
            </figure>
<p>Adblock Plus 已被超过 1 亿台设备使用，是世界上最受欢迎的广告拦截软件。
<a href="https://chrome.google.com/webstore/detail/cfhdojbkjhnklbpkdaibdccddilifddb" target="_blank" rel="external">商店地址</a></p>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/draw-io.png" alt="draw作图应用" width="600" height="400" title="">
                </div>
                <div class="image-caption">draw作图应用</div>
            </figure>
<p>draw.io 是一款免费的在线图表编辑工具, 可以用来编辑工作流, BPM, org charts, UML, ER图, 网络拓朴图等。
<a href="https://chrome.google.com/webstore/detail/pebppomjfocnoigkeepgbmcifnnlndla" target="_blank" rel="external">商店地址</a></p>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/chrome-ext-postman.png" alt="Postman" width="600" height="450" title="">
                </div>
                <div class="image-caption">Postman</div>
            </figure>
<p>Postman可以帮助你更有效的针对API工作。Postman是一个scratch-your-own-itch项目。它需要的是开发者有效的在项目中创建APIS，能够对API测试进行收藏保留。
<a href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop" target="_blank" rel="external">商店地址</a></p>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/chrome-ext-rest-client.png" alt="Advanced" width="600" height="350" title="REST">
                </div>
                <div class="image-caption">REST</div>
            </figure>
<p>网页开发者辅助程序来创建和测试自定义HTTP请求。它是一款非常强大，使用简单的客户端测试工具，得到了程序员的好评。每周超过50k的开发者使用此应用程序。如此多的人是不会错的！
<a href="https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo" target="_blank" rel="external">商店地址</a></p>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/json-view.png" alt="JsonView" width="600" height="400" title="">
                </div>
                <div class="image-caption">JsonView</div>
            </figure>
<p>Jsonview是目前最热门的一款开发者工具插件，确切的来说JSONView是一款非常实用的格式化和语法高亮JSON格式数据查看器jQuery插件。
它是查看json数据的神器。
<a href="https://chrome.google.com/webstore/detail/chklaanhfefbnpoihckbnefhakgolnmc" target="_blank" rel="external">商店地址</a></p>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/octotree-github.png" alt="Github代码查看" width="600" height="350" title="">
                </div>
                <div class="image-caption">Github代码查看</div>
            </figure>
<p>Octotree 是一个 Chrome 扩展，能让你以树形的方式显示 GitHub 项目的目录结构。
<a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc" target="_blank" rel="external">商店地址</a></p>
<p>特性：</p>
<ul>
<li>类似 IDE 的非常方便的代码目录树</li>
<li>使用 PJAX 的超快代码浏览</li>
<li>支持公有库和私有库</li>
</ul>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/pixlr-today.png" alt="Pixlr-Today" width="600" height="350" title="">
                </div>
                <div class="image-caption">Pixlr-Today</div>
            </figure>
<p>Pixlr Today是一个Chrome新标签页扩展，支持自定义搜索，集成天气，带有备忘与 Todo，还可以每日更换壁纸。
<a href="https://chrome.google.com/webstore/detail/pixlr-today/nkgmhpdhaaijoaeaokmhdpfegfmbmfjg" target="_blank" rel="external">商店地址</a></p>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/wappalyzer.png" alt="网站分析利器" width="600" height="350" title="">
                </div>
                <div class="image-caption">网站分析利器</div>
            </figure>
<p>Wappalyzer 网站是一个可以分析不同网站所使用的各种技术的工具，对于有自身经验的网站开发者而言可以通过代码开分析网站的构架和所采用的技术，不过现在你可以通过工具来获得网站技术的参数报告了。
<a href="https://chrome.google.com/webstore/detail/wappalyzer/gppongmhjkpfnbhagpmjfkannfbllamg" target="_blank" rel="external">商店地址</a></p>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/chrome-ext-qrcode.png" alt="二维码生成" width="600" height="350" title="">
                </div>
                <div class="image-caption">二维码生成</div>
            </figure>
<p>使用此插件可以生成当前网址的二维码,手机直接扫二维码就可以访问当前页面。
<a href="https://chrome.google.com/webstore/detail/%E4%BA%8C%E7%BB%B4%E7%A0%81qr%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8qr-code-generato/pflgjjogbmmcmfhfcnlohagkablhbpmg" target="_blank" rel="external">商店地址</a></p>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/crx-selection-translate.png" alt="划词翻译" width="600" height="450" title="">
                </div>
                <div class="image-caption">划词翻译</div>
            </figure>
<p>让浏览任意语言的网站变得无比轻松的 Chrome 扩展程序。
<a href="https://chrome.google.com/webstore/detail/ikhdkkncnoglghljlkmcimlnlhkeamad" target="_blank" rel="external">商店地址</a></p>
<p><strong>特点</strong></p>
<ul>
<li>划词即显示翻译结果，简单、方便、迅速，并且支持多种语言的朗读。</li>
<li>支持在 PDF 文档内使用。</li>
<li>支持多种翻译引擎：有道翻译、百度翻译、谷歌翻译（含谷歌中国翻译）、必应词典。</li>
</ul>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/chrome-ext-tab.png" alt="标签一键保存" width="600" height="400" title="">
                </div>
                <div class="image-caption">标签一键保存</div>
            </figure>
<p>标签一键保存：您必备的标签工具
当您打开多个标签时，通过标签一键保存可以立刻保存所有标签，当您下次想打开时，可以一键全部打开。
<a href="https://chrome.google.com/webstore/detail/%E6%A0%87%E7%AD%BE%E4%B8%80%E9%94%AE%E4%BF%9D%E5%AD%98/inmdclijgcfddiagnepffcmknfgghiho" target="_blank" rel="external">商店地址</a></p>
<p><strong>功能介绍：</strong></p>
<ol>
<li>一键保存当前窗口所有标签</li>
<li>一键打开保存的所有标签</li>
<li>支持自定义标签文件夹名称</li>
<li>浏览标签文件夹下的标签内容</li>
<li>删除指定的标签或标签文件夹</li>
<li>打开单个标签页</li>
</ol>
<hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/data-saver.png" alt="流量节省程序" width="600" height="420" title="">
                </div>
                <div class="image-caption">流量节省程序</div>
            </figure>
<p>使用 Google 服务器优化您访问的网页，借此减少流量消耗。</p>
<p>加载更快，流量更省！
启用此扩展程序后，Chrome 会在加载您要访问的网页之前先使用 Google 服务器对其进行压缩。Google 将不会优化您通过私密连接 (HTTPS) 或在隐身标签页中访问的网页，而且也检测不到这些网页。点击“详细信息”即可查看您访问的网站消耗的流量，从而进一步了解您的流量消耗情况。这可能有助于您根据所使用的网络连接的类型在流量消耗方面做出更明智的决策。
<a href="https://chrome.google.com/webstore/detail/%E6%A0%87%E7%AD%BE%E4%B8%80%E9%94%AE%E4%BF%9D%E5%AD%98/inmdclijgcfddiagnepffcmknfgghiho" target="_blank" rel="external">商店地址</a></p>
<p>以上是我使用的Chrome插件，分享给大家！</p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                   
    
    </summary>
    
    
      <category term="chrome" scheme="http://biezhi.me/tags/chrome/"/>
    
      <category term="插件" scheme="http://biezhi.me/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="postman" scheme="http://biezhi.me/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>跟上Java8 - 日期和时间实用技巧</title>
    <link href="http://biezhi.me/2017/07/20/keep-up-with-java8-datetime.html"/>
    <id>http://biezhi.me/2017/07/20/keep-up-with-java8-datetime.html</id>
    <published>2017-07-19T16:00:00.000Z</published>
    <updated>2017-07-22T08:02:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你开始使用Java操作日期和时间的时候，会有一些棘手。你也许会通过<code>System.currentTimeMillis()</code>
来返回<code>1970年1月1日</code>到今天的毫秒数。或者使用<code>Date</code>类来操作日期；当遇到加减月份、天数的时候
你又需要用到<code>Calendar</code>类；当需要格式化日期的时候需要使用<code>java.text.DateFormat</code>类。
总而言之在Java中操作日期不是很方便，以至于很多开发者不得不使用第三方库，比如: <a href="http://joda-time.sourceforge.net" target="_blank" rel="external">joda-time</a></p>
<a id="more"></a>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/java8-clock.jpeg" alt="时间" width="600" height="380" title="">
                </div>
                <div class="image-caption">时间</div>
            </figure>
<h2 id="现有API存在的问题"><a href="#现有API存在的问题" class="headerlink" title="现有API存在的问题"></a>现有API存在的问题</h2><ul>
<li>线程安全: <code>Date</code>和<code>Calendar</code>不是线程安全的，你需要编写额外的代码处理线程安全问题</li>
<li>API设计和易用性: 由于<code>Date</code>和<code>Calendar</code>的设计不当你无法完成日常的日期操作</li>
<li><code>ZonedDate</code>和<code>Time</code>: 你必须编写额外的逻辑处理时区和那些旧的逻辑</li>
</ul>
<p>好在<a href="http://jcp.org/en/jsr/detail?id=310" target="_blank" rel="external">JSR 310</a>规范中为Java8添加了新的API，
在<code>java.time</code>包中，新的API纠正了过去的缺陷，</p>
<h2 id="新的日期API"><a href="#新的日期API" class="headerlink" title="新的日期API"></a>新的日期API</h2><ul>
<li><code>ZoneId</code>: 时区ID，用来确定Instant和LocalDateTime互相转换的规则</li>
<li><code>Instant</code>: 用来表示时间线上的一个点</li>
<li><code>LocalDate</code>: 表示没有时区的日期, LocalDate是不可变并且线程安全的</li>
<li><code>LocalTime</code>: 表示没有时区的时间, LocalTime是不可变并且线程安全的</li>
<li><code>LocalDateTime</code>: 表示没有时区的日期时间, LocalDateTime是不可变并且线程安全的</li>
<li><code>Clock</code>: 用于访问当前时刻、日期、时间，用到时区</li>
<li><code>Duration</code>: 用秒和纳秒表示时间的数量</li>
</ul>
<p>最常用的就是<code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>了，从它们的名字就可以看出是操作日期
和时间的。这些类是主要用于当时区不需要显式地指定的上下文。在本章节中我们将讨论最常用的api。</p>
<h3 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h3><p><code>LocalDate</code>代表一个IOS格式(yyyy-MM-dd)的日期，可以存储 <code>生日</code>、<code>纪念日</code>等日期。
获取当前的日期：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalDate localDate = LocalDate.now();</div><div class="line">System.out.println(<span class="string">"localDate: "</span> + localDate);</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">localDate: 2017-07-20</div></pre></td></tr></table></figure>
<p><code>LocalDate</code>可以指定特定的日期，调用<code>of</code>或<code>parse</code>方法返回该实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalDate.of(<span class="number">2017</span>, <span class="number">07</span>, <span class="number">20</span>);</div><div class="line"></div><div class="line">LocalDate.parse(<span class="string">"2017-07-20"</span>);</div></pre></td></tr></table></figure>
<p>当然它还有一些其他方法，我们一起来看看：</p>
<p><strong>为今天添加一天，也就是获取明天</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalDate tomorrow = LocalDate.now().plusDays(<span class="number">1</span>);</div></pre></td></tr></table></figure>
<p><strong>从今天减去一个月</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalDate prevMonth = LocalDate.now().minus(<span class="number">1</span>, ChronoUnit.MONTHS);</div></pre></td></tr></table></figure>
<p>下面写两个例子，分别解析日期 <code>2017-07-20</code>，获取每周中的<code>星期</code>和每月中的<code>日</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">DayOfWeek thursday = LocalDate.parse(<span class="string">"2017-07-20"</span>).getDayOfWeek();</div><div class="line">System.out.println(<span class="string">"周四: "</span> + thursday);</div><div class="line"></div><div class="line"><span class="keyword">int</span> twenty = LocalDate.parse(<span class="string">"2017-07-20"</span>).getDayOfMonth();</div><div class="line">System.out.println(<span class="string">"twenty: "</span> + twenty);</div></pre></td></tr></table></figure>
<p>试试今年是不是闰年:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">boolean</span> leapYear = LocalDate.now().isLeapYear();</div><div class="line">System.out.println(<span class="string">"是否闰年: "</span> + leapYear);</div></pre></td></tr></table></figure>
<p>判断是否在日期之前或之后:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">boolean</span> notBefore = LocalDate.parse(<span class="string">"2017-07-20"</span>)</div><div class="line">                .isBefore(LocalDate.parse(<span class="string">"2017-07-22"</span>));</div><div class="line">System.out.println(<span class="string">"notBefore: "</span> + notBefore);</div><div class="line"></div><div class="line"><span class="keyword">boolean</span> isAfter = LocalDate.parse(<span class="string">"2017-07-20"</span>).isAfter(LocalDate.parse(<span class="string">"2017-07-22"</span>));</div><div class="line">System.out.println(<span class="string">"isAfter: "</span> + isAfter);</div></pre></td></tr></table></figure>
<p>获取这个月的第一天:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalDate firstDayOfMonth = LocalDate.parse(<span class="string">"2017-07-20"</span>)</div><div class="line">                .with(TemporalAdjusters.firstDayOfMonth());</div><div class="line">System.out.println(<span class="string">"这个月的第一天: "</span> + firstDayOfMonth);</div><div class="line"></div><div class="line">firstDayOfMonth = firstDayOfMonth.withDayOfMonth(<span class="number">1</span>);</div><div class="line">System.out.println(<span class="string">"这个月的第一天: "</span> + firstDayOfMonth);</div></pre></td></tr></table></figure>
<p>判断今天是否是我的生日，例如我的生日是 <code>2009-07-20</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalDate birthday = LocalDate.of(<span class="number">2009</span>, <span class="number">07</span>, <span class="number">20</span>);</div><div class="line">MonthDay birthdayMd = MonthDay.of(birthday.getMonth(), birthday.getDayOfMonth());</div><div class="line">MonthDay today = MonthDay.from(LocalDate.now());</div><div class="line">System.out.println(<span class="string">"今天是否是我的生日: "</span> + today.equals(birthdayMd));</div></pre></td></tr></table></figure>
<h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><p><code>LocalTime</code>表示一个时间，而不是日期，下面介绍一下它的使用方法。</p>
<p>获取现在的时间，输出<code>15:01:22.144</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalTime now = LocalTime.now();</div><div class="line">System.out.println(<span class="string">"现在的时间: "</span> + now);</div></pre></td></tr></table></figure>
<p>将一个字符串时间解析为<code>LocalTime</code>，输出<code>15:02</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalTime nowTime = LocalTime.parse(<span class="string">"15:02"</span>);</div><div class="line">System.out.println(<span class="string">"时间是: "</span> + nowTime);</div></pre></td></tr></table></figure>
<p>使用静态方法<code>of</code>创建一个时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalTime nowTime = LocalTime.of(<span class="number">15</span>, <span class="number">02</span>);</div><div class="line">System.out.println(<span class="string">"时间是: "</span> + nowTime);</div></pre></td></tr></table></figure>
<p>使用解析字符串的方式并添加一小时，输出<code>16:02</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalTime nextHour = LocalTime.parse(<span class="string">"15:02"</span>).plus(<span class="number">1</span>, ChronoUnit.HOURS);</div><div class="line">System.out.println(<span class="string">"下一个小时: "</span> + nextHour);</div></pre></td></tr></table></figure>
<p>获取时间的<code>小时</code>、<code>分钟</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> hour = LocalTime.parse(<span class="string">"15:02"</span>).getHour();</div><div class="line">System.out.println(<span class="string">"小时: "</span> + hour);</div><div class="line"><span class="keyword">int</span> minute = LocalTime.parse(<span class="string">"15:02"</span>).getMinute();</div><div class="line">System.out.println(<span class="string">"分钟: "</span> + minute);</div></pre></td></tr></table></figure>
<p>我们也可以通过之前类似的API检查一个时间是否在另一个时间之前、之后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">boolean</span> isBefore = LocalTime.parse(<span class="string">"15:02"</span>).isBefore(LocalTime.parse(<span class="string">"16:02"</span>));</div><div class="line"><span class="keyword">boolean</span> isAfter = LocalTime.parse(<span class="string">"15:02"</span>).isAfter(LocalTime.parse(<span class="string">"16:02"</span>));</div><div class="line">System.out.println(<span class="string">"isBefore: "</span> + isBefore);</div><div class="line">System.out.println(<span class="string">"isAfter: "</span> + isAfter);</div></pre></td></tr></table></figure>
<p>输出 <code>isBefore: true</code>, <code>isAfter: false</code>。</p>
<p>在<code>LocalTime</code>类中也将每天的开始和结束作为常量供我们使用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">System.out.println(LocalTime.MAX);</div><div class="line">System.out.println(LocalTime.MIN);</div></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="number">23</span>:<span class="number">59</span>:<span class="number">59.999999999</span></div><div class="line"><span class="number">00</span>:<span class="number">00</span></div></pre></td></tr></table></figure>
<p><code>LocalTime</code>就这些了，下面我们来了解一下<code>LocalDateTime</code></p>
<h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p><code>LocalDateTime</code>是用来表示日期和时间的，这是一个最常用的类之一。</p>
<p>获取当前的日期和时间:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalDateTime now = LocalDateTime.now();</div><div class="line">System.out.println(<span class="string">"现在: "</span> + now);</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">现在: 2017-07-20T15:17:19.926</div></pre></td></tr></table></figure>
<p>下面使用静态方法和字符串的方式分别创建<code>LocalDateTime</code>对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalDateTime.of(<span class="number">2017</span>, Month.JULY, <span class="number">20</span>, <span class="number">15</span>, <span class="number">18</span>);</div><div class="line"></div><div class="line">LocalDateTime.parse(<span class="string">"2017-07-20T15:18:00"</span>);</div><div class="line">``</div><div class="line"></div><div class="line">同时`LocalDateTime`也提供了相关API来对日期和时间进行增减操作:</div><div class="line"></div><div class="line">```java</div><div class="line">LocalDateTime tomorrow = now.plusDays(<span class="number">1</span>);</div><div class="line">System.out.println(<span class="string">"明天的这个时间: "</span> + tomorrow);</div><div class="line"></div><div class="line">LocalDateTime minusTowHour = now.minusHours(<span class="number">2</span>);</div><div class="line">System.out.println(<span class="string">"两小时前: "</span> + minusTowHour);</div></pre></td></tr></table></figure>
<p>这个类也提供一系列的<code>get</code>方法来获取特定单位:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Month month = now.getMonth();</div><div class="line">System.out.println(<span class="string">"当前月份: "</span> + month);</div></pre></td></tr></table></figure>
<h2 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h2><p>在日常开发中我们用到最多的也许就是日期、时间的格式化了，那在Java8种该如何操作呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalDateTime now = LocalDateTime.now();</div><div class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</div><div class="line"></div><div class="line">System.out.println(<span class="string">"默认格式化: "</span> + now);</div><div class="line">System.out.println(<span class="string">"自定义格式化: "</span> + now.format(dateTimeFormatter));</div><div class="line"></div><div class="line">LocalDateTime localDateTime = LocalDateTime.parse(<span class="string">"2017-07-20 15:27:44"</span>, dateTimeFormatter);</div><div class="line">System.out.println(<span class="string">"字符串转LocalDateTime: "</span> + localDateTime);</div></pre></td></tr></table></figure>
<p>也可以使用<code>DateTimeFormatter</code>的<code>format</code>方法将日期、时间格式化为字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</div><div class="line">String dateString = dateTimeFormatter.format(LocalDate.now());</div><div class="line">System.out.println(<span class="string">"日期转字符串: "</span> + dateString);</div></pre></td></tr></table></figure>
<h2 id="日期周期"><a href="#日期周期" class="headerlink" title="日期周期"></a>日期周期</h2><p><code>Period</code>类用于修改给定日期或获得的两个日期之间的区别。</p>
<p>给初始化的日期添加5天:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalDate initialDate = LocalDate.parse(<span class="string">"2017-07-20"</span>);</div><div class="line">LocalDate finalDate   = initialDate.plus(Period.ofDays(<span class="number">5</span>));</div><div class="line">System.out.println(<span class="string">"初始化日期: "</span> + initialDate);</div><div class="line">System.out.println(<span class="string">"加日期之后: "</span> + finalDate);</div></pre></td></tr></table></figure>
<p>周期API中提供给我们可以比较两个日期的差别，像下面这样获取差距天数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">long</span> between = ChronoUnit.DAYS.between(initialDate, finalDate);</div><div class="line">System.out.println(<span class="string">"差距天数: "</span> + between);</div></pre></td></tr></table></figure>
<p>上面的代码会返回5，当然你想获取两个日期相差多少小时也是简单的。</p>
<h2 id="与遗留代码转换"><a href="#与遗留代码转换" class="headerlink" title="与遗留代码转换"></a>与遗留代码转换</h2><p>在之前的代码中你可能出现了大量的<code>Date</code>类，如何将它转换为Java8种的时间类呢？</p>
<p><code>Date</code>和<code>Instant</code>互相转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Date date = Date.from(Instant.now());</div><div class="line">Instant instant = date.toInstant();</div></pre></td></tr></table></figure>
<p><code>Date</code>转换为<code>LocalDateTime</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalDateTime localDateTime = LocalDateTime.from(<span class="keyword">new</span> Date());</div><div class="line">System.out.println(localDateTime);</div></pre></td></tr></table></figure>
<p><code>LocalDateTime</code>转<code>Date</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Date date =</div><div class="line">    Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());</div></pre></td></tr></table></figure>
<p><code>LocalDate</code>转<code>Date</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Date date =</div><div class="line">    Date.from(LocalDate.now().atStartOfDay().atZone(ZoneId.systemDefault()).toInstant());</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你开始使用Java操作日期和时间的时候，会有一些棘手。你也许会通过&lt;code&gt;System.currentTimeMillis()&lt;/code&gt;
来返回&lt;code&gt;1970年1月1日&lt;/code&gt;到今天的毫秒数。或者使用&lt;code&gt;Date&lt;/code&gt;类来操作日期；当遇到加减月份、天数的时候
你又需要用到&lt;code&gt;Calendar&lt;/code&gt;类；当需要格式化日期的时候需要使用&lt;code&gt;java.text.DateFormat&lt;/code&gt;类。
总而言之在Java中操作日期不是很方便，以至于很多开发者不得不使用第三方库，比如: &lt;a href=&quot;http://joda-time.sourceforge.net&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;joda-time&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="跟上Java8" scheme="http://biezhi.me/categories/%E8%B7%9F%E4%B8%8AJava8/"/>
    
    
      <category term="Java8" scheme="http://biezhi.me/tags/Java8/"/>
    
      <category term="datetime" scheme="http://biezhi.me/tags/datetime/"/>
    
  </entry>
  
  <entry>
    <title>跟上Java8 - 函数式编程</title>
    <link href="http://biezhi.me/2017/07/19/keep-up-with-java8-functional-programming.html"/>
    <id>http://biezhi.me/2017/07/19/keep-up-with-java8-functional-programming.html</id>
    <published>2017-07-18T16:00:00.000Z</published>
    <updated>2017-07-21T15:22:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的章节我们快速学习了<code>lambda</code>和<code>Stream</code>，本章节中我们来回顾和理解函数式编程的思想。
我们不断的提及<code>函数式</code>这个名词，它指的是lambda吗？如果是这样，采用函数式编程能为你带来什么好处呢?</p>
<a id="more"></a>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/java8-function-programing.jpg" alt="函数式编程" width="600" height="400" title="">
                </div>
                <div class="image-caption">函数式编程</div>
            </figure>
<h2 id="函数式的思考"><a href="#函数式的思考" class="headerlink" title="函数式的思考"></a>函数式的思考</h2><h3 id="命令式编程"><a href="#命令式编程" class="headerlink" title="命令式编程"></a>命令式编程</h3><p>一般我们实现一个系统有两种思考方式，一种专注于如何实现，比如下厨做菜，通常按照自己熟悉的烹饪方法：首先洗菜，
然后切菜，热油，下菜，然后…… 这看起来像是一系列的命令合集。对于这种”如何做”式的编程风格我们称之为<strong>命令式编程</strong>，
它的特点非常像工厂的流水线、计算机的指令处理，都是串行化、命令式的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">CookingTask cookingTask = <span class="keyword">new</span> CookingTask();</div><div class="line">cookingTask.wash();</div><div class="line">cookingTask.cut();</div><div class="line">cookingTask.deepFry();</div><div class="line">cookingTask.fried();</div><div class="line">...</div></pre></td></tr></table></figure>
<h3 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h3><p>还有一种方式你关注的是要做什么，我们如果用<code>lambda</code>和函数式来解决上述问题应该是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookingDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">(String material, Consumer&lt;String&gt; consumer)</span> </span>&#123;</div><div class="line">        consumer.accept(material);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        CookingDemo cookingDemo = <span class="keyword">new</span> CookingDemo();</div><div class="line">        cookingDemo.doTask(<span class="string">"蔬菜"</span>, material -&gt; System.out.println(<span class="string">"清洗"</span> + material));</div><div class="line">        cookingDemo.doTask(<span class="string">"蔬菜"</span>, material -&gt; System.out.println(material + <span class="string">"切片"</span>));</div><div class="line">        cookingDemo.doTask(<span class="string">"食用油"</span>, material -&gt; System.out.println(material + <span class="string">"烧热"</span>));</div><div class="line">        cookingDemo.doTask(<span class="string">""</span>, material -&gt; System.out.println(<span class="string">"炒菜"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们将烹饪的实现细节交给了函数库，它最大的优势在于你读起来就像是在问题陈述，采用这种方式我们很快可以理解它的功能，
当你在烹饪流程中添加其他步骤也变得非常简单，你只需要调用<code>doTask</code>方法将材料传递进去处理，比如在食用油烧热前我要打个鸡蛋</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">cookingDemo.doTask(<span class="string">"鸡蛋"</span>, material -&gt; System.out.println(material + <span class="string">"打碎搅拌均匀"</span>));</div></pre></td></tr></table></figure>
<p>而不用再编写一个处理鸡蛋的方法。</p>
<h2 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h2><p>对于“什么是函数式编程”这一问题最简化的回答是“它是一种使用函数进行编程的方式”。
每个人的理解都是不同的，其核心是：<strong>在思考问题时，使用不可变值和函数，函数对一个值进行处理，映射成另一个值。</strong></p>
<p>不同的语言社区往往对各自语言中的特性孤芳自赏。现在谈Java程序员如何定义函数式编程还为时尚早，
但是，这根本不重要！我们关心的是如何写出好代码，而不是符合函数式编程风格的代码。</p>
<p>我们想象一下设计一个函数，输入一个字符串类型和布尔类型参数，输出一个整形参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">foo</span><span class="params">(String str, boolea flag)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(flag &amp;&amp; <span class="keyword">null</span> != str)&#123;</div><div class="line">        pos++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> pos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子有输入也有输出，同时每次调用也可能会更行外部的变量值，这样的函数我们称之为是有<strong>副作用</strong>的函数。</p>
<p>在函数式编程的上下文中，一个“函数”对应于一个数学函数：它接受零个或多个参数，生成一个或多个结果，并且不会有任何副作用。
你可以把它看成一个黑盒，它接收输入并产生一些输出，像下面的函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">foo</span><span class="params">(String str, boolea flag)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(flag &amp;&amp; <span class="keyword">null</span> != str)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种类型的函数和你在Java编程语言中见到的函数之间的区别是非常重要的（我们无法想象，log或者sin这样的数学函数会有副作用）。
尤其是，使用同样的参数调用数学函数，它所返回的结果一定是相同的。这里，我们暂时不考虑<code>Random.nextInt</code>这样的方法，</p>
<h2 id="函数的副作用"><a href="#函数的副作用" class="headerlink" title="函数的副作用"></a>函数的副作用</h2><p>当谈论“函数式”时，我们想说的其实是“像数学函数那样——没有副作用”。由此，编程上的一些精妙问题随之而来。
我们的意思是，每个函数都只能使用函数和像<code>if-then-else</code>这样的数学思想来构建吗？
或者，我们也允许函数内部执行一些非函数式的操作，只要这些操作的结果不会暴露给系统中的其他部分？
换句话说，如果程序有一定的副作用，不过该副作用不会为其他的调用者感知，是否我们能假设这种副作用不存在呢？
调用者不需要知道，或者完全不在意这些副作用，因为这对它完全没有影响。</p>
<p>当我们希望能界定这二者之间的区别时，我们将第一种称为纯粹的函数式编程，后者称为函数式编程。</p>
<p>在编程实战中我们很难用Java语言以纯粹的函数式来完成一个程序的，因为很多老的代码包括标准库的函数都是有副作用的
（调用<code>Scanner.nextLine</code>就有副作用，它会从一个文件中读取一行， 通常情况两次调用的结果完全不同）。你希望为你的系统
编写接近纯函数式的实现，需要确保你的代码没有副作用。假设这样一个函数或者方法，它没有副作用，进入方法体执行时会对一个字段的值加一，
退出方法体之前会对该字段减一。对一个单线程的程序而言，这个方法是没有副作用的，可以看作函数式的实现。</p>
<p>我们构建函数式的准则是，被称为“函数式”的函数或方法都只能修改局部变量，除此之外，它引用的对象都应该是<code>final</code>的。
所有的引用类型字段都指向不可变对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面的章节我们快速学习了&lt;code&gt;lambda&lt;/code&gt;和&lt;code&gt;Stream&lt;/code&gt;，本章节中我们来回顾和理解函数式编程的思想。
我们不断的提及&lt;code&gt;函数式&lt;/code&gt;这个名词，它指的是lambda吗？如果是这样，采用函数式编程能为你带来什么好处呢?&lt;/p&gt;
    
    </summary>
    
      <category term="跟上Java8" scheme="http://biezhi.me/categories/%E8%B7%9F%E4%B8%8AJava8/"/>
    
    
      <category term="Java8" scheme="http://biezhi.me/tags/Java8/"/>
    
      <category term="函数式" scheme="http://biezhi.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>跟上Java8 - Stream API快速入门</title>
    <link href="http://biezhi.me/2017/07/18/keep-up-with-java8-stream.html"/>
    <id>http://biezhi.me/2017/07/18/keep-up-with-java8-stream.html</id>
    <published>2017-07-17T16:00:00.000Z</published>
    <updated>2017-07-19T11:46:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前面我们简单介绍了<code>lambda</code>表达式，Java8旨在帮助程序员写出更好的代码，
其对核心类库的改进也是关键的一部分，<code>Stream</code>是Java8种处理集合的抽象概念，
它可以指定你希望对集合的操作，但是执行操作的时间交给具体实现来决定。</p>
<a id="more"></a>
<h2 id="为什么需要Stream"><a href="#为什么需要Stream" class="headerlink" title="为什么需要Stream?"></a>为什么需要Stream?</h2><p>Java语言中集合是使用最多的API，几乎每个Java程序都会用到集合操作，
这里的Stream和IO中的Stream不同，它提供了对集合操作的增强，极大的提高了操作集合对象的便利性。</p>
<p>集合对于大多数编程任务而言都是基本的，为了解释集合是怎么工作，我们想象一下当下最火的外卖APP，
当我们点菜的时候需要按照<strong>距离</strong>、<strong>价格</strong>、<strong>销量</strong>等进行排序后筛选出自己满意的菜品。
你可能想选择距离自己最近的一家店铺点菜，尽管用集合可以完成这件事，但集合的操作远远算不上完美。</p>
<p>假如让你编写上面示例中的代码，你可能会写出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 店铺属性</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Property</span> </span>&#123;</div><div class="line">    String  name;</div><div class="line">    <span class="comment">// 距离，单位:米</span></div><div class="line">    Integer distance;</div><div class="line">    <span class="comment">// 销量，月售</span></div><div class="line">    Integer sales;</div><div class="line">    <span class="comment">// 价格，这里简单起见就写一个级别代表价格段</span></div><div class="line">    Integer priceLevel;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Property</span><span class="params">(String name, <span class="keyword">int</span> distance, <span class="keyword">int</span> sales, <span class="keyword">int</span> priceLevel)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.distance = distance;</div><div class="line">        <span class="keyword">this</span>.sales = sales;</div><div class="line">        <span class="keyword">this</span>.priceLevel = priceLevel;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// getter setter 省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我想要筛选距离我最近的店铺，你可能会写下这样的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Property p1 = <span class="keyword">new</span> Property(<span class="string">"叫了个鸡"</span>, <span class="number">1000</span>, <span class="number">500</span>, <span class="number">2</span>);</div><div class="line">    Property p2 = <span class="keyword">new</span> Property(<span class="string">"张三丰饺子馆"</span>, <span class="number">2300</span>, <span class="number">1500</span>, <span class="number">3</span>);</div><div class="line">    Property p3 = <span class="keyword">new</span> Property(<span class="string">"永和大王"</span>, <span class="number">580</span>, <span class="number">3000</span>, <span class="number">1</span>);</div><div class="line">    Property p4 = <span class="keyword">new</span> Property(<span class="string">"肯德基"</span>, <span class="number">6000</span>, <span class="number">200</span>, <span class="number">4</span>);</div><div class="line"></div><div class="line">    List&lt;Property&gt; properties = Arrays.asList(p1, p2, p3, p4);</div><div class="line"></div><div class="line">    Collections.sort(properties, (x, y) -&gt; x.distance.compareTo(y.distance));</div><div class="line"></div><div class="line">    String name = properties.get(<span class="number">0</span>).name;</div><div class="line">    System.out.println(<span class="string">"距离我最近的店铺是:"</span> + name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里也使用了部分<code>lambda</code>表达式，在Java8之前你可能写的更痛苦一些。
要是要处理大量元素又该怎么办呢？为了提高性能，你需要并行处理，并利用多核架构。
但写并行代码比用迭代器还要复杂，而且调试起来也够受的！</p>
<p>但<code>Stream</code>中操作这些东西当然是非常简单的，小试牛刀:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Stream操作</span></div><div class="line">String name2 = properties.stream()</div><div class="line">                .sorted(Comparator.comparingInt(x -&gt; x.distance))</div><div class="line">                .findFirst()</div><div class="line">                .get().name;</div><div class="line">System.out.println(<span class="string">"距离我最近的店铺是:"</span> + name);</div></pre></td></tr></table></figure>
<p>新的API对所有的集合操作都提供了生成流操作的方法，写的代码也行云流水，我们非常简单的就筛选了离我最近的店铺。
在后面我们继续讲解<code>Stream</code>更多的特性和玩法。</p>
<h2 id="外部迭代和内部迭代"><a href="#外部迭代和内部迭代" class="headerlink" title="外部迭代和内部迭代"></a>外部迭代和内部迭代</h2><p>当你处理集合时，通常会对它进行迭代，然后处理返回的每个元素。比如我想看看月销量大于1000的店铺个数。</p>
<h3 id="使用for循环进行迭代"><a href="#使用for循环进行迭代" class="headerlink" title="使用for循环进行迭代"></a>使用for循环进行迭代</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (Property property : properties) &#123;</div><div class="line">    <span class="keyword">if</span>(property.sales &gt; <span class="number">1000</span>)&#123;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的操作是可行的，但是当每次迭代的时候你需要些很多重复的代码。将<code>for</code>循环修改为并行执行也非常困难，
需要修改每个<code>for</code>的实现。</p>
<p>从集合背后的原理来看，<code>for</code>循环封装了迭代的语法糖，首先调用<code>iterator</code>方法，产生一个<code>Iterator</code>对象，
然后控制整个迭代，这就是<strong>外部迭代</strong>。迭代的过程通过调用<code>Iterator</code>对象的<code>hasNext</code>和<code>next</code>方法完成。</p>
<h3 id="使用迭代器进行计算"><a href="#使用迭代器进行计算" class="headerlink" title="使用迭代器进行计算"></a>使用迭代器进行计算</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">Iterator&lt;Property&gt; iterator = properties.iterator();</div><div class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</div><div class="line">    Property property = iterator.next();</div><div class="line">    <span class="keyword">if</span>(property.sales &gt; <span class="number">1000</span>)&#123;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而迭代器也是有问题的。它很难抽象出<strong>未知的不能操作</strong>；此外它本质上还是串行化的操作，总体来看使用
<code>for</code>循环会将行为和方法混为一谈。</p>
<p>另一种办法是使用内部迭代完成，<code>properties.stream()</code>该方法返回一个<code>Stream</code>而不是迭代器。</p>
<h3 id="使用内部迭代进行计算"><a href="#使用内部迭代进行计算" class="headerlink" title="使用内部迭代进行计算"></a>使用内部迭代进行计算</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">long</span> count2 = properties.stream()</div><div class="line">                .filter(p -&gt; p.sales &gt; <span class="number">1000</span>)</div><div class="line">                .count();</div></pre></td></tr></table></figure>
<p>上述代码是通过<code>Stream API</code>完成的，我们可以把它理解为2个步骤：</p>
<ol>
<li>找出所有销量大于1000的店铺</li>
<li>计算出店铺个数</li>
</ol>
<p>为了找出销量大于1000的店铺，需要先做一次过滤：<code>filter</code>，你可以看看这个方法的入参就是前面讲到的<code>Predicate</code>断言型函数式接口，
测试一个函数完成后，返回值为<code>boolean</code>。
由于<code>Stream API</code>的风格，我们没有改变集合的内容，而是描述了<code>Stream</code>的内容，最终调用<code>count()</code>方法计算出<code>Stream</code>
里包含了多少个过滤之后的对象，返回值为<code>long</code>。</p>
<h2 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h2><p>你已经知道Java8种在<code>Collection</code>接口添加了<code>Stream</code>方法，可以将任何集合转换成一个<code>Stream</code>。
如果你操作的是一个数组可以使用<code>Stream.of(1, 2, 3)</code>方法将它转换为一个流。</p>
<p>也许有人知道JDK7中添加了一些类库如<code>Files.readAllLines(Paths.get(&quot;/home/biezhi/a.txt&quot;))</code>这样的读取文件行方法。
<code>List</code>作为<code>Collection</code>的子类拥有转换流的方法，那么我们读取这个文本文件到一个字符串变量中将变得更简洁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String content = Files.readAllLines(Paths.get(<span class="string">"/home/biezhi/a.txt"</span>)).stream()</div><div class="line">            .collect(Collectors.joining(<span class="string">"\n"</span>));</div></pre></td></tr></table></figure>
<p>这里的<code>collect</code>是后面要讲解的<strong>收集器</strong>，对<code>Stream</code>进行了处理后得到一个文本文件的内容。</p>
<p>JDK8也为我们提供了一些便捷的<code>Stream</code>相关类库:</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/java8-stream-class.png" alt="java8提供的Stream类库" width="320" height="500" title="">
                </div>
                <div class="image-caption">java8提供的Stream类库</div>
            </figure>
<p>创建一个流是很简单的，下面我们试试用创建好的<code>Stream</code>做一些操作吧。</p>
<h2 id="流操作"><a href="#流操作" class="headerlink" title="流操作"></a>流操作</h2><p><code>java.util.stream.Stream</code>中定义了许多流操作的方法，为了更好的理解<code>Stream API</code>掌握它常用的操作非常重要。
流的操作其实可以分为两类：<strong>处理操作</strong>、<strong>聚合操作</strong>。</p>
<ul>
<li>处理操作：诸如<code>filter</code>、<code>map</code>等处理操作将<code>Stream</code>一层一层的进行抽离，返回一个流给下一层使用。</li>
<li>聚合操作：从最后一次流中生成一个结果给调用方，<code>foreach</code>只做处理不做返回。</li>
</ul>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><code>filter</code>看名字也知道是过滤的意思，我们通常在筛选数据的时候用到，频率非常高。
<code>filter</code>方法的参数是<code>Predicate&lt;T&gt; predicate</code>即一个从<code>T</code>到boolean的函数。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/java8-filter.png" alt="" width="300" height="200" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>筛选出距离我在1000米内的店铺</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">properties.stream()</div><div class="line">            .filter(p -&gt; p.distance &lt; <span class="number">1000</span>)</div></pre></td></tr></table></figure>
<p><strong>筛选出名称大于5个字的店铺</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">properties.stream()</div><div class="line">            .filter(p -&gt; p.name.length() &gt; <span class="number">5</span>);</div></pre></td></tr></table></figure>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>有时候我们需要将流中处理的数据类型进行转换，这时候就可以使用<code>map</code>方法来完成，将流中的值转换为一个新的流。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/java8-map.png" alt="" width="300" height="200" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>列出所有店铺的名称</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">properties.stream()</div><div class="line">            .map(p -&gt; p.name);</div></pre></td></tr></table></figure>
<p>传给<code>map</code>的<code>lambda</code>表达式接收一个<code>Property</code>类型的参数，返回一个<code>String</code>。
参数和返回值不必属于同一种类型，但是<code>lambda</code>表达式必须是<code>Function</code>接口的一个实例。</p>
<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>有时候我们会遇到提取子流的操作，这种情况用的不多但是遇到<code>flatMap</code>将变得更容易处理。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/java8-flatmap.png" alt="" width="300" height="200" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>例如我们有一个<code>List&lt;List&lt;String&gt;&gt;</code>结构的数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">List&lt;List&lt;String&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        lists.add(Arrays.asList(<span class="string">"apple"</span>, <span class="string">"click"</span>));</div><div class="line">        lists.add(Arrays.asList(<span class="string">"boss"</span>, <span class="string">"dig"</span>, <span class="string">"qq"</span>, <span class="string">"vivo"</span>));</div><div class="line">        lists.add(Arrays.asList(<span class="string">"c#"</span>, <span class="string">"biezhi"</span>));</div></pre></td></tr></table></figure>
<p>要做的操作是获取这些数据中长度大于2的单词个数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">lists.stream()</div><div class="line">        .flatMap(Collection::stream)</div><div class="line">        .filter(str -&gt; str.length() &gt; <span class="number">2</span>)</div><div class="line">        .count();</div></pre></td></tr></table></figure>
<p>在不使用<code>flatMap</code>前你可能需要做2次<code>for</code>循环。这里调用了<code>List</code>的<code>stream</code>方法将每个列表转换成<code>Stream</code>对象，
其他的就和之前的操作一样。</p>
<h2 id="max和min"><a href="#max和min" class="headerlink" title="max和min"></a>max和min</h2><p><code>Stream</code>中常用的操作之一是求最大值和最小值，<code>Stream API</code> 中的<code>max</code>和<code>min</code>操作足以解决这一问题。</p>
<p>我们需要筛选出价格最低的店铺:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Property property = properties.stream()</div><div class="line">            .max(Comparator.comparingInt(p -&gt; p.priceLevel))</div><div class="line">            .get();</div></pre></td></tr></table></figure>
<p>查找<code>Stream</code>中的最大或最小元素，首先要考虑的是用什么作为排序的指标。
以查找价格最低的店铺为例，排序的指标就是<strong>店铺的价格等级</strong>。</p>
<p>为了让<code>Stream</code>对象按照价格等级进行排序，需要传给它一个<code>Comparator</code>对象。
Java8提供了一个新的静态方法<code>comparingInt</code>，使用它可以方便地实现一个比较器。
放在以前，我们需要比较两个对象的某项属性的值，现在只需要提供一个存取方法就够了。</p>
<h2 id="收集结果"><a href="#收集结果" class="headerlink" title="收集结果"></a>收集结果</h2><p>通常我们处理完流之后想查看一下结果，比如获取总数，转换结果，在前面的示例中你发现调用了
<code>filter</code>、<code>map</code>之后没有下文了，后续的操作应该调用<code>Stream</code>中的<code>collect</code>方法完成。</p>
<p><strong>获取距离我最近的2个店铺</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">List&lt;Property&gt; properties = properties.stream()</div><div class="line">            .sorted(Comparator.comparingInt(x -&gt; x.distance))</div><div class="line">            .limit(<span class="number">2</span>)</div><div class="line">            .collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p><strong>获取所有店铺的名称</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">List&lt;String&gt; names = properties.stream()</div><div class="line">                      .map(p -&gt; p.name)</div><div class="line">                      .collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p><strong>获取每个店铺的价格等级</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Map&lt;String, Integer&gt; map = properties.stream()</div><div class="line">        .collect(Collectors.toMap(Property::getName, Property::getPriceLevel));</div></pre></td></tr></table></figure>
<p><strong>所有价格等级的店铺列表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Map&lt;Integer, List&lt;Property&gt;&gt; priceMap = properties.stream()</div><div class="line">                .collect(Collectors.groupingBy(Property::getPriceLevel));</div></pre></td></tr></table></figure>
<h2 id="并行数据处理"><a href="#并行数据处理" class="headerlink" title="并行数据处理"></a>并行数据处理</h2><h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><p>并发是两个任务共享时间段，并行则是两个任务在同一时间发生，比如运行在多核CPU上。
如果一个程序要运行两个任务，并且只有一个CPU给它们分配了不同的时间片，那么这就是并发，而不是并行。</p>
<blockquote>
<p>并行化是指为缩短任务执行时间，将一个任务分解成几部分，然后并行执行。</p>
</blockquote>
<p>这和顺序执行的任务量是一样的，区别就像用更多的马来拉车，花费的时间自然减少了。
实际上，和顺序执行相比，并行化执行任务时，CPU承载的工作量更大。</p>
<blockquote>
<p>数据并行化是指将数据分成块，为每块数据分配单独的处理单元。</p>
</blockquote>
<p>还是拿马拉车那个例子打比方，就像从车里取出一些货物，放到另一辆车上，两辆马车都沿着同样的路径到达目的地。</p>
<p>当需要在大量数据上执行同样的操作时，数据并行化很管用。
它将问题分解为可在多块数据上求解的形式，然后对每块数据执行运算，最后将各数据块上得到的结果汇总，从而获得最终答案。</p>
<p>人们经常拿任务并行化和数据并行化做比较，在任务并行化中，线程不同，工作各异。
我们最常遇到的JavaEE应用容器便是任务并行化的例子之一，每个线程不光可以为不同用户服务，
还可以为同一个用户执行不同的任务，比如登录或往购物车添加商品。</p>
<h3 id="Stream并行流"><a href="#Stream并行流" class="headerlink" title="Stream并行流"></a>Stream并行流</h3><p>流使得计算变得容易，它的操作也非常简单，但你需要遵守一些约定。默认情况下我们使用集合的<code>stream</code>方法
创建的是一个串行流，你有两种办法让他变成并行流。</p>
<ol>
<li>调用<code>Stream</code>对象的<code>parallel</code>方法</li>
<li>创建流的时候调用<code>parallelStream</code>而不是<code>stream</code>方法</li>
</ol>
<p>我们来用具体的例子来解释串行和并行流</p>
<p><strong>串行化计算</strong></p>
<p>筛选出价格等级小于4，按照距离排序的2个店铺名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">properties.stream()</div><div class="line">            .filter(p -&gt; p.priceLevel &lt; <span class="number">4</span>)</div><div class="line">            .sorted(Comparator.comparingInt(Property::getDistance))</div><div class="line">            .map(Property::getName)</div><div class="line">            .limit(<span class="number">2</span>)</div><div class="line">            .collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p>调用 parallelStream 方法即能并行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">properties.parallelStream()</div><div class="line">            .filter(p -&gt; p.priceLevel &lt; <span class="number">4</span>)</div><div class="line">            .sorted(Comparator.comparingInt(Property::getDistance))</div><div class="line">            .map(Property::getName)</div><div class="line">            .limit(<span class="number">2</span>)</div><div class="line">            .collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p>读到这里，大家的第一反应可能是立即将手头代码中的<code>stream</code>方法替换为<code>parallelStream</code>方法，
因为这样做简直太简单了！先别忙，为了将硬件物尽其用，利用好并行化非常重要，但流类库提供的数据并行化只是其中的一种形式。</p>
<p>我们先要问自己一个问题：<code>并行化运行基于流的代码是否比串行化运行更快？</code>这不是一个简单的问题。
回到前面的例子，哪种方式花的时间更多取决于串行或并行化运行时的环境。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面我们简单介绍了&lt;code&gt;lambda&lt;/code&gt;表达式，Java8旨在帮助程序员写出更好的代码，
其对核心类库的改进也是关键的一部分，&lt;code&gt;Stream&lt;/code&gt;是Java8种处理集合的抽象概念，
它可以指定你希望对集合的操作，但是执行操作的时间交给具体实现来决定。&lt;/p&gt;
    
    </summary>
    
      <category term="跟上Java8" scheme="http://biezhi.me/categories/%E8%B7%9F%E4%B8%8AJava8/"/>
    
    
      <category term="Java8" scheme="http://biezhi.me/tags/Java8/"/>
    
      <category term="stream" scheme="http://biezhi.me/tags/stream/"/>
    
      <category term="flatmap" scheme="http://biezhi.me/tags/flatmap/"/>
    
      <category term="filter" scheme="http://biezhi.me/tags/filter/"/>
    
      <category term="collect" scheme="http://biezhi.me/tags/collect/"/>
    
  </entry>
  
  <entry>
    <title>跟上Java8 - 了解lambda</title>
    <link href="http://biezhi.me/2017/07/17/keep-up-with-java8-lambda.html"/>
    <id>http://biezhi.me/2017/07/17/keep-up-with-java8-lambda.html</id>
    <published>2017-07-16T16:00:00.000Z</published>
    <updated>2017-07-21T15:22:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>从<code>java8</code>出现以来<code>lambda</code>是最重要的特性之一，它可以让我们用简洁流畅的代码完成一个功能。
很长一段时间<code>java</code>被吐槽是冗余和缺乏函数式编程能力的语言，随着函数式编程的流行<code>java8</code>种也引入了
这种编程风格。在此之前我们都在写匿名内部类干这些事，但有时候这不是好的做法，本文中将介绍和使用<code>lambda</code>，
带你体验函数式编程的魔力。</p>
<a id="more"></a>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/lambda-expression.png" alt="lambda表达式" width="500" height="180" title="">
                </div>
                <div class="image-caption">lambda表达式</div>
            </figure>
<h2 id="什么是lambda"><a href="#什么是lambda" class="headerlink" title="什么是lambda?"></a>什么是lambda?</h2><p>lambda表达式是一段可以传递的代码，它的核心思想是将面向对象中的传递数据变成传递行为。
我们回顾一下在使用java8之前要做的事，之前我们编写一个线程时是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Runnable r = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"do something."</span>);      </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也有人会写一个类去实现<code>Runnable</code>接口，这样做没有问题，我们注意这个接口中只有一个<code>run</code>方法，
当把<code>Runnable</code>对象给<code>Thread</code>对象作为构造参数时创建一个线程，运行后将输出<code>do something.</code>。
我们使用匿名内部类的方式实现了该方法。</p>
<blockquote>
<p>这实际上是一个代码即数据的例子，在<code>run</code>方法中是线程要执行的一个任务，但上面的代码中任务内容已经被规定死了。
当我们有多个不同的任务时，需要重复编写如上代码。</p>
</blockquote>
<p>设计匿名内部类的目的，就是为了方便 Java 程序员将代码作为数据传递。不过，匿名内部 类还是不够简便。
为了执行一个简单的任务逻辑，不得不加上 6 行冗繁的样板代码。那如果是<code>lambda</code>该怎么做?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Runnable r = () -&gt; System.out.println(<span class="string">"do something."</span>);</div></pre></td></tr></table></figure>
<p>嗯，这代码看起来很酷，你可以看到我们用<code>()</code>和<code>-&gt;</code>的方式完成了这件事，这是一个没有名字的函数，也没有人和参数，再简单不过了。
使用<code>-&gt;</code>将参数和实现逻辑分离，当运行这个线程的时候执行的是<code>-&gt;</code>之后的代码片段，且编译器帮助我们做了类型推导；
这个代码片段可以是用<code>{}</code>包含的一段逻辑。下面一起来学习一下<code>lambda</code>的语法。</p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p>在<code>lambda</code>中我们遵循如下的表达式来编写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">expression = (variable) -&gt; action</div></pre></td></tr></table></figure>
<ul>
<li><strong>variable</strong>: 这是一个变量,一个占位符。像<code>x</code>,<code>y</code>,<code>z</code>,可以是多个变量。</li>
<li><strong>action</strong>: 这里我称它为<code>action</code>, 这是我们实现的代码逻辑部分,它可以是一行代码也可以是一个代码片段</li>
</ul>
<p>可以看到Java中lambda表达式的格式：参数、箭头、以及动作实现，当一个动作实现无法用一行代码完成，可以编写
一段代码用<code>{}</code>包裹起来。</p>
<p>lambda表达式可以包含多个参数,例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> sum = (x, y) -&gt; x + y;</div></pre></td></tr></table></figure>
<p>这时候我们应该思考这段代码不是之前的x和y数字相加，而是创建了一个函数，用来计算两个操作数的和。
后面用<code>int</code>类型进行接收，在lambda中为我们省略去了<code>return</code>。</p>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口是只有一个方法的接口，用作lambda表达式的类型。前面写的例子就是一个函数式接口，来看看jdk中的<code>Runnable</code>源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</div><div class="line">     * to create a thread, starting the thread causes the object's</div><div class="line">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</div><div class="line">     * thread.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</div><div class="line">     * take any action whatsoever.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@see</span>     java.lang.Thread#run()</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里只有一个抽象方法<code>run</code>，实际上你不写<code>public abstract</code>也是可以的，在接口中定义的方法都是<code>public abstract</code>的。
同时也使用注解<code>@FunctionalInterface</code>告诉编译器这是一个函数式接口，当然你不这么写也可以，标识后明确了这个函数中
只有一个抽象方法，当你尝试在接口中编写多个方法的时候编译器将不允许这么干。</p>
<h3 id="尝试函数式接口"><a href="#尝试函数式接口" class="headerlink" title="尝试函数式接口"></a>尝试函数式接口</h3><p>我们来编写一个函数式接口，输入一个年龄，判断这个人是否是成人。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionInterfaceDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@FunctionalInterface</span></div><div class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行Predicate判断</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> age       年龄</div><div class="line">     * <span class="doctag">@param</span> predicate Predicate函数式接口</div><div class="line">     * <span class="doctag">@return</span>          返回布尔类型结果</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">doPredicate</span><span class="params">(<span class="keyword">int</span> age, Predicate&lt;Integer&gt; predicate)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> predicate.test(age);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> isAdult = doPredicate(<span class="number">20</span>, x -&gt; x &gt;= <span class="number">18</span>);</div><div class="line">        System.out.println(isAdult);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这个例子我们很轻松的完成 <strong>是否是成人</strong> 的动作，其次判断是否是成人，在此之前我们的做法一般是编写一个
判断是否是成人的方法，是无法将 <strong>判断</strong> 共用的。而在本例只，你要做的是将 <strong>行为</strong> (判断是否是成人，或者是判断是否大于30岁)
传递进去，函数式接口告诉你结果是什么。</p>
<p>实际上诸如上述例子中的接口，伟大的jdk设计者为我们准备了<code>java.util.function</code>包</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/java8-util-function-package.png" alt="" width="300" height="500" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>我们前面写的<code>Predicate</code>函数式接口也是JDK种的一个实现，他们大致分为以下几类：</p>
<table>
<thead>
<tr>
<th>接口</th>
<th style="text-align:center">参数</th>
<th style="text-align:center">返回值</th>
<th>类别</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Consumer<t></t></td>
<td style="text-align:center">T</td>
<td style="text-align:center">void</td>
<td>消费型接口</td>
<td>输出一个值</td>
</tr>
<tr>
<td>Supplier<t></t></td>
<td style="text-align:center">None</td>
<td style="text-align:center">T</td>
<td>供给型接口</td>
<td>工厂方法</td>
</tr>
<tr>
<td>Function<t, r=""></t,></td>
<td style="text-align:center">T</td>
<td style="text-align:center">R</td>
<td>函数型接口</td>
<td>获得 Artist 对象的名字</td>
</tr>
<tr>
<td>Predicate<t></t></td>
<td style="text-align:center">T</td>
<td style="text-align:center">boolean</td>
<td>断言型接口</td>
<td>这张唱片已经发行了吗</td>
</tr>
</tbody>
</table>
<p><strong>消费型接口示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">donation</span><span class="params">(Integer money, Consumer&lt;Integer&gt; consumer)</span></span>&#123;</div><div class="line">    consumer.accept(money);  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    donation(<span class="number">1000</span>, money -&gt; System.out.println(<span class="string">"好心的麦乐迪为Blade捐赠了"</span>+money+<span class="string">"元"</span>)) ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>供给型接口示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">supply</span><span class="params">(Integer num, Supplier&lt;Integer&gt; supplier)</span></span>&#123;</div><div class="line">       List&lt;Integer&gt; resultList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;()   ;</div><div class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;num;x++)  </div><div class="line">           resultList.add(supplier.get());</div><div class="line">       <span class="keyword">return</span> resultList ;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; list = supply(<span class="number">10</span>,() -&gt; (<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>));</div><div class="line">    list.forEach(System.out::println);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>函数型接口示例</strong></p>
<p>转换字符串为<code>Integer</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">convert</span><span class="params">(String str, Function&lt;String, Integer&gt; function)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> function.apply(str);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Integer value = convert(<span class="string">"28"</span>, x -&gt; Integer.parseInt(x));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>断言型接口示例</strong></p>
<p>筛选出只有2个字的水果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">filter</span><span class="params">(List&lt;String&gt; fruit, Predicate&lt;String&gt; predicate)</span></span>&#123;</div><div class="line">    List&lt;String&gt; f = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (String s : fruit) &#123;</div><div class="line">        <span class="keyword">if</span>(predicate.test(s))&#123;</div><div class="line">            f.add(s);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> f;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    List&lt;String&gt; fruit = Arrays.asList(<span class="string">"香蕉"</span>, <span class="string">"哈密瓜"</span>, <span class="string">"榴莲"</span>, <span class="string">"火龙果"</span>, <span class="string">"水蜜桃"</span>);</div><div class="line">    List&lt;String&gt; newFruit = filter(fruit, (f) -&gt; f.length() == <span class="number">2</span>);</div><div class="line">    System.out.println(newFruit);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>在Java语言中，一个接口中定义的方法必须由实现类提供实现。但是当接口中加入新的API时，
实现类按照约定也要修改实现，而Java8的API对现有接口也添加了很多方法，比如<code>List</code>接口中添加了<code>sort</code>方法。
如果按照之前的做法，那么所有的实现类都要实现<code>sort</code>方法，JDK的编写者们一定非常抓狂。</p>
<p>幸运的是我们使用了Java8，这一问题将得到很好的解决，在Java8种引入新的机制，<strong>支持在接口中声明方法同时提供实现</strong>。
这令人激动不已，你有两种方式完成 1.在接口内声明静态方法 2.指定一个默认方法。</p>
<p>我们来看看在JDK8中上述<code>List</code>接口添加方法的问题是如何解决的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</div><div class="line">    Object[] a = <span class="keyword">this</span>.toArray();</div><div class="line">    Arrays.sort(a, (Comparator) c);</div><div class="line">    ListIterator&lt;E&gt; i = <span class="keyword">this</span>.listIterator();</div><div class="line">    <span class="keyword">for</span> (Object e : a) &#123;</div><div class="line">        i.next();</div><div class="line">        i.set((E) e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>翻阅<code>List</code>接口的源码，其中加入一个默认方法<code>default void sort(Comparator&lt;? super E&gt; c)</code>。
在返回值之前加入<code>default</code>关键字，有了这个方法我们可以直接调用<code>sort</code>方法进行排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>);</div><div class="line">list.sort(Comparator.naturalOrder());</div><div class="line">System.out.println(list);</div></pre></td></tr></table></figure>
<p><code>Comparator.naturalOrder()</code>是一个自然排序的实现，这里可以自定义排序方案。
你经常看到使用Java8操作集合的时候可以直接foreach的原因也是在<code>Iterable</code>接口中也新增了一个默认方法：<code>forEach</code> ，
该方法功能和 for 循环类似，但是允许 用户使用一个<code>Lambda</code>表达式作为循环体。</p>
<p>在后面的章节中我们再次通过案例来展示函数式编程的魅力 :)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从&lt;code&gt;java8&lt;/code&gt;出现以来&lt;code&gt;lambda&lt;/code&gt;是最重要的特性之一，它可以让我们用简洁流畅的代码完成一个功能。
很长一段时间&lt;code&gt;java&lt;/code&gt;被吐槽是冗余和缺乏函数式编程能力的语言，随着函数式编程的流行&lt;code&gt;java8&lt;/code&gt;种也引入了
这种编程风格。在此之前我们都在写匿名内部类干这些事，但有时候这不是好的做法，本文中将介绍和使用&lt;code&gt;lambda&lt;/code&gt;，
带你体验函数式编程的魔力。&lt;/p&gt;
    
    </summary>
    
      <category term="跟上Java8" scheme="http://biezhi.me/categories/%E8%B7%9F%E4%B8%8AJava8/"/>
    
    
      <category term="Java8" scheme="http://biezhi.me/tags/Java8/"/>
    
      <category term="lambda" scheme="http://biezhi.me/tags/lambda/"/>
    
      <category term="functional-interface" scheme="http://biezhi.me/tags/functional-interface/"/>
    
  </entry>
  
  <entry>
    <title>跟上Java8系列文章 - 带你实战Java8</title>
    <link href="http://biezhi.me/2017/07/16/keep-up-with-java8.html"/>
    <id>http://biezhi.me/2017/07/16/keep-up-with-java8.html</id>
    <published>2017-07-15T16:00:00.000Z</published>
    <updated>2017-07-22T07:02:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Java8</code>从<code>2014</code>年出现至今已经三年有余，这里发布的新功能是自Java1.0发布18年来最大变化的。
没有去处任何API，我们仍然能兼容以前的代码，新功能中提供了更多的语法和设计，帮助开发者编写更清楚、简洁的代码。
Java8把函数式编程里一些最好的思想融入到大家熟知的Java语法中，让你用更少的时间写出高效代码。</p>
<a id="more"></a>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/static/img/article/java8-banner.png" alt="开启Java8之路" width="500" height="300" title="">
                </div>
                <div class="image-caption">开启Java8之路</div>
            </figure>
<p>而目前国内很多开发者的现状还处于<code>Java6</code>的语法之上，这确实没什么问题，可以保证你的企业软件稳定运行下去。
但时代总是变化的，我们熟悉的Spring框架也对java8做了更好的支持。
大势所趋，为何不跟上<code>Java8</code>的节奏一起体验现代高级编程语言中的新特性呢？
现在我可以带你深入浅出跟上<code>Java8</code>，这一系列文章写了那些我认为有用所关注的一些内容，如果你对更详细的细节感兴趣可以查阅相关书籍。</p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul>
<li>代码行更少</li>
<li>lambda表达式</li>
<li>Stream API</li>
<li>便于并行</li>
<li>减少空指针</li>
<li>jvm优化</li>
<li>兼容老版本</li>
</ul>
<h2 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h2><ol>
<li><a href="/2017/07/17/keep-up-with-java8-lambda.html">跟上Java8 - 了解lambda</a></li>
<li><a href="/2017/07/18/keep-up-with-java8-stream.html">跟上Java8 - Stream API快速入门</a></li>
<li><a href="/2017/07/19/keep-up-with-java8-functional-programming.html">跟上Java8 - 函数式编程</a></li>
<li><a href="/2017/07/20/keep-up-with-java8-datetime.html">跟上Java8 - 日期和时间实用技巧</a></li>
<li><a href="/2017/07/21/keep-up-with-java8-features.html">跟上Java8 - 你忽略了的新特性</a></li>
<li><a href="/2017/07/22/keep-up-with-java8-concurrent.html">跟上Java8 - 使用lambda并发编程</a></li>
<li><a href="/2017/07/23/keep-up-with-java8-tips.html">跟上Java8 - 七七八八的黑科技</a></li>
<li><a href="/2017/07/23/keep-up-with-java8-tips.html">跟上Java8 - 优化工作中那些屎代码</a></li>
<li><a href="/2017/07/24/keep-up-with-java8-complex-examples.html">跟上Java8 - 复杂一点的例子</a></li>
</ol>
<h2 id="资料分享"><a href="#资料分享" class="headerlink" title="资料分享"></a>资料分享</h2><ul>
<li><a href="http://winterbe.com/projects/java8-explorer" target="_blank" rel="external">在线查看Java8新增API</a></li>
<li><a href="https://github.com/shekhargulati/java8-the-missing-tutorial" target="_blank" rel="external">java8-the-missing-tutorial</a></li>
<li><a href="https://github.com/winterbe/java8-tutorial" target="_blank" rel="external">java8-tutorial</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Java8&lt;/code&gt;从&lt;code&gt;2014&lt;/code&gt;年出现至今已经三年有余，这里发布的新功能是自Java1.0发布18年来最大变化的。
没有去处任何API，我们仍然能兼容以前的代码，新功能中提供了更多的语法和设计，帮助开发者编写更清楚、简洁的代码。
Java8把函数式编程里一些最好的思想融入到大家熟知的Java语法中，让你用更少的时间写出高效代码。&lt;/p&gt;
    
    </summary>
    
      <category term="跟上Java8" scheme="http://biezhi.me/categories/%E8%B7%9F%E4%B8%8AJava8/"/>
    
    
      <category term="Java8" scheme="http://biezhi.me/tags/Java8/"/>
    
      <category term="lambda" scheme="http://biezhi.me/tags/lambda/"/>
    
      <category term="系列" scheme="http://biezhi.me/tags/%E7%B3%BB%E5%88%97/"/>
    
      <category term="stream-api" scheme="http://biezhi.me/tags/stream-api/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://biezhi.me/2017/07/15/hello-world.html"/>
    <id>http://biezhi.me/2017/07/15/hello-world.html</id>
    <published>2017-07-14T16:00:00.000Z</published>
    <updated>2017-07-16T02:39:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>博客换了主题，以前的文章在github的分支上保存，以后在这里重新写点东西。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客换了主题，以前的文章在github的分支上保存，以后在这里重新写点东西。&lt;/p&gt;

    
    </summary>
    
    
      <category term="blog" scheme="http://biezhi.me/tags/blog/"/>
    
      <category term="hello-world" scheme="http://biezhi.me/tags/hello-world/"/>
    
  </entry>
  
</feed>
